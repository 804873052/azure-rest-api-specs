// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armquantum

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type BlobDetails.
func (b BlobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobName", b.BlobName)
	populate(objectMap, "containerName", b.ContainerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BlobDetails.
func (b *BlobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobName":
				err = unpopulate(val, "BlobName", &b.BlobName)
			delete(rawMsg, key)
		case "containerName":
				err = unpopulate(val, "ContainerName", &b.ContainerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CostEstimate.
func (c CostEstimate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currencyCode", c.CurrencyCode)
	populate(objectMap, "estimatedTotal", c.EstimatedTotal)
	populate(objectMap, "events", c.Events)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CostEstimate.
func (c *CostEstimate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currencyCode":
				err = unpopulate(val, "CurrencyCode", &c.CurrencyCode)
			delete(rawMsg, key)
		case "estimatedTotal":
				err = unpopulate(val, "EstimatedTotal", &c.EstimatedTotal)
			delete(rawMsg, key)
		case "events":
				err = unpopulate(val, "Events", &c.Events)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Error.
func (e Error) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "innererror", e.Innererror)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Error.
func (e *Error) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &e.Details)
			delete(rawMsg, key)
		case "innererror":
				err = unpopulate(val, "Innererror", &e.Innererror)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &e.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &e.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InnerError.
func (i InnerError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", i.Code)
	populate(objectMap, "innererror", i.Innererror)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InnerError.
func (i *InnerError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &i.Code)
			delete(rawMsg, key)
		case "innererror":
				err = unpopulate(val, "Innererror", &i.Innererror)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ItemDetails.
func (i ItemDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "beginExecutionTime", i.BeginExecutionTime)
	populate(objectMap, "costEstimate", i.CostEstimate)
	populateDateTimeRFC3339(objectMap, "creationTime", i.CreationTime)
	populateDateTimeRFC3339(objectMap, "endExecutionTime", i.EndExecutionTime)
	populate(objectMap, "errorData", i.ErrorData)
	populate(objectMap, "id", i.ID)
	populate(objectMap, "itemType", i.ItemType)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "providerId", i.ProviderID)
	populate(objectMap, "target", i.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ItemDetails.
func (i *ItemDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "beginExecutionTime":
				err = unpopulateDateTimeRFC3339(val, "BeginExecutionTime", &i.BeginExecutionTime)
			delete(rawMsg, key)
		case "costEstimate":
				err = unpopulate(val, "CostEstimate", &i.CostEstimate)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &i.CreationTime)
			delete(rawMsg, key)
		case "endExecutionTime":
				err = unpopulateDateTimeRFC3339(val, "EndExecutionTime", &i.EndExecutionTime)
			delete(rawMsg, key)
		case "errorData":
				err = unpopulate(val, "ErrorData", &i.ErrorData)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &i.ID)
			delete(rawMsg, key)
		case "itemType":
				err = unpopulate(val, "ItemType", &i.ItemType)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "providerId":
				err = unpopulate(val, "ProviderID", &i.ProviderID)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &i.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JSONPatchObject.
func (j JSONPatchObject) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "from", j.From)
	populate(objectMap, "op", j.Operation)
	populate(objectMap, "path", j.Path)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JSONPatchObject.
func (j *JSONPatchObject) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "from":
				err = unpopulate(val, "From", &j.From)
			delete(rawMsg, key)
		case "op":
				err = unpopulate(val, "Operation", &j.Operation)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &j.Path)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &j.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobDetails.
func (j JobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "beginExecutionTime", j.BeginExecutionTime)
	populateDateTimeRFC3339(objectMap, "cancellationTime", j.CancellationTime)
	populate(objectMap, "containerUri", j.ContainerURI)
	populate(objectMap, "costEstimate", j.CostEstimate)
	populateDateTimeRFC3339(objectMap, "creationTime", j.CreationTime)
	populateDateTimeRFC3339(objectMap, "endExecutionTime", j.EndExecutionTime)
	populate(objectMap, "errorData", j.ErrorData)
	populate(objectMap, "id", j.ID)
	populate(objectMap, "inputDataFormat", j.InputDataFormat)
	populate(objectMap, "inputDataUri", j.InputDataURI)
	populate(objectMap, "inputParams", j.InputParams)
	objectMap["itemType"] = ItemTypeJob
	populate(objectMap, "jobType", j.JobType)
	populate(objectMap, "metadata", j.Metadata)
	populate(objectMap, "name", j.Name)
	populate(objectMap, "outputDataFormat", j.OutputDataFormat)
	populate(objectMap, "outputDataUri", j.OutputDataURI)
	populate(objectMap, "providerId", j.ProviderID)
	populate(objectMap, "quantumComputingData", j.QuantumComputingData)
	populate(objectMap, "sessionId", j.SessionID)
	populate(objectMap, "status", j.Status)
	populate(objectMap, "tags", j.Tags)
	populate(objectMap, "target", j.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobDetails.
func (j *JobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "beginExecutionTime":
				err = unpopulateDateTimeRFC3339(val, "BeginExecutionTime", &j.BeginExecutionTime)
			delete(rawMsg, key)
		case "cancellationTime":
				err = unpopulateDateTimeRFC3339(val, "CancellationTime", &j.CancellationTime)
			delete(rawMsg, key)
		case "containerUri":
				err = unpopulate(val, "ContainerURI", &j.ContainerURI)
			delete(rawMsg, key)
		case "costEstimate":
				err = unpopulate(val, "CostEstimate", &j.CostEstimate)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &j.CreationTime)
			delete(rawMsg, key)
		case "endExecutionTime":
				err = unpopulateDateTimeRFC3339(val, "EndExecutionTime", &j.EndExecutionTime)
			delete(rawMsg, key)
		case "errorData":
				err = unpopulate(val, "ErrorData", &j.ErrorData)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &j.ID)
			delete(rawMsg, key)
		case "inputDataFormat":
				err = unpopulate(val, "InputDataFormat", &j.InputDataFormat)
			delete(rawMsg, key)
		case "inputDataUri":
				err = unpopulate(val, "InputDataURI", &j.InputDataURI)
			delete(rawMsg, key)
		case "inputParams":
				err = unpopulate(val, "InputParams", &j.InputParams)
			delete(rawMsg, key)
		case "itemType":
				err = unpopulate(val, "ItemType", &j.ItemType)
			delete(rawMsg, key)
		case "jobType":
				err = unpopulate(val, "JobType", &j.JobType)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &j.Metadata)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &j.Name)
			delete(rawMsg, key)
		case "outputDataFormat":
				err = unpopulate(val, "OutputDataFormat", &j.OutputDataFormat)
			delete(rawMsg, key)
		case "outputDataUri":
				err = unpopulate(val, "OutputDataURI", &j.OutputDataURI)
			delete(rawMsg, key)
		case "providerId":
				err = unpopulate(val, "ProviderID", &j.ProviderID)
			delete(rawMsg, key)
		case "quantumComputingData":
				err = unpopulate(val, "QuantumComputingData", &j.QuantumComputingData)
			delete(rawMsg, key)
		case "sessionId":
				err = unpopulate(val, "SessionID", &j.SessionID)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &j.Status)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &j.Tags)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &j.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedItemDetails.
func (p PagedItemDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedItemDetails.
func (p *PagedItemDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
			p.Value, err = unmarshalItemDetailsClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedJobDetails.
func (p PagedJobDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedJobDetails.
func (p *PagedJobDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedProviderStatus.
func (p PagedProviderStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedProviderStatus.
func (p *PagedProviderStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedQuota.
func (p PagedQuota) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedQuota.
func (p *PagedQuota) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedSessionDetails.
func (p PagedSessionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedSessionDetails.
func (p *PagedSessionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProviderStatus.
func (p ProviderStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "currentAvailability", p.CurrentAvailability)
	populate(objectMap, "id", p.ID)
	populate(objectMap, "targets", p.Targets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProviderStatus.
func (p *ProviderStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "currentAvailability":
				err = unpopulate(val, "CurrentAvailability", &p.CurrentAvailability)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &p.ID)
			delete(rawMsg, key)
		case "targets":
				err = unpopulate(val, "Targets", &p.Targets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QuantumComputingData.
func (q QuantumComputingData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "count", q.Count)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QuantumComputingData.
func (q *QuantumComputingData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "count":
				err = unpopulate(val, "Count", &q.Count)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type Quota.
func (q Quota) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dimension", q.Dimension)
	populate(objectMap, "holds", q.Holds)
	populate(objectMap, "limit", q.Limit)
	populate(objectMap, "period", q.Period)
	populate(objectMap, "providerId", q.ProviderID)
	populate(objectMap, "scope", q.Scope)
	populate(objectMap, "utilization", q.Utilization)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Quota.
func (q *Quota) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dimension":
				err = unpopulate(val, "Dimension", &q.Dimension)
			delete(rawMsg, key)
		case "holds":
				err = unpopulate(val, "Holds", &q.Holds)
			delete(rawMsg, key)
		case "limit":
				err = unpopulate(val, "Limit", &q.Limit)
			delete(rawMsg, key)
		case "period":
				err = unpopulate(val, "Period", &q.Period)
			delete(rawMsg, key)
		case "providerId":
				err = unpopulate(val, "ProviderID", &q.ProviderID)
			delete(rawMsg, key)
		case "scope":
				err = unpopulate(val, "Scope", &q.Scope)
			delete(rawMsg, key)
		case "utilization":
				err = unpopulate(val, "Utilization", &q.Utilization)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SasURIResponse.
func (s SasURIResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "sasUri", s.SasURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SasURIResponse.
func (s *SasURIResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sasUri":
				err = unpopulate(val, "SasURI", &s.SasURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SessionDetails.
func (s SessionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "beginExecutionTime", s.BeginExecutionTime)
	populate(objectMap, "costEstimate", s.CostEstimate)
	populateDateTimeRFC3339(objectMap, "creationTime", s.CreationTime)
	populateDateTimeRFC3339(objectMap, "endExecutionTime", s.EndExecutionTime)
	populate(objectMap, "errorData", s.ErrorData)
	populate(objectMap, "id", s.ID)
	objectMap["itemType"] = ItemTypeSession
	populate(objectMap, "jobFailurePolicy", s.JobFailurePolicy)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "providerId", s.ProviderID)
	populate(objectMap, "status", s.Status)
	populate(objectMap, "target", s.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SessionDetails.
func (s *SessionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "beginExecutionTime":
				err = unpopulateDateTimeRFC3339(val, "BeginExecutionTime", &s.BeginExecutionTime)
			delete(rawMsg, key)
		case "costEstimate":
				err = unpopulate(val, "CostEstimate", &s.CostEstimate)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &s.CreationTime)
			delete(rawMsg, key)
		case "endExecutionTime":
				err = unpopulateDateTimeRFC3339(val, "EndExecutionTime", &s.EndExecutionTime)
			delete(rawMsg, key)
		case "errorData":
				err = unpopulate(val, "ErrorData", &s.ErrorData)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		case "itemType":
				err = unpopulate(val, "ItemType", &s.ItemType)
			delete(rawMsg, key)
		case "jobFailurePolicy":
				err = unpopulate(val, "JobFailurePolicy", &s.JobFailurePolicy)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &s.Name)
			delete(rawMsg, key)
		case "providerId":
				err = unpopulate(val, "ProviderID", &s.ProviderID)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &s.Status)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &s.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TargetStatus.
func (t TargetStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "averageQueueTime", t.AverageQueueTime)
	populate(objectMap, "currentAvailability", t.CurrentAvailability)
	populate(objectMap, "id", t.ID)
	populate(objectMap, "statusPage", t.StatusPage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TargetStatus.
func (t *TargetStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "averageQueueTime":
				err = unpopulate(val, "AverageQueueTime", &t.AverageQueueTime)
			delete(rawMsg, key)
		case "currentAvailability":
				err = unpopulate(val, "CurrentAvailability", &t.CurrentAvailability)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &t.ID)
			delete(rawMsg, key)
		case "statusPage":
				err = unpopulate(val, "StatusPage", &t.StatusPage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UsageEvent.
func (u UsageEvent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "amountBilled", u.AmountBilled)
	populate(objectMap, "amountConsumed", u.AmountConsumed)
	populate(objectMap, "dimensionId", u.DimensionID)
	populate(objectMap, "dimensionName", u.DimensionName)
	populate(objectMap, "measureUnit", u.MeasureUnit)
	populate(objectMap, "unitPrice", u.UnitPrice)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UsageEvent.
func (u *UsageEvent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "amountBilled":
				err = unpopulate(val, "AmountBilled", &u.AmountBilled)
			delete(rawMsg, key)
		case "amountConsumed":
				err = unpopulate(val, "AmountConsumed", &u.AmountConsumed)
			delete(rawMsg, key)
		case "dimensionId":
				err = unpopulate(val, "DimensionID", &u.DimensionID)
			delete(rawMsg, key)
		case "dimensionName":
				err = unpopulate(val, "DimensionName", &u.DimensionName)
			delete(rawMsg, key)
		case "measureUnit":
				err = unpopulate(val, "MeasureUnit", &u.MeasureUnit)
			delete(rawMsg, key)
		case "unitPrice":
				err = unpopulate(val, "UnitPrice", &u.UnitPrice)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkspaceItemError.
func (w WorkspaceItemError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", w.Code)
	populate(objectMap, "details", w.Details)
	populate(objectMap, "innererror", w.Innererror)
	populate(objectMap, "message", w.Message)
	populate(objectMap, "target", w.Target)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkspaceItemError.
func (w *WorkspaceItemError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &w.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &w.Details)
			delete(rawMsg, key)
		case "innererror":
				err = unpopulate(val, "Innererror", &w.Innererror)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &w.Message)
			delete(rawMsg, key)
		case "target":
				err = unpopulate(val, "Target", &w.Target)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

