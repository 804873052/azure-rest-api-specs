// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armcognitiveservices

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AddOrUpdateTextBlocklistItemsOptions.
func (a AddOrUpdateTextBlocklistItemsOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistItems", a.BlocklistItems)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddOrUpdateTextBlocklistItemsOptions.
func (a *AddOrUpdateTextBlocklistItemsOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistItems":
				err = unpopulate(val, "BlocklistItems", &a.BlocklistItems)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AddOrUpdateTextBlocklistItemsResult.
func (a AddOrUpdateTextBlocklistItemsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistItems", a.BlocklistItems)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AddOrUpdateTextBlocklistItemsResult.
func (a *AddOrUpdateTextBlocklistItemsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistItems":
				err = unpopulate(val, "BlocklistItems", &a.BlocklistItems)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeImageOptions.
func (a AnalyzeImageOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "categories", a.Categories)
	populate(objectMap, "image", a.Image)
	populate(objectMap, "outputType", a.OutputType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeImageOptions.
func (a *AnalyzeImageOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "categories":
				err = unpopulate(val, "Categories", &a.Categories)
			delete(rawMsg, key)
		case "image":
				err = unpopulate(val, "Image", &a.Image)
			delete(rawMsg, key)
		case "outputType":
				err = unpopulate(val, "OutputType", &a.OutputType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeImageResult.
func (a AnalyzeImageResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "categoriesAnalysis", a.CategoriesAnalysis)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeImageResult.
func (a *AnalyzeImageResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "categoriesAnalysis":
				err = unpopulate(val, "CategoriesAnalysis", &a.CategoriesAnalysis)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextGroundednessOptions.
func (a AnalyzeTextGroundednessOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "domain", a.Domain)
	populate(objectMap, "groundingSources", a.GroundingSources)
	populate(objectMap, "llmResource", a.LlmResource)
	populate(objectMap, "qna", a.Qna)
	populate(objectMap, "reasoning", a.Reasoning)
	populate(objectMap, "task", a.Task)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextGroundednessOptions.
func (a *AnalyzeTextGroundednessOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "domain":
				err = unpopulate(val, "Domain", &a.Domain)
			delete(rawMsg, key)
		case "groundingSources":
				err = unpopulate(val, "GroundingSources", &a.GroundingSources)
			delete(rawMsg, key)
		case "llmResource":
				err = unpopulate(val, "LlmResource", &a.LlmResource)
			delete(rawMsg, key)
		case "qna":
				err = unpopulate(val, "Qna", &a.Qna)
			delete(rawMsg, key)
		case "reasoning":
				err = unpopulate(val, "Reasoning", &a.Reasoning)
			delete(rawMsg, key)
		case "task":
				err = unpopulate(val, "Task", &a.Task)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextGroundednessResult.
func (a AnalyzeTextGroundednessResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ungroundedDetails", a.UngroundedDetails)
	populate(objectMap, "ungroundedDetected", a.UngroundedDetected)
	populate(objectMap, "ungroundedPercentage", a.UngroundedPercentage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextGroundednessResult.
func (a *AnalyzeTextGroundednessResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ungroundedDetails":
				err = unpopulate(val, "UngroundedDetails", &a.UngroundedDetails)
			delete(rawMsg, key)
		case "ungroundedDetected":
				err = unpopulate(val, "UngroundedDetected", &a.UngroundedDetected)
			delete(rawMsg, key)
		case "ungroundedPercentage":
				err = unpopulate(val, "UngroundedPercentage", &a.UngroundedPercentage)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextJailbreakOptions.
func (a AnalyzeTextJailbreakOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextJailbreakOptions.
func (a *AnalyzeTextJailbreakOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextJailbreakResult.
func (a AnalyzeTextJailbreakResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jailbreakAnalysis", a.JailbreakAnalysis)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextJailbreakResult.
func (a *AnalyzeTextJailbreakResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jailbreakAnalysis":
				err = unpopulate(val, "JailbreakAnalysis", &a.JailbreakAnalysis)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextOptions.
func (a AnalyzeTextOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistNames", a.BlocklistNames)
	populate(objectMap, "categories", a.Categories)
	populate(objectMap, "haltOnBlocklistHit", a.HaltOnBlocklistHit)
	populate(objectMap, "outputType", a.OutputType)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextOptions.
func (a *AnalyzeTextOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistNames":
				err = unpopulate(val, "BlocklistNames", &a.BlocklistNames)
			delete(rawMsg, key)
		case "categories":
				err = unpopulate(val, "Categories", &a.Categories)
			delete(rawMsg, key)
		case "haltOnBlocklistHit":
				err = unpopulate(val, "HaltOnBlocklistHit", &a.HaltOnBlocklistHit)
			delete(rawMsg, key)
		case "outputType":
				err = unpopulate(val, "OutputType", &a.OutputType)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextPromptInjectionOptions.
func (a AnalyzeTextPromptInjectionOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "documents", a.Documents)
	populate(objectMap, "userPrompt", a.UserPrompt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextPromptInjectionOptions.
func (a *AnalyzeTextPromptInjectionOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "documents":
				err = unpopulate(val, "Documents", &a.Documents)
			delete(rawMsg, key)
		case "userPrompt":
				err = unpopulate(val, "UserPrompt", &a.UserPrompt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextPromptInjectionResult.
func (a AnalyzeTextPromptInjectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "documentsAnalysis", a.DocumentsAnalysis)
	populate(objectMap, "userPromptAnalysis", a.UserPromptAnalysis)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextPromptInjectionResult.
func (a *AnalyzeTextPromptInjectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "documentsAnalysis":
				err = unpopulate(val, "DocumentsAnalysis", &a.DocumentsAnalysis)
			delete(rawMsg, key)
		case "userPromptAnalysis":
				err = unpopulate(val, "UserPromptAnalysis", &a.UserPromptAnalysis)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextProtectedMaterialOptions.
func (a AnalyzeTextProtectedMaterialOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "text", a.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextProtectedMaterialOptions.
func (a *AnalyzeTextProtectedMaterialOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "text":
				err = unpopulate(val, "Text", &a.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextProtectedMaterialResult.
func (a AnalyzeTextProtectedMaterialResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "protectedMaterialAnalysis", a.ProtectedMaterialAnalysis)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextProtectedMaterialResult.
func (a *AnalyzeTextProtectedMaterialResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "protectedMaterialAnalysis":
				err = unpopulate(val, "ProtectedMaterialAnalysis", &a.ProtectedMaterialAnalysis)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AnalyzeTextResult.
func (a AnalyzeTextResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistsMatch", a.BlocklistsMatch)
	populate(objectMap, "categoriesAnalysis", a.CategoriesAnalysis)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AnalyzeTextResult.
func (a *AnalyzeTextResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistsMatch":
				err = unpopulate(val, "BlocklistsMatch", &a.BlocklistsMatch)
			delete(rawMsg, key)
		case "categoriesAnalysis":
				err = unpopulate(val, "CategoriesAnalysis", &a.CategoriesAnalysis)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageCategoriesAnalysis.
func (i ImageCategoriesAnalysis) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", i.Category)
	populate(objectMap, "severity", i.Severity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageCategoriesAnalysis.
func (i *ImageCategoriesAnalysis) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
				err = unpopulate(val, "Category", &i.Category)
			delete(rawMsg, key)
		case "severity":
				err = unpopulate(val, "Severity", &i.Severity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageData.
func (i ImageData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blobUrl", i.BlobURL)
	populateByteArray(objectMap, "content", i.Content, func() any {
		return runtime.EncodeByteArray(i.Content, runtime.Base64StdFormat)
	})
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageData.
func (i *ImageData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blobUrl":
				err = unpopulate(val, "BlobURL", &i.BlobURL)
			delete(rawMsg, key)
		case "content":
		if val != nil && string(val) != "null" {
				err = runtime.DecodeByteArray(string(val), &i.Content, runtime.Base64StdFormat)
		}
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type IndexDetails.
func (i IndexDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "codePoint", i.CodePoint)
	populate(objectMap, "utf16", i.UTF16)
	populate(objectMap, "utf8", i.UTF8)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type IndexDetails.
func (i *IndexDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "codePoint":
				err = unpopulate(val, "CodePoint", &i.CodePoint)
			delete(rawMsg, key)
		case "utf16":
				err = unpopulate(val, "UTF16", &i.UTF16)
			delete(rawMsg, key)
		case "utf8":
				err = unpopulate(val, "UTF8", &i.UTF8)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JailbreakAnalysisResult.
func (j JailbreakAnalysisResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detected", j.Detected)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JailbreakAnalysisResult.
func (j *JailbreakAnalysisResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detected":
				err = unpopulate(val, "Detected", &j.Detected)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LLMResource.
func (l LLMResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureOpenAIDeploymentName", l.AzureOpenAIDeploymentName)
	populate(objectMap, "azureOpenAIEndpoint", l.AzureOpenAIEndpoint)
	populate(objectMap, "resourceType", l.ResourceType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LLMResource.
func (l *LLMResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureOpenAIDeploymentName":
				err = unpopulate(val, "AzureOpenAIDeploymentName", &l.AzureOpenAIDeploymentName)
			delete(rawMsg, key)
		case "azureOpenAIEndpoint":
				err = unpopulate(val, "AzureOpenAIEndpoint", &l.AzureOpenAIEndpoint)
			delete(rawMsg, key)
		case "resourceType":
				err = unpopulate(val, "ResourceType", &l.ResourceType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedTextBlocklist.
func (p PagedTextBlocklist) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedTextBlocklist.
func (p *PagedTextBlocklist) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedTextBlocklistItem.
func (p PagedTextBlocklistItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedTextBlocklistItem.
func (p *PagedTextBlocklistItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProtectedMaterialAnalysisResult.
func (p ProtectedMaterialAnalysisResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "detected", p.Detected)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProtectedMaterialAnalysisResult.
func (p *ProtectedMaterialAnalysisResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "detected":
				err = unpopulate(val, "Detected", &p.Detected)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QnAOptions.
func (q QnAOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "query", q.Query)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QnAOptions.
func (q *QnAOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "query":
				err = unpopulate(val, "Query", &q.Query)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RemoveTextBlocklistItemsOptions.
func (r RemoveTextBlocklistItemsOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistItemIds", r.BlocklistItemIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RemoveTextBlocklistItemsOptions.
func (r *RemoveTextBlocklistItemsOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistItemIds":
				err = unpopulate(val, "BlocklistItemIDs", &r.BlocklistItemIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextBlocklist.
func (t TextBlocklist) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistName", t.BlocklistName)
	populate(objectMap, "description", t.Description)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextBlocklist.
func (t *TextBlocklist) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistName":
				err = unpopulate(val, "BlocklistName", &t.BlocklistName)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextBlocklistItem.
func (t TextBlocklistItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistItemId", t.BlocklistItemID)
	populate(objectMap, "description", t.Description)
	populate(objectMap, "text", t.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextBlocklistItem.
func (t *TextBlocklistItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistItemId":
				err = unpopulate(val, "BlocklistItemID", &t.BlocklistItemID)
			delete(rawMsg, key)
		case "description":
				err = unpopulate(val, "Description", &t.Description)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &t.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextBlocklistMatch.
func (t TextBlocklistMatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "blocklistItemId", t.BlocklistItemID)
	populate(objectMap, "blocklistItemText", t.BlocklistItemText)
	populate(objectMap, "blocklistName", t.BlocklistName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextBlocklistMatch.
func (t *TextBlocklistMatch) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "blocklistItemId":
				err = unpopulate(val, "BlocklistItemID", &t.BlocklistItemID)
			delete(rawMsg, key)
		case "blocklistItemText":
				err = unpopulate(val, "BlocklistItemText", &t.BlocklistItemText)
			delete(rawMsg, key)
		case "blocklistName":
				err = unpopulate(val, "BlocklistName", &t.BlocklistName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextCategoriesAnalysis.
func (t TextCategoriesAnalysis) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", t.Category)
	populate(objectMap, "severity", t.Severity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextCategoriesAnalysis.
func (t *TextCategoriesAnalysis) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
				err = unpopulate(val, "Category", &t.Category)
			delete(rawMsg, key)
		case "severity":
				err = unpopulate(val, "Severity", &t.Severity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type TextPromptInjectionResult.
func (t TextPromptInjectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "attackDetected", t.AttackDetected)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TextPromptInjectionResult.
func (t *TextPromptInjectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", t, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "attackDetected":
				err = unpopulate(val, "AttackDetected", &t.AttackDetected)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", t, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UngroundednessDetails.
func (u UngroundednessDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "length", u.Length)
	populate(objectMap, "offset", u.Offset)
	populate(objectMap, "reason", u.Reason)
	populate(objectMap, "text", u.Text)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UngroundednessDetails.
func (u *UngroundednessDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "length":
				err = unpopulate(val, "Length", &u.Length)
			delete(rawMsg, key)
		case "offset":
				err = unpopulate(val, "Offset", &u.Offset)
			delete(rawMsg, key)
		case "reason":
				err = unpopulate(val, "Reason", &u.Reason)
			delete(rawMsg, key)
		case "text":
				err = unpopulate(val, "Text", &u.Text)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateByteArray[T any](m map[string]any, k string, b []T, convert func() any) {
	if azcore.IsNullValue(b) {
		m[k] = nil
	} else if len(b) == 0 {
		return
	} else {
		m[k] = convert()
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

