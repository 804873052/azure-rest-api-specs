// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package typespec-go

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
)

// TextOperationsClient contains the methods for the ContentSafety namespace.
// Don't use this type directly, use [ContentSafetyClient.NewTextOperationsClient] instead.
type TextOperationsClient struct {
	internal *azcore.Client
	endpoint string
}

// AnalyzeText - Analyze Text
//   - body - The text analysis request.
//   - options - TextOperationsClientAnalyzeTextOptions contains the optional parameters for the TextOperationsClient.AnalyzeText
//     method.
func (client *TextOperationsClient) AnalyzeText(ctx context.Context, body AnalyzeTextOptions, options *TextOperationsClientAnalyzeTextOptions) (TextOperationsClientAnalyzeTextResponse, error) {
	var err error
	req, err := client.analyzeTextCreateRequest(ctx, body, options)
	if err != nil {
		return TextOperationsClientAnalyzeTextResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextOperationsClientAnalyzeTextResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextOperationsClientAnalyzeTextResponse{}, err
	}
	resp, err := client.analyzeTextHandleResponse(httpResp)
	return resp, err
}

// analyzeTextCreateRequest creates the AnalyzeText request.
func (client *TextOperationsClient) analyzeTextCreateRequest(ctx context.Context, body AnalyzeTextOptions, options *TextOperationsClientAnalyzeTextOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text:analyze"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
	return req, nil
}

// analyzeTextHandleResponse handles the AnalyzeText response.
func (client *TextOperationsClient) analyzeTextHandleResponse(resp *http.Response) (TextOperationsClientAnalyzeTextResponse, error) {
	result := TextOperationsClientAnalyzeTextResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AnalyzeTextResult); err != nil {
		return TextOperationsClientAnalyzeTextResponse{}, err
	}
	return result, nil
}

// DetectTextJailbreak - Analyze Text Jailbreak
//   - body - The text jailbreak analysis request.
//   - options - TextOperationsClientDetectTextJailbreakOptions contains the optional parameters for the TextOperationsClient.DetectTextJailbreak
//     method.
func (client *TextOperationsClient) DetectTextJailbreak(ctx context.Context, body AnalyzeTextJailbreakOptions, options *TextOperationsClientDetectTextJailbreakOptions) (TextOperationsClientDetectTextJailbreakResponse, error) {
	var err error
	req, err := client.detectTextJailbreakCreateRequest(ctx, body, options)
	if err != nil {
		return TextOperationsClientDetectTextJailbreakResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextOperationsClientDetectTextJailbreakResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextOperationsClientDetectTextJailbreakResponse{}, err
	}
	resp, err := client.detectTextJailbreakHandleResponse(httpResp)
	return resp, err
}

// detectTextJailbreakCreateRequest creates the DetectTextJailbreak request.
func (client *TextOperationsClient) detectTextJailbreakCreateRequest(ctx context.Context, body AnalyzeTextJailbreakOptions, options *TextOperationsClientDetectTextJailbreakOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text:detectJailbreak"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
	return req, nil
}

// detectTextJailbreakHandleResponse handles the DetectTextJailbreak response.
func (client *TextOperationsClient) detectTextJailbreakHandleResponse(resp *http.Response) (TextOperationsClientDetectTextJailbreakResponse, error) {
	result := TextOperationsClientDetectTextJailbreakResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AnalyzeTextJailbreakResult); err != nil {
		return TextOperationsClientDetectTextJailbreakResponse{}, err
	}
	return result, nil
}

// DetectTextPromptInjectionOptions - Analyze text prompt injection attacks
//   - body - The text prompt injection attacks analysis request.
//   - options - TextOperationsClientDetectTextPromptInjectionOptionsOptions contains the optional parameters for the TextOperationsClient.DetectTextPromptInjectionOptions
//     method.
func (client *TextOperationsClient) DetectTextPromptInjectionOptions(ctx context.Context, body AnalyzeTextPromptInjectionOptions, options *TextOperationsClientDetectTextPromptInjectionOptionsOptions) (TextOperationsClientDetectTextPromptInjectionOptionsResponse, error) {
	var err error
	req, err := client.detectTextPromptInjectionOptionsCreateRequest(ctx, body, options)
	if err != nil {
		return TextOperationsClientDetectTextPromptInjectionOptionsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextOperationsClientDetectTextPromptInjectionOptionsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextOperationsClientDetectTextPromptInjectionOptionsResponse{}, err
	}
	resp, err := client.detectTextPromptInjectionOptionsHandleResponse(httpResp)
	return resp, err
}

// detectTextPromptInjectionOptionsCreateRequest creates the DetectTextPromptInjectionOptions request.
func (client *TextOperationsClient) detectTextPromptInjectionOptionsCreateRequest(ctx context.Context, body AnalyzeTextPromptInjectionOptions, options *TextOperationsClientDetectTextPromptInjectionOptionsOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text:shieldPrompt"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
	return req, nil
}

// detectTextPromptInjectionOptionsHandleResponse handles the DetectTextPromptInjectionOptions response.
func (client *TextOperationsClient) detectTextPromptInjectionOptionsHandleResponse(resp *http.Response) (TextOperationsClientDetectTextPromptInjectionOptionsResponse, error) {
	result := TextOperationsClientDetectTextPromptInjectionOptionsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AnalyzeTextPromptInjectionResult); err != nil {
		return TextOperationsClientDetectTextPromptInjectionOptionsResponse{}, err
	}
	return result, nil
}

// DetectTextProtectedMaterial - Analyze Protected Material
//   - body - The text protected material analysis request.
//   - options - TextOperationsClientDetectTextProtectedMaterialOptions contains the optional parameters for the TextOperationsClient.DetectTextProtectedMaterial
//     method.
func (client *TextOperationsClient) DetectTextProtectedMaterial(ctx context.Context, body AnalyzeTextProtectedMaterialOptions, options *TextOperationsClientDetectTextProtectedMaterialOptions) (TextOperationsClientDetectTextProtectedMaterialResponse, error) {
	var err error
	req, err := client.detectTextProtectedMaterialCreateRequest(ctx, body, options)
	if err != nil {
		return TextOperationsClientDetectTextProtectedMaterialResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextOperationsClientDetectTextProtectedMaterialResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextOperationsClientDetectTextProtectedMaterialResponse{}, err
	}
	resp, err := client.detectTextProtectedMaterialHandleResponse(httpResp)
	return resp, err
}

// detectTextProtectedMaterialCreateRequest creates the DetectTextProtectedMaterial request.
func (client *TextOperationsClient) detectTextProtectedMaterialCreateRequest(ctx context.Context, body AnalyzeTextProtectedMaterialOptions, options *TextOperationsClientDetectTextProtectedMaterialOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text:detectProtectedMaterial"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
	return req, nil
}

// detectTextProtectedMaterialHandleResponse handles the DetectTextProtectedMaterial response.
func (client *TextOperationsClient) detectTextProtectedMaterialHandleResponse(resp *http.Response) (TextOperationsClientDetectTextProtectedMaterialResponse, error) {
	result := TextOperationsClientDetectTextProtectedMaterialResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AnalyzeTextProtectedMaterialResult); err != nil {
		return TextOperationsClientDetectTextProtectedMaterialResponse{}, err
	}
	return result, nil
}

