// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package typespec-go

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
)

// TextBlocklistsClient contains the methods for the ContentSafety namespace.
// Don't use this type directly, use [ContentSafetyClient.NewTextBlocklistsClient] instead.
type TextBlocklistsClient struct {
	internal *azcore.Client
	endpoint string
}

// AddOrUpdateBlocklistItems - Add or update BlocklistItems To Text Blocklist
//   - blocklistName - Text blocklist name.
//   - body - Options for adding or updating blocklist items.
//   - options - TextBlocklistsClientAddOrUpdateBlocklistItemsOptions contains the optional parameters for the TextBlocklistsClient.AddOrUpdateBlocklistItems
//     method.
func (client *TextBlocklistsClient) AddOrUpdateBlocklistItems(ctx context.Context, blocklistName string, body AddOrUpdateTextBlocklistItemsOptions, options *TextBlocklistsClientAddOrUpdateBlocklistItemsOptions) (TextBlocklistsClientAddOrUpdateBlocklistItemsResponse, error) {
	var err error
	req, err := client.addOrUpdateBlocklistItemsCreateRequest(ctx, blocklistName, body, options)
	if err != nil {
		return TextBlocklistsClientAddOrUpdateBlocklistItemsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextBlocklistsClientAddOrUpdateBlocklistItemsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextBlocklistsClientAddOrUpdateBlocklistItemsResponse{}, err
	}
	resp, err := client.addOrUpdateBlocklistItemsHandleResponse(httpResp)
	return resp, err
}

// addOrUpdateBlocklistItemsCreateRequest creates the AddOrUpdateBlocklistItems request.
func (client *TextBlocklistsClient) addOrUpdateBlocklistItemsCreateRequest(ctx context.Context, blocklistName string, body AddOrUpdateTextBlocklistItemsOptions, options *TextBlocklistsClientAddOrUpdateBlocklistItemsOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}:addOrUpdateBlocklistItems"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
	return req, nil
}

// addOrUpdateBlocklistItemsHandleResponse handles the AddOrUpdateBlocklistItems response.
func (client *TextBlocklistsClient) addOrUpdateBlocklistItemsHandleResponse(resp *http.Response) (TextBlocklistsClientAddOrUpdateBlocklistItemsResponse, error) {
	result := TextBlocklistsClientAddOrUpdateBlocklistItemsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AddOrUpdateTextBlocklistItemsResult); err != nil {
		return TextBlocklistsClientAddOrUpdateBlocklistItemsResponse{}, err
	}
	return result, nil
}

// CreateOrUpdateTextBlocklist - Create Or Update Text Blocklist
//   - blocklistName - Text blocklist name.
//   - options - The resource instance.
//   - opts - TextBlocklistsClientCreateOrUpdateTextBlocklistOptions contains the optional parameters for the TextBlocklistsClient.CreateOrUpdateTextBlocklist
//     method.
func (client *TextBlocklistsClient) CreateOrUpdateTextBlocklist(ctx context.Context, blocklistName string, options TextBlocklist, opts *TextBlocklistsClientCreateOrUpdateTextBlocklistOptions) (TextBlocklistsClientCreateOrUpdateTextBlocklistResponse, error) {
	var err error
	req, err := client.createOrUpdateTextBlocklistCreateRequest(ctx, blocklistName, options, opts)
	if err != nil {
		return TextBlocklistsClientCreateOrUpdateTextBlocklistResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextBlocklistsClientCreateOrUpdateTextBlocklistResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return TextBlocklistsClientCreateOrUpdateTextBlocklistResponse{}, err
	}
	resp, err := client.createOrUpdateTextBlocklistHandleResponse(httpResp)
	return resp, err
}

// createOrUpdateTextBlocklistCreateRequest creates the CreateOrUpdateTextBlocklist request.
func (client *TextBlocklistsClient) createOrUpdateTextBlocklistCreateRequest(ctx context.Context, blocklistName string, options TextBlocklist, opts *TextBlocklistsClientCreateOrUpdateTextBlocklistOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if err := runtime.MarshalAsJSON(req, options); err != nil {
	return nil, err
}
	return req, nil
}

// createOrUpdateTextBlocklistHandleResponse handles the CreateOrUpdateTextBlocklist response.
func (client *TextBlocklistsClient) createOrUpdateTextBlocklistHandleResponse(resp *http.Response) (TextBlocklistsClientCreateOrUpdateTextBlocklistResponse, error) {
	result := TextBlocklistsClientCreateOrUpdateTextBlocklistResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TextBlocklist); err != nil {
		return TextBlocklistsClientCreateOrUpdateTextBlocklistResponse{}, err
	}
	return result, nil
}

// DeleteTextBlocklist - Delete Text Blocklist By blocklistName
//   - blocklistName - Text blocklist name.
//   - options - TextBlocklistsClientDeleteTextBlocklistOptions contains the optional parameters for the TextBlocklistsClient.DeleteTextBlocklist
//     method.
func (client *TextBlocklistsClient) DeleteTextBlocklist(ctx context.Context, blocklistName string, options *TextBlocklistsClientDeleteTextBlocklistOptions) (TextBlocklistsClientDeleteTextBlocklistResponse, error) {
	var err error
	req, err := client.deleteTextBlocklistCreateRequest(ctx, blocklistName, options)
	if err != nil {
		return TextBlocklistsClientDeleteTextBlocklistResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextBlocklistsClientDeleteTextBlocklistResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return TextBlocklistsClientDeleteTextBlocklistResponse{}, err
	}
	return TextBlocklistsClientDeleteTextBlocklistResponse{}, nil
}

// deleteTextBlocklistCreateRequest creates the DeleteTextBlocklist request.
func (client *TextBlocklistsClient) deleteTextBlocklistCreateRequest(ctx context.Context, blocklistName string, options *TextBlocklistsClientDeleteTextBlocklistOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetTextBlocklist - Get Text Blocklist By blocklistName
//   - blocklistName - Text blocklist name.
//   - options - TextBlocklistsClientGetTextBlocklistOptions contains the optional parameters for the TextBlocklistsClient.GetTextBlocklist
//     method.
func (client *TextBlocklistsClient) GetTextBlocklist(ctx context.Context, blocklistName string, options *TextBlocklistsClientGetTextBlocklistOptions) (TextBlocklistsClientGetTextBlocklistResponse, error) {
	var err error
	req, err := client.getTextBlocklistCreateRequest(ctx, blocklistName, options)
	if err != nil {
		return TextBlocklistsClientGetTextBlocklistResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextBlocklistsClientGetTextBlocklistResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextBlocklistsClientGetTextBlocklistResponse{}, err
	}
	resp, err := client.getTextBlocklistHandleResponse(httpResp)
	return resp, err
}

// getTextBlocklistCreateRequest creates the GetTextBlocklist request.
func (client *TextBlocklistsClient) getTextBlocklistCreateRequest(ctx context.Context, blocklistName string, options *TextBlocklistsClientGetTextBlocklistOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTextBlocklistHandleResponse handles the GetTextBlocklist response.
func (client *TextBlocklistsClient) getTextBlocklistHandleResponse(resp *http.Response) (TextBlocklistsClientGetTextBlocklistResponse, error) {
	result := TextBlocklistsClientGetTextBlocklistResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TextBlocklist); err != nil {
		return TextBlocklistsClientGetTextBlocklistResponse{}, err
	}
	return result, nil
}

// GetTextBlocklistItem - Get BlocklistItem By blocklistName And blocklistItemId
//   - blocklistName - Text blocklist name.
//   - blocklistItemID - The service will generate a BlocklistItemId, which will be a UUID.
//   - options - TextBlocklistsClientGetTextBlocklistItemOptions contains the optional parameters for the TextBlocklistsClient.GetTextBlocklistItem
//     method.
func (client *TextBlocklistsClient) GetTextBlocklistItem(ctx context.Context, blocklistName string, blocklistItemID string, options *TextBlocklistsClientGetTextBlocklistItemOptions) (TextBlocklistsClientGetTextBlocklistItemResponse, error) {
	var err error
	req, err := client.getTextBlocklistItemCreateRequest(ctx, blocklistName, blocklistItemID, options)
	if err != nil {
		return TextBlocklistsClientGetTextBlocklistItemResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextBlocklistsClientGetTextBlocklistItemResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return TextBlocklistsClientGetTextBlocklistItemResponse{}, err
	}
	resp, err := client.getTextBlocklistItemHandleResponse(httpResp)
	return resp, err
}

// getTextBlocklistItemCreateRequest creates the GetTextBlocklistItem request.
func (client *TextBlocklistsClient) getTextBlocklistItemCreateRequest(ctx context.Context, blocklistName string, blocklistItemID string, options *TextBlocklistsClientGetTextBlocklistItemOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}/blocklistItems/{blocklistItemId}"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	if blocklistItemID == "" {
		return nil, errors.New("parameter blocklistItemID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistItemId}", url.PathEscape(blocklistItemID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getTextBlocklistItemHandleResponse handles the GetTextBlocklistItem response.
func (client *TextBlocklistsClient) getTextBlocklistItemHandleResponse(resp *http.Response) (TextBlocklistsClientGetTextBlocklistItemResponse, error) {
	result := TextBlocklistsClientGetTextBlocklistItemResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.TextBlocklistItem); err != nil {
		return TextBlocklistsClientGetTextBlocklistItemResponse{}, err
	}
	return result, nil
}

// NewListTextBlocklistItemsPager - Get All BlocklistItems By blocklistName
//   - blocklistName - Text blocklist name.
//   - options - TextBlocklistsClientListTextBlocklistItemsOptions contains the optional parameters for the TextBlocklistsClient.NewListTextBlocklistItemsPager
//     method.
func (client *TextBlocklistsClient) NewListTextBlocklistItemsPager(blocklistName string, options *TextBlocklistsClientListTextBlocklistItemsOptions) (*runtime.Pager[TextBlocklistsClientListTextBlocklistItemsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[TextBlocklistsClientListTextBlocklistItemsResponse]{
		More: func(page TextBlocklistsClientListTextBlocklistItemsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *TextBlocklistsClientListTextBlocklistItemsResponse) (TextBlocklistsClientListTextBlocklistItemsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTextBlocklistItemsCreateRequest(ctx, blocklistName, options)
			}, nil)
			if err != nil {
				return TextBlocklistsClientListTextBlocklistItemsResponse{}, err
			}
			return client.listTextBlocklistItemsHandleResponse(resp)
			},
	})
}

// listTextBlocklistItemsCreateRequest creates the ListTextBlocklistItems request.
func (client *TextBlocklistsClient) listTextBlocklistItemsCreateRequest(ctx context.Context, blocklistName string, options *TextBlocklistsClientListTextBlocklistItemsOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}/blocklistItems"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	if options != nil && options.Skip != nil {
		reqQP.Set("skip", strconv.FormatInt(int64(*options.Skip), 10))
	}
	if options != nil && options.Top != nil {
		reqQP.Set("top", strconv.FormatInt(int64(*options.Top), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTextBlocklistItemsHandleResponse handles the ListTextBlocklistItems response.
func (client *TextBlocklistsClient) listTextBlocklistItemsHandleResponse(resp *http.Response) (TextBlocklistsClientListTextBlocklistItemsResponse, error) {
	result := TextBlocklistsClientListTextBlocklistItemsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedTextBlocklistItem); err != nil {
		return TextBlocklistsClientListTextBlocklistItemsResponse{}, err
	}
	return result, nil
}

// NewListTextBlocklistsPager - Get All Text Blocklists
//   - options - TextBlocklistsClientListTextBlocklistsOptions contains the optional parameters for the TextBlocklistsClient.NewListTextBlocklistsPager
//     method.
func (client *TextBlocklistsClient) NewListTextBlocklistsPager(options *TextBlocklistsClientListTextBlocklistsOptions) (*runtime.Pager[TextBlocklistsClientListTextBlocklistsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[TextBlocklistsClientListTextBlocklistsResponse]{
		More: func(page TextBlocklistsClientListTextBlocklistsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *TextBlocklistsClientListTextBlocklistsResponse) (TextBlocklistsClientListTextBlocklistsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTextBlocklistsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return TextBlocklistsClientListTextBlocklistsResponse{}, err
			}
			return client.listTextBlocklistsHandleResponse(resp)
			},
	})
}

// listTextBlocklistsCreateRequest creates the ListTextBlocklists request.
func (client *TextBlocklistsClient) listTextBlocklistsCreateRequest(ctx context.Context, options *TextBlocklistsClientListTextBlocklistsOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listTextBlocklistsHandleResponse handles the ListTextBlocklists response.
func (client *TextBlocklistsClient) listTextBlocklistsHandleResponse(resp *http.Response) (TextBlocklistsClientListTextBlocklistsResponse, error) {
	result := TextBlocklistsClientListTextBlocklistsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedTextBlocklist); err != nil {
		return TextBlocklistsClientListTextBlocklistsResponse{}, err
	}
	return result, nil
}

// RemoveBlocklistItems - Remove BlocklistItems From Text Blocklist
//   - blocklistName - Text blocklist name.
//   - body - Options for removing blocklist items.
//   - options - TextBlocklistsClientRemoveBlocklistItemsOptions contains the optional parameters for the TextBlocklistsClient.RemoveBlocklistItems
//     method.
func (client *TextBlocklistsClient) RemoveBlocklistItems(ctx context.Context, blocklistName string, body RemoveTextBlocklistItemsOptions, options *TextBlocklistsClientRemoveBlocklistItemsOptions) (TextBlocklistsClientRemoveBlocklistItemsResponse, error) {
	var err error
	req, err := client.removeBlocklistItemsCreateRequest(ctx, blocklistName, body, options)
	if err != nil {
		return TextBlocklistsClientRemoveBlocklistItemsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return TextBlocklistsClientRemoveBlocklistItemsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return TextBlocklistsClientRemoveBlocklistItemsResponse{}, err
	}
	return TextBlocklistsClientRemoveBlocklistItemsResponse{}, nil
}

// removeBlocklistItemsCreateRequest creates the RemoveBlocklistItems request.
func (client *TextBlocklistsClient) removeBlocklistItemsCreateRequest(ctx context.Context, blocklistName string, body RemoveTextBlocklistItemsOptions, options *TextBlocklistsClientRemoveBlocklistItemsOptions) (*policy.Request, error) {
	host := "{endpoint}/contentsafety"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/text/blocklists/{blocklistName}:removeBlocklistItems"
	if blocklistName == "" {
		return nil, errors.New("parameter blocklistName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{blocklistName}", url.PathEscape(blocklistName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-15-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if err := runtime.MarshalAsJSON(req, body); err != nil {
	return nil, err
}
	return req, nil
}

