// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package typespec-go

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// JobRouterAdministrationOperationsClient contains the methods for the AzureCommunicationRoutingService namespace.
// Don't use this type directly, use [AzureCommunicationRoutingServiceClient.NewJobRouterAdministrationOperationsClient] instead.
type JobRouterAdministrationOperationsClient struct {
	internal *azcore.Client
	endpoint string
}

// DeleteClassificationPolicy - Delete a classification policy by Id.
//   - classificationPolicyID - Id of a classification policy.
//   - options - JobRouterAdministrationOperationsClientDeleteClassificationPolicyOptions contains the optional parameters for
//     the JobRouterAdministrationOperationsClient.DeleteClassificationPolicy method.
func (client *JobRouterAdministrationOperationsClient) DeleteClassificationPolicy(ctx context.Context, classificationPolicyID string, options *JobRouterAdministrationOperationsClientDeleteClassificationPolicyOptions) (JobRouterAdministrationOperationsClientDeleteClassificationPolicyResponse, error) {
	var err error
	req, err := client.deleteClassificationPolicyCreateRequest(ctx, classificationPolicyID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteClassificationPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteClassificationPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientDeleteClassificationPolicyResponse{}, err
	}
	return JobRouterAdministrationOperationsClientDeleteClassificationPolicyResponse{}, nil
}

// deleteClassificationPolicyCreateRequest creates the DeleteClassificationPolicy request.
func (client *JobRouterAdministrationOperationsClient) deleteClassificationPolicyCreateRequest(ctx context.Context, classificationPolicyID string, options *JobRouterAdministrationOperationsClientDeleteClassificationPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/classificationPolicies/{classificationPolicyId}"
	if classificationPolicyID == "" {
		return nil, errors.New("parameter classificationPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{classificationPolicyId}", url.PathEscape(classificationPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteDistributionPolicy - Delete a distribution policy by Id.
//   - distributionPolicyID - Id of a distribution policy.
//   - options - JobRouterAdministrationOperationsClientDeleteDistributionPolicyOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.DeleteDistributionPolicy method.
func (client *JobRouterAdministrationOperationsClient) DeleteDistributionPolicy(ctx context.Context, distributionPolicyID string, options *JobRouterAdministrationOperationsClientDeleteDistributionPolicyOptions) (JobRouterAdministrationOperationsClientDeleteDistributionPolicyResponse, error) {
	var err error
	req, err := client.deleteDistributionPolicyCreateRequest(ctx, distributionPolicyID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteDistributionPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteDistributionPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientDeleteDistributionPolicyResponse{}, err
	}
	return JobRouterAdministrationOperationsClientDeleteDistributionPolicyResponse{}, nil
}

// deleteDistributionPolicyCreateRequest creates the DeleteDistributionPolicy request.
func (client *JobRouterAdministrationOperationsClient) deleteDistributionPolicyCreateRequest(ctx context.Context, distributionPolicyID string, options *JobRouterAdministrationOperationsClientDeleteDistributionPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/distributionPolicies/{distributionPolicyId}"
	if distributionPolicyID == "" {
		return nil, errors.New("parameter distributionPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{distributionPolicyId}", url.PathEscape(distributionPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteExceptionPolicy - Deletes a exception policy by Id.
//   - exceptionPolicyID - Id of an exception policy.
//   - options - JobRouterAdministrationOperationsClientDeleteExceptionPolicyOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.DeleteExceptionPolicy method.
func (client *JobRouterAdministrationOperationsClient) DeleteExceptionPolicy(ctx context.Context, exceptionPolicyID string, options *JobRouterAdministrationOperationsClientDeleteExceptionPolicyOptions) (JobRouterAdministrationOperationsClientDeleteExceptionPolicyResponse, error) {
	var err error
	req, err := client.deleteExceptionPolicyCreateRequest(ctx, exceptionPolicyID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteExceptionPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteExceptionPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientDeleteExceptionPolicyResponse{}, err
	}
	return JobRouterAdministrationOperationsClientDeleteExceptionPolicyResponse{}, nil
}

// deleteExceptionPolicyCreateRequest creates the DeleteExceptionPolicy request.
func (client *JobRouterAdministrationOperationsClient) deleteExceptionPolicyCreateRequest(ctx context.Context, exceptionPolicyID string, options *JobRouterAdministrationOperationsClientDeleteExceptionPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/exceptionPolicies/{exceptionPolicyId}"
	if exceptionPolicyID == "" {
		return nil, errors.New("parameter exceptionPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{exceptionPolicyId}", url.PathEscape(exceptionPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteQueue - Deletes a queue by Id.
//   - queueID - Id of a queue.
//   - options - JobRouterAdministrationOperationsClientDeleteQueueOptions contains the optional parameters for the JobRouterAdministrationOperationsClient.DeleteQueue
//     method.
func (client *JobRouterAdministrationOperationsClient) DeleteQueue(ctx context.Context, queueID string, options *JobRouterAdministrationOperationsClientDeleteQueueOptions) (JobRouterAdministrationOperationsClientDeleteQueueResponse, error) {
	var err error
	req, err := client.deleteQueueCreateRequest(ctx, queueID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteQueueResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientDeleteQueueResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientDeleteQueueResponse{}, err
	}
	return JobRouterAdministrationOperationsClientDeleteQueueResponse{}, nil
}

// deleteQueueCreateRequest creates the DeleteQueue request.
func (client *JobRouterAdministrationOperationsClient) deleteQueueCreateRequest(ctx context.Context, queueID string, options *JobRouterAdministrationOperationsClientDeleteQueueOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/queues/{queueId}"
	if queueID == "" {
		return nil, errors.New("parameter queueID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{queueId}", url.PathEscape(queueID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetClassificationPolicy - Retrieves an existing classification policy by Id.
//   - classificationPolicyID - Id of a classification policy.
//   - options - JobRouterAdministrationOperationsClientGetClassificationPolicyOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.GetClassificationPolicy method.
func (client *JobRouterAdministrationOperationsClient) GetClassificationPolicy(ctx context.Context, classificationPolicyID string, options *JobRouterAdministrationOperationsClientGetClassificationPolicyOptions) (JobRouterAdministrationOperationsClientGetClassificationPolicyResponse, error) {
	var err error
	req, err := client.getClassificationPolicyCreateRequest(ctx, classificationPolicyID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetClassificationPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetClassificationPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientGetClassificationPolicyResponse{}, err
	}
	resp, err := client.getClassificationPolicyHandleResponse(httpResp)
	return resp, err
}

// getClassificationPolicyCreateRequest creates the GetClassificationPolicy request.
func (client *JobRouterAdministrationOperationsClient) getClassificationPolicyCreateRequest(ctx context.Context, classificationPolicyID string, options *JobRouterAdministrationOperationsClientGetClassificationPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/classificationPolicies/{classificationPolicyId}"
	if classificationPolicyID == "" {
		return nil, errors.New("parameter classificationPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{classificationPolicyId}", url.PathEscape(classificationPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getClassificationPolicyHandleResponse handles the GetClassificationPolicy response.
func (client *JobRouterAdministrationOperationsClient) getClassificationPolicyHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientGetClassificationPolicyResponse, error) {
	result := JobRouterAdministrationOperationsClientGetClassificationPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientGetClassificationPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ClassificationPolicy); err != nil {
		return JobRouterAdministrationOperationsClientGetClassificationPolicyResponse{}, err
	}
	return result, nil
}

// GetDistributionPolicy - Retrieves an existing distribution policy by Id.
//   - distributionPolicyID - Id of a distribution policy.
//   - options - JobRouterAdministrationOperationsClientGetDistributionPolicyOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.GetDistributionPolicy method.
func (client *JobRouterAdministrationOperationsClient) GetDistributionPolicy(ctx context.Context, distributionPolicyID string, options *JobRouterAdministrationOperationsClientGetDistributionPolicyOptions) (JobRouterAdministrationOperationsClientGetDistributionPolicyResponse, error) {
	var err error
	req, err := client.getDistributionPolicyCreateRequest(ctx, distributionPolicyID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetDistributionPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetDistributionPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientGetDistributionPolicyResponse{}, err
	}
	resp, err := client.getDistributionPolicyHandleResponse(httpResp)
	return resp, err
}

// getDistributionPolicyCreateRequest creates the GetDistributionPolicy request.
func (client *JobRouterAdministrationOperationsClient) getDistributionPolicyCreateRequest(ctx context.Context, distributionPolicyID string, options *JobRouterAdministrationOperationsClientGetDistributionPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/distributionPolicies/{distributionPolicyId}"
	if distributionPolicyID == "" {
		return nil, errors.New("parameter distributionPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{distributionPolicyId}", url.PathEscape(distributionPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getDistributionPolicyHandleResponse handles the GetDistributionPolicy response.
func (client *JobRouterAdministrationOperationsClient) getDistributionPolicyHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientGetDistributionPolicyResponse, error) {
	result := JobRouterAdministrationOperationsClientGetDistributionPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientGetDistributionPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.DistributionPolicy); err != nil {
		return JobRouterAdministrationOperationsClientGetDistributionPolicyResponse{}, err
	}
	return result, nil
}

// GetExceptionPolicy - Retrieves an existing exception policy by Id.
//   - exceptionPolicyID - Id of an exception policy.
//   - options - JobRouterAdministrationOperationsClientGetExceptionPolicyOptions contains the optional parameters for the JobRouterAdministrationOperationsClient.GetExceptionPolicy
//     method.
func (client *JobRouterAdministrationOperationsClient) GetExceptionPolicy(ctx context.Context, exceptionPolicyID string, options *JobRouterAdministrationOperationsClientGetExceptionPolicyOptions) (JobRouterAdministrationOperationsClientGetExceptionPolicyResponse, error) {
	var err error
	req, err := client.getExceptionPolicyCreateRequest(ctx, exceptionPolicyID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetExceptionPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetExceptionPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientGetExceptionPolicyResponse{}, err
	}
	resp, err := client.getExceptionPolicyHandleResponse(httpResp)
	return resp, err
}

// getExceptionPolicyCreateRequest creates the GetExceptionPolicy request.
func (client *JobRouterAdministrationOperationsClient) getExceptionPolicyCreateRequest(ctx context.Context, exceptionPolicyID string, options *JobRouterAdministrationOperationsClientGetExceptionPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/exceptionPolicies/{exceptionPolicyId}"
	if exceptionPolicyID == "" {
		return nil, errors.New("parameter exceptionPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{exceptionPolicyId}", url.PathEscape(exceptionPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getExceptionPolicyHandleResponse handles the GetExceptionPolicy response.
func (client *JobRouterAdministrationOperationsClient) getExceptionPolicyHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientGetExceptionPolicyResponse, error) {
	result := JobRouterAdministrationOperationsClientGetExceptionPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientGetExceptionPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ExceptionPolicy); err != nil {
		return JobRouterAdministrationOperationsClientGetExceptionPolicyResponse{}, err
	}
	return result, nil
}

// GetQueue - Retrieves an existing queue by Id.
//   - queueID - Id of a queue.
//   - options - JobRouterAdministrationOperationsClientGetQueueOptions contains the optional parameters for the JobRouterAdministrationOperationsClient.GetQueue
//     method.
func (client *JobRouterAdministrationOperationsClient) GetQueue(ctx context.Context, queueID string, options *JobRouterAdministrationOperationsClientGetQueueOptions) (JobRouterAdministrationOperationsClientGetQueueResponse, error) {
	var err error
	req, err := client.getQueueCreateRequest(ctx, queueID, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetQueueResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientGetQueueResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientGetQueueResponse{}, err
	}
	resp, err := client.getQueueHandleResponse(httpResp)
	return resp, err
}

// getQueueCreateRequest creates the GetQueue request.
func (client *JobRouterAdministrationOperationsClient) getQueueCreateRequest(ctx context.Context, queueID string, options *JobRouterAdministrationOperationsClientGetQueueOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/queues/{queueId}"
	if queueID == "" {
		return nil, errors.New("parameter queueID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{queueId}", url.PathEscape(queueID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getQueueHandleResponse handles the GetQueue response.
func (client *JobRouterAdministrationOperationsClient) getQueueHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientGetQueueResponse, error) {
	result := JobRouterAdministrationOperationsClientGetQueueResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientGetQueueResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterQueue); err != nil {
		return JobRouterAdministrationOperationsClientGetQueueResponse{}, err
	}
	return result, nil
}

// NewListClassificationPoliciesPager - Retrieves existing classification policies.
//   - options - JobRouterAdministrationOperationsClientListClassificationPoliciesOptions contains the optional parameters for
//     the JobRouterAdministrationOperationsClient.NewListClassificationPoliciesPager method.
func (client *JobRouterAdministrationOperationsClient) NewListClassificationPoliciesPager(options *JobRouterAdministrationOperationsClientListClassificationPoliciesOptions) (*runtime.Pager[JobRouterAdministrationOperationsClientListClassificationPoliciesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[JobRouterAdministrationOperationsClientListClassificationPoliciesResponse]{
		More: func(page JobRouterAdministrationOperationsClientListClassificationPoliciesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *JobRouterAdministrationOperationsClientListClassificationPoliciesResponse) (JobRouterAdministrationOperationsClientListClassificationPoliciesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listClassificationPoliciesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return JobRouterAdministrationOperationsClientListClassificationPoliciesResponse{}, err
			}
			return client.listClassificationPoliciesHandleResponse(resp)
			},
	})
}

// listClassificationPoliciesCreateRequest creates the ListClassificationPolicies request.
func (client *JobRouterAdministrationOperationsClient) listClassificationPoliciesCreateRequest(ctx context.Context, options *JobRouterAdministrationOperationsClientListClassificationPoliciesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/classificationPolicies"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listClassificationPoliciesHandleResponse handles the ListClassificationPolicies response.
func (client *JobRouterAdministrationOperationsClient) listClassificationPoliciesHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientListClassificationPoliciesResponse, error) {
	result := JobRouterAdministrationOperationsClientListClassificationPoliciesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedClassificationPolicy); err != nil {
		return JobRouterAdministrationOperationsClientListClassificationPoliciesResponse{}, err
	}
	return result, nil
}

// NewListDistributionPoliciesPager - Retrieves existing distribution policies.
//   - options - JobRouterAdministrationOperationsClientListDistributionPoliciesOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.NewListDistributionPoliciesPager method.
func (client *JobRouterAdministrationOperationsClient) NewListDistributionPoliciesPager(options *JobRouterAdministrationOperationsClientListDistributionPoliciesOptions) (*runtime.Pager[JobRouterAdministrationOperationsClientListDistributionPoliciesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[JobRouterAdministrationOperationsClientListDistributionPoliciesResponse]{
		More: func(page JobRouterAdministrationOperationsClientListDistributionPoliciesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *JobRouterAdministrationOperationsClientListDistributionPoliciesResponse) (JobRouterAdministrationOperationsClientListDistributionPoliciesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listDistributionPoliciesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return JobRouterAdministrationOperationsClientListDistributionPoliciesResponse{}, err
			}
			return client.listDistributionPoliciesHandleResponse(resp)
			},
	})
}

// listDistributionPoliciesCreateRequest creates the ListDistributionPolicies request.
func (client *JobRouterAdministrationOperationsClient) listDistributionPoliciesCreateRequest(ctx context.Context, options *JobRouterAdministrationOperationsClientListDistributionPoliciesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/distributionPolicies"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listDistributionPoliciesHandleResponse handles the ListDistributionPolicies response.
func (client *JobRouterAdministrationOperationsClient) listDistributionPoliciesHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientListDistributionPoliciesResponse, error) {
	result := JobRouterAdministrationOperationsClientListDistributionPoliciesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedDistributionPolicy); err != nil {
		return JobRouterAdministrationOperationsClientListDistributionPoliciesResponse{}, err
	}
	return result, nil
}

// NewListExceptionPoliciesPager - Retrieves existing exception policies.
//   - options - JobRouterAdministrationOperationsClientListExceptionPoliciesOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.NewListExceptionPoliciesPager method.
func (client *JobRouterAdministrationOperationsClient) NewListExceptionPoliciesPager(options *JobRouterAdministrationOperationsClientListExceptionPoliciesOptions) (*runtime.Pager[JobRouterAdministrationOperationsClientListExceptionPoliciesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[JobRouterAdministrationOperationsClientListExceptionPoliciesResponse]{
		More: func(page JobRouterAdministrationOperationsClientListExceptionPoliciesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *JobRouterAdministrationOperationsClientListExceptionPoliciesResponse) (JobRouterAdministrationOperationsClientListExceptionPoliciesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listExceptionPoliciesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return JobRouterAdministrationOperationsClientListExceptionPoliciesResponse{}, err
			}
			return client.listExceptionPoliciesHandleResponse(resp)
			},
	})
}

// listExceptionPoliciesCreateRequest creates the ListExceptionPolicies request.
func (client *JobRouterAdministrationOperationsClient) listExceptionPoliciesCreateRequest(ctx context.Context, options *JobRouterAdministrationOperationsClientListExceptionPoliciesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/exceptionPolicies"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listExceptionPoliciesHandleResponse handles the ListExceptionPolicies response.
func (client *JobRouterAdministrationOperationsClient) listExceptionPoliciesHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientListExceptionPoliciesResponse, error) {
	result := JobRouterAdministrationOperationsClientListExceptionPoliciesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedExceptionPolicy); err != nil {
		return JobRouterAdministrationOperationsClientListExceptionPoliciesResponse{}, err
	}
	return result, nil
}

// NewListQueuesPager - Retrieves existing queues.
//   - options - JobRouterAdministrationOperationsClientListQueuesOptions contains the optional parameters for the JobRouterAdministrationOperationsClient.NewListQueuesPager
//     method.
func (client *JobRouterAdministrationOperationsClient) NewListQueuesPager(options *JobRouterAdministrationOperationsClientListQueuesOptions) (*runtime.Pager[JobRouterAdministrationOperationsClientListQueuesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[JobRouterAdministrationOperationsClientListQueuesResponse]{
		More: func(page JobRouterAdministrationOperationsClientListQueuesResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *JobRouterAdministrationOperationsClientListQueuesResponse) (JobRouterAdministrationOperationsClientListQueuesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listQueuesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return JobRouterAdministrationOperationsClientListQueuesResponse{}, err
			}
			return client.listQueuesHandleResponse(resp)
			},
	})
}

// listQueuesCreateRequest creates the ListQueues request.
func (client *JobRouterAdministrationOperationsClient) listQueuesCreateRequest(ctx context.Context, options *JobRouterAdministrationOperationsClientListQueuesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/queues"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listQueuesHandleResponse handles the ListQueues response.
func (client *JobRouterAdministrationOperationsClient) listQueuesHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientListQueuesResponse, error) {
	result := JobRouterAdministrationOperationsClientListQueuesResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedRouterQueue); err != nil {
		return JobRouterAdministrationOperationsClientListQueuesResponse{}, err
	}
	return result, nil
}

// UpsertClassificationPolicy - Creates or updates a classification policy.
//   - classificationPolicyID - Id of a classification policy.
//   - resource - The resource instance.
//   - options - JobRouterAdministrationOperationsClientUpsertClassificationPolicyOptions contains the optional parameters for
//     the JobRouterAdministrationOperationsClient.UpsertClassificationPolicy method.
func (client *JobRouterAdministrationOperationsClient) UpsertClassificationPolicy(ctx context.Context, classificationPolicyID string, resource ClassificationPolicy, options *JobRouterAdministrationOperationsClientUpsertClassificationPolicyOptions) (JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse, error) {
	var err error
	req, err := client.upsertClassificationPolicyCreateRequest(ctx, classificationPolicyID, resource, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse{}, err
	}
	resp, err := client.upsertClassificationPolicyHandleResponse(httpResp)
	return resp, err
}

// upsertClassificationPolicyCreateRequest creates the UpsertClassificationPolicy request.
func (client *JobRouterAdministrationOperationsClient) upsertClassificationPolicyCreateRequest(ctx context.Context, classificationPolicyID string, resource ClassificationPolicy, options *JobRouterAdministrationOperationsClientUpsertClassificationPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/classificationPolicies/{classificationPolicyId}"
	if classificationPolicyID == "" {
		return nil, errors.New("parameter classificationPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{classificationPolicyId}", url.PathEscape(classificationPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
	return nil, err
}
	return req, nil
}

// upsertClassificationPolicyHandleResponse handles the UpsertClassificationPolicy response.
func (client *JobRouterAdministrationOperationsClient) upsertClassificationPolicyHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse, error) {
	result := JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ClassificationPolicy); err != nil {
		return JobRouterAdministrationOperationsClientUpsertClassificationPolicyResponse{}, err
	}
	return result, nil
}

// UpsertDistributionPolicy - Creates or updates a distribution policy.
//   - distributionPolicyID - Id of a distribution policy.
//   - resource - The resource instance.
//   - options - JobRouterAdministrationOperationsClientUpsertDistributionPolicyOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.UpsertDistributionPolicy method.
func (client *JobRouterAdministrationOperationsClient) UpsertDistributionPolicy(ctx context.Context, distributionPolicyID string, resource DistributionPolicy, options *JobRouterAdministrationOperationsClientUpsertDistributionPolicyOptions) (JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse, error) {
	var err error
	req, err := client.upsertDistributionPolicyCreateRequest(ctx, distributionPolicyID, resource, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse{}, err
	}
	resp, err := client.upsertDistributionPolicyHandleResponse(httpResp)
	return resp, err
}

// upsertDistributionPolicyCreateRequest creates the UpsertDistributionPolicy request.
func (client *JobRouterAdministrationOperationsClient) upsertDistributionPolicyCreateRequest(ctx context.Context, distributionPolicyID string, resource DistributionPolicy, options *JobRouterAdministrationOperationsClientUpsertDistributionPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/distributionPolicies/{distributionPolicyId}"
	if distributionPolicyID == "" {
		return nil, errors.New("parameter distributionPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{distributionPolicyId}", url.PathEscape(distributionPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
	return nil, err
}
	return req, nil
}

// upsertDistributionPolicyHandleResponse handles the UpsertDistributionPolicy response.
func (client *JobRouterAdministrationOperationsClient) upsertDistributionPolicyHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse, error) {
	result := JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.DistributionPolicy); err != nil {
		return JobRouterAdministrationOperationsClientUpsertDistributionPolicyResponse{}, err
	}
	return result, nil
}

// UpsertExceptionPolicy - Creates or updates a exception policy.
//   - exceptionPolicyID - Id of an exception policy.
//   - resource - The resource instance.
//   - options - JobRouterAdministrationOperationsClientUpsertExceptionPolicyOptions contains the optional parameters for the
//     JobRouterAdministrationOperationsClient.UpsertExceptionPolicy method.
func (client *JobRouterAdministrationOperationsClient) UpsertExceptionPolicy(ctx context.Context, exceptionPolicyID string, resource ExceptionPolicy, options *JobRouterAdministrationOperationsClientUpsertExceptionPolicyOptions) (JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse, error) {
	var err error
	req, err := client.upsertExceptionPolicyCreateRequest(ctx, exceptionPolicyID, resource, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse{}, err
	}
	resp, err := client.upsertExceptionPolicyHandleResponse(httpResp)
	return resp, err
}

// upsertExceptionPolicyCreateRequest creates the UpsertExceptionPolicy request.
func (client *JobRouterAdministrationOperationsClient) upsertExceptionPolicyCreateRequest(ctx context.Context, exceptionPolicyID string, resource ExceptionPolicy, options *JobRouterAdministrationOperationsClientUpsertExceptionPolicyOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/exceptionPolicies/{exceptionPolicyId}"
	if exceptionPolicyID == "" {
		return nil, errors.New("parameter exceptionPolicyID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{exceptionPolicyId}", url.PathEscape(exceptionPolicyID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
	return nil, err
}
	return req, nil
}

// upsertExceptionPolicyHandleResponse handles the UpsertExceptionPolicy response.
func (client *JobRouterAdministrationOperationsClient) upsertExceptionPolicyHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse, error) {
	result := JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.ExceptionPolicy); err != nil {
		return JobRouterAdministrationOperationsClientUpsertExceptionPolicyResponse{}, err
	}
	return result, nil
}

// UpsertQueue - Creates or updates a queue.
//   - queueID - Id of a queue.
//   - resource - The resource instance.
//   - options - JobRouterAdministrationOperationsClientUpsertQueueOptions contains the optional parameters for the JobRouterAdministrationOperationsClient.UpsertQueue
//     method.
func (client *JobRouterAdministrationOperationsClient) UpsertQueue(ctx context.Context, queueID string, resource RouterQueue, options *JobRouterAdministrationOperationsClientUpsertQueueOptions) (JobRouterAdministrationOperationsClientUpsertQueueResponse, error) {
	var err error
	req, err := client.upsertQueueCreateRequest(ctx, queueID, resource, options)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertQueueResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterAdministrationOperationsClientUpsertQueueResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterAdministrationOperationsClientUpsertQueueResponse{}, err
	}
	resp, err := client.upsertQueueHandleResponse(httpResp)
	return resp, err
}

// upsertQueueCreateRequest creates the UpsertQueue request.
func (client *JobRouterAdministrationOperationsClient) upsertQueueCreateRequest(ctx context.Context, queueID string, resource RouterQueue, options *JobRouterAdministrationOperationsClientUpsertQueueOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/queues/{queueId}"
	if queueID == "" {
		return nil, errors.New("parameter queueID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{queueId}", url.PathEscape(queueID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
	return nil, err
}
	return req, nil
}

// upsertQueueHandleResponse handles the UpsertQueue response.
func (client *JobRouterAdministrationOperationsClient) upsertQueueHandleResponse(resp *http.Response) (JobRouterAdministrationOperationsClientUpsertQueueResponse, error) {
	result := JobRouterAdministrationOperationsClientUpsertQueueResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterAdministrationOperationsClientUpsertQueueResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterQueue); err != nil {
		return JobRouterAdministrationOperationsClientUpsertQueueResponse{}, err
	}
	return result, nil
}

