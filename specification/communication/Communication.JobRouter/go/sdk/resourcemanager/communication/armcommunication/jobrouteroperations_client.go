// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armcommunication

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// JobRouterOperationsClient contains the methods for the AzureCommunicationRoutingService namespace.
// Don't use this type directly, use [AzureCommunicationRoutingServiceClient.NewJobRouterOperationsClient] instead.
type JobRouterOperationsClient struct {
	internal *azcore.Client
	endpoint string
}

// AcceptJobOffer - Accepts an offer to work on a job and returns a 409/Conflict if another agent accepted the job already.
//   - workerID - Id of a worker.
//   - offerID - Id of an offer.
//   - options - JobRouterOperationsClientAcceptJobOfferOptions contains the optional parameters for the JobRouterOperationsClient.AcceptJobOffer
//     method.
func (client *JobRouterOperationsClient) AcceptJobOffer(ctx context.Context, workerID string, offerID string, options *JobRouterOperationsClientAcceptJobOfferOptions) (JobRouterOperationsClientAcceptJobOfferResponse, error) {
	var err error
	req, err := client.acceptJobOfferCreateRequest(ctx, workerID, offerID, options)
	if err != nil {
		return JobRouterOperationsClientAcceptJobOfferResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientAcceptJobOfferResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientAcceptJobOfferResponse{}, err
	}
	resp, err := client.acceptJobOfferHandleResponse(httpResp)
	return resp, err
}

// acceptJobOfferCreateRequest creates the AcceptJobOffer request.
func (client *JobRouterOperationsClient) acceptJobOfferCreateRequest(ctx context.Context, workerID string, offerID string, options *JobRouterOperationsClientAcceptJobOfferOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/workers/{workerId}/offers/{offerId}:accept"
	if workerID == "" {
		return nil, errors.New("parameter workerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerId}", url.PathEscape(workerID))
	if offerID == "" {
		return nil, errors.New("parameter offerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{offerId}", url.PathEscape(offerID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// acceptJobOfferHandleResponse handles the AcceptJobOffer response.
func (client *JobRouterOperationsClient) acceptJobOfferHandleResponse(resp *http.Response) (JobRouterOperationsClientAcceptJobOfferResponse, error) {
	result := JobRouterOperationsClientAcceptJobOfferResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.AcceptJobOfferResult); err != nil {
		return JobRouterOperationsClientAcceptJobOfferResponse{}, err
	}
	return result, nil
}

// CancelJob - Submits request to cancel an existing job by Id while supplying free-form cancellation reason.
//   - jobID - Id of a job.
//   - opts - JobRouterOperationsClientCancelJobOptions contains the optional parameters for the JobRouterOperationsClient.CancelJob
//     method.
func (client *JobRouterOperationsClient) CancelJob(ctx context.Context, jobID string, opts *JobRouterOperationsClientCancelJobOptions) (JobRouterOperationsClientCancelJobResponse, error) {
	var err error
	req, err := client.cancelJobCreateRequest(ctx, jobID, opts)
	if err != nil {
		return JobRouterOperationsClientCancelJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientCancelJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientCancelJobResponse{}, err
	}
	resp, err := client.cancelJobHandleResponse(httpResp)
	return resp, err
}

// cancelJobCreateRequest creates the CancelJob request.
func (client *JobRouterOperationsClient) cancelJobCreateRequest(ctx context.Context, jobID string, opts *JobRouterOperationsClientCancelJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}:cancel"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if opts != nil && opts.Options != nil {
	if err := runtime.MarshalAsJSON(req, *opts.Options); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// cancelJobHandleResponse handles the CancelJob response.
func (client *JobRouterOperationsClient) cancelJobHandleResponse(resp *http.Response) (JobRouterOperationsClientCancelJobResponse, error) {
	result := JobRouterOperationsClientCancelJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.cancelJobResult); err != nil {
		return JobRouterOperationsClientCancelJobResponse{}, err
	}
	return result, nil
}

// CloseJob - Closes a completed job.
//   - jobID - Id of a job.
//   - assignmentID - Id of a job assignment.
//   - opts - JobRouterOperationsClientCloseJobOptions contains the optional parameters for the JobRouterOperationsClient.CloseJob
//     method.
func (client *JobRouterOperationsClient) CloseJob(ctx context.Context, jobID string, assignmentID string, opts *JobRouterOperationsClientCloseJobOptions) (JobRouterOperationsClientCloseJobResponse, error) {
	var err error
	req, err := client.closeJobCreateRequest(ctx, jobID, assignmentID, opts)
	if err != nil {
		return JobRouterOperationsClientCloseJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientCloseJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientCloseJobResponse{}, err
	}
	resp, err := client.closeJobHandleResponse(httpResp)
	return resp, err
}

// closeJobCreateRequest creates the CloseJob request.
func (client *JobRouterOperationsClient) closeJobCreateRequest(ctx context.Context, jobID string, assignmentID string, opts *JobRouterOperationsClientCloseJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}/assignments/{assignmentId}:close"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if assignmentID == "" {
		return nil, errors.New("parameter assignmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assignmentId}", url.PathEscape(assignmentID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if opts != nil && opts.Options != nil {
	if err := runtime.MarshalAsJSON(req, *opts.Options); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// closeJobHandleResponse handles the CloseJob response.
func (client *JobRouterOperationsClient) closeJobHandleResponse(resp *http.Response) (JobRouterOperationsClientCloseJobResponse, error) {
	result := JobRouterOperationsClientCloseJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.closeJobResult); err != nil {
		return JobRouterOperationsClientCloseJobResponse{}, err
	}
	return result, nil
}

// CompleteJob - Completes an assigned job.
//   - jobID - Id of a job.
//   - assignmentID - Id of a job assignment.
//   - opts - JobRouterOperationsClientCompleteJobOptions contains the optional parameters for the JobRouterOperationsClient.CompleteJob
//     method.
func (client *JobRouterOperationsClient) CompleteJob(ctx context.Context, jobID string, assignmentID string, opts *JobRouterOperationsClientCompleteJobOptions) (JobRouterOperationsClientCompleteJobResponse, error) {
	var err error
	req, err := client.completeJobCreateRequest(ctx, jobID, assignmentID, opts)
	if err != nil {
		return JobRouterOperationsClientCompleteJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientCompleteJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientCompleteJobResponse{}, err
	}
	resp, err := client.completeJobHandleResponse(httpResp)
	return resp, err
}

// completeJobCreateRequest creates the CompleteJob request.
func (client *JobRouterOperationsClient) completeJobCreateRequest(ctx context.Context, jobID string, assignmentID string, opts *JobRouterOperationsClientCompleteJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}/assignments/{assignmentId}:complete"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if assignmentID == "" {
		return nil, errors.New("parameter assignmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assignmentId}", url.PathEscape(assignmentID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if opts != nil && opts.Options != nil {
	if err := runtime.MarshalAsJSON(req, *opts.Options); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// completeJobHandleResponse handles the CompleteJob response.
func (client *JobRouterOperationsClient) completeJobHandleResponse(resp *http.Response) (JobRouterOperationsClientCompleteJobResponse, error) {
	result := JobRouterOperationsClientCompleteJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.completeJobResult); err != nil {
		return JobRouterOperationsClientCompleteJobResponse{}, err
	}
	return result, nil
}

// DeclineJobOffer - Declines an offer to work on a job.
//   - workerID - Id of a worker.
//   - offerID - Id of an offer.
//   - opts - JobRouterOperationsClientDeclineJobOfferOptions contains the optional parameters for the JobRouterOperationsClient.DeclineJobOffer
//     method.
func (client *JobRouterOperationsClient) DeclineJobOffer(ctx context.Context, workerID string, offerID string, opts *JobRouterOperationsClientDeclineJobOfferOptions) (JobRouterOperationsClientDeclineJobOfferResponse, error) {
	var err error
	req, err := client.declineJobOfferCreateRequest(ctx, workerID, offerID, opts)
	if err != nil {
		return JobRouterOperationsClientDeclineJobOfferResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientDeclineJobOfferResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientDeclineJobOfferResponse{}, err
	}
	resp, err := client.declineJobOfferHandleResponse(httpResp)
	return resp, err
}

// declineJobOfferCreateRequest creates the DeclineJobOffer request.
func (client *JobRouterOperationsClient) declineJobOfferCreateRequest(ctx context.Context, workerID string, offerID string, opts *JobRouterOperationsClientDeclineJobOfferOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/workers/{workerId}/offers/{offerId}:decline"
	if workerID == "" {
		return nil, errors.New("parameter workerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerId}", url.PathEscape(workerID))
	if offerID == "" {
		return nil, errors.New("parameter offerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{offerId}", url.PathEscape(offerID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if opts != nil && opts.Options != nil {
	if err := runtime.MarshalAsJSON(req, *opts.Options); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// declineJobOfferHandleResponse handles the DeclineJobOffer response.
func (client *JobRouterOperationsClient) declineJobOfferHandleResponse(resp *http.Response) (JobRouterOperationsClientDeclineJobOfferResponse, error) {
	result := JobRouterOperationsClientDeclineJobOfferResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.declineJobOfferResult); err != nil {
		return JobRouterOperationsClientDeclineJobOfferResponse{}, err
	}
	return result, nil
}

// DeleteJob - Deletes a job and all of its traces.
//   - jobID - Id of a job.
//   - options - JobRouterOperationsClientDeleteJobOptions contains the optional parameters for the JobRouterOperationsClient.DeleteJob
//     method.
func (client *JobRouterOperationsClient) DeleteJob(ctx context.Context, jobID string, options *JobRouterOperationsClientDeleteJobOptions) (JobRouterOperationsClientDeleteJobResponse, error) {
	var err error
	req, err := client.deleteJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return JobRouterOperationsClientDeleteJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientDeleteJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientDeleteJobResponse{}, err
	}
	return JobRouterOperationsClientDeleteJobResponse{}, nil
}

// deleteJobCreateRequest creates the DeleteJob request.
func (client *JobRouterOperationsClient) deleteJobCreateRequest(ctx context.Context, jobID string, options *JobRouterOperationsClientDeleteJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// DeleteWorker - Deletes a worker and all of its traces.
//   - workerID - Id of a worker.
//   - options - JobRouterOperationsClientDeleteWorkerOptions contains the optional parameters for the JobRouterOperationsClient.DeleteWorker
//     method.
func (client *JobRouterOperationsClient) DeleteWorker(ctx context.Context, workerID string, options *JobRouterOperationsClientDeleteWorkerOptions) (JobRouterOperationsClientDeleteWorkerResponse, error) {
	var err error
	req, err := client.deleteWorkerCreateRequest(ctx, workerID, options)
	if err != nil {
		return JobRouterOperationsClientDeleteWorkerResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientDeleteWorkerResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientDeleteWorkerResponse{}, err
	}
	return JobRouterOperationsClientDeleteWorkerResponse{}, nil
}

// deleteWorkerCreateRequest creates the DeleteWorker request.
func (client *JobRouterOperationsClient) deleteWorkerCreateRequest(ctx context.Context, workerID string, options *JobRouterOperationsClientDeleteWorkerOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/workers/{workerId}"
	if workerID == "" {
		return nil, errors.New("parameter workerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerId}", url.PathEscape(workerID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// GetInQueuePosition - Gets a job's position details.
//   - jobID - Id of the job.
//   - options - JobRouterOperationsClientGetInQueuePositionOptions contains the optional parameters for the JobRouterOperationsClient.GetInQueuePosition
//     method.
func (client *JobRouterOperationsClient) GetInQueuePosition(ctx context.Context, jobID string, options *JobRouterOperationsClientGetInQueuePositionOptions) (JobRouterOperationsClientGetInQueuePositionResponse, error) {
	var err error
	req, err := client.getInQueuePositionCreateRequest(ctx, jobID, options)
	if err != nil {
		return JobRouterOperationsClientGetInQueuePositionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientGetInQueuePositionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientGetInQueuePositionResponse{}, err
	}
	resp, err := client.getInQueuePositionHandleResponse(httpResp)
	return resp, err
}

// getInQueuePositionCreateRequest creates the GetInQueuePosition request.
func (client *JobRouterOperationsClient) getInQueuePositionCreateRequest(ctx context.Context, jobID string, options *JobRouterOperationsClientGetInQueuePositionOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}/position"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getInQueuePositionHandleResponse handles the GetInQueuePosition response.
func (client *JobRouterOperationsClient) getInQueuePositionHandleResponse(resp *http.Response) (JobRouterOperationsClientGetInQueuePositionResponse, error) {
	result := JobRouterOperationsClientGetInQueuePositionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterJobPositionDetails); err != nil {
		return JobRouterOperationsClientGetInQueuePositionResponse{}, err
	}
	return result, nil
}

// GetJob - Retrieves an existing job by Id.
//   - jobID - Id of a job.
//   - options - JobRouterOperationsClientGetJobOptions contains the optional parameters for the JobRouterOperationsClient.GetJob
//     method.
func (client *JobRouterOperationsClient) GetJob(ctx context.Context, jobID string, options *JobRouterOperationsClientGetJobOptions) (JobRouterOperationsClientGetJobResponse, error) {
	var err error
	req, err := client.getJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return JobRouterOperationsClientGetJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientGetJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientGetJobResponse{}, err
	}
	resp, err := client.getJobHandleResponse(httpResp)
	return resp, err
}

// getJobCreateRequest creates the GetJob request.
func (client *JobRouterOperationsClient) getJobCreateRequest(ctx context.Context, jobID string, options *JobRouterOperationsClientGetJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getJobHandleResponse handles the GetJob response.
func (client *JobRouterOperationsClient) getJobHandleResponse(resp *http.Response) (JobRouterOperationsClientGetJobResponse, error) {
	result := JobRouterOperationsClientGetJobResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterOperationsClientGetJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterJob); err != nil {
		return JobRouterOperationsClientGetJobResponse{}, err
	}
	return result, nil
}

// GetQueueStatistics - Retrieves a queue's statistics.
//   - queueID - Id of the queue to retrieve statistics.
//   - options - JobRouterOperationsClientGetQueueStatisticsOptions contains the optional parameters for the JobRouterOperationsClient.GetQueueStatistics
//     method.
func (client *JobRouterOperationsClient) GetQueueStatistics(ctx context.Context, queueID string, options *JobRouterOperationsClientGetQueueStatisticsOptions) (JobRouterOperationsClientGetQueueStatisticsResponse, error) {
	var err error
	req, err := client.getQueueStatisticsCreateRequest(ctx, queueID, options)
	if err != nil {
		return JobRouterOperationsClientGetQueueStatisticsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientGetQueueStatisticsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientGetQueueStatisticsResponse{}, err
	}
	resp, err := client.getQueueStatisticsHandleResponse(httpResp)
	return resp, err
}

// getQueueStatisticsCreateRequest creates the GetQueueStatistics request.
func (client *JobRouterOperationsClient) getQueueStatisticsCreateRequest(ctx context.Context, queueID string, options *JobRouterOperationsClientGetQueueStatisticsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/queues/{queueId}/statistics"
	if queueID == "" {
		return nil, errors.New("parameter queueID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{queueId}", url.PathEscape(queueID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getQueueStatisticsHandleResponse handles the GetQueueStatistics response.
func (client *JobRouterOperationsClient) getQueueStatisticsHandleResponse(resp *http.Response) (JobRouterOperationsClientGetQueueStatisticsResponse, error) {
	result := JobRouterOperationsClientGetQueueStatisticsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterQueueStatistics); err != nil {
		return JobRouterOperationsClientGetQueueStatisticsResponse{}, err
	}
	return result, nil
}

// GetWorker - Retrieves an existing worker by Id.
//   - workerID - Id of a worker.
//   - options - JobRouterOperationsClientGetWorkerOptions contains the optional parameters for the JobRouterOperationsClient.GetWorker
//     method.
func (client *JobRouterOperationsClient) GetWorker(ctx context.Context, workerID string, options *JobRouterOperationsClientGetWorkerOptions) (JobRouterOperationsClientGetWorkerResponse, error) {
	var err error
	req, err := client.getWorkerCreateRequest(ctx, workerID, options)
	if err != nil {
		return JobRouterOperationsClientGetWorkerResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientGetWorkerResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientGetWorkerResponse{}, err
	}
	resp, err := client.getWorkerHandleResponse(httpResp)
	return resp, err
}

// getWorkerCreateRequest creates the GetWorker request.
func (client *JobRouterOperationsClient) getWorkerCreateRequest(ctx context.Context, workerID string, options *JobRouterOperationsClientGetWorkerOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/workers/{workerId}"
	if workerID == "" {
		return nil, errors.New("parameter workerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerId}", url.PathEscape(workerID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// getWorkerHandleResponse handles the GetWorker response.
func (client *JobRouterOperationsClient) getWorkerHandleResponse(resp *http.Response) (JobRouterOperationsClientGetWorkerResponse, error) {
	result := JobRouterOperationsClientGetWorkerResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterOperationsClientGetWorkerResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterWorker); err != nil {
		return JobRouterOperationsClientGetWorkerResponse{}, err
	}
	return result, nil
}

// NewListJobsPager - Retrieves list of jobs based on filter parameters.
//   - options - JobRouterOperationsClientListJobsOptions contains the optional parameters for the JobRouterOperationsClient.NewListJobsPager
//     method.
func (client *JobRouterOperationsClient) NewListJobsPager(options *JobRouterOperationsClientListJobsOptions) (*runtime.Pager[JobRouterOperationsClientListJobsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[JobRouterOperationsClientListJobsResponse]{
		More: func(page JobRouterOperationsClientListJobsResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *JobRouterOperationsClientListJobsResponse) (JobRouterOperationsClientListJobsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return JobRouterOperationsClientListJobsResponse{}, err
			}
			return client.listJobsHandleResponse(resp)
			},
	})
}

// listJobsCreateRequest creates the ListJobs request.
func (client *JobRouterOperationsClient) listJobsCreateRequest(ctx context.Context, options *JobRouterOperationsClientListJobsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	if options != nil && options.ChannelID != nil {
		reqQP.Set("channelId", *options.ChannelID)
	}
	if options != nil && options.ClassificationPolicyID != nil {
		reqQP.Set("classificationPolicyId", *options.ClassificationPolicyID)
	}
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	if options != nil && options.QueueID != nil {
		reqQP.Set("queueId", *options.QueueID)
	}
	if options != nil && options.ScheduledAfter != nil {
		reqQP.Set("scheduledAfter", options.ScheduledAfter.Format(time.RFC3339Nano))
	}
	if options != nil && options.ScheduledBefore != nil {
		reqQP.Set("scheduledBefore", options.ScheduledBefore.Format(time.RFC3339Nano))
	}
	if options != nil && options.Status != nil {
		reqQP.Set("status", string(*options.Status))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listJobsHandleResponse handles the ListJobs response.
func (client *JobRouterOperationsClient) listJobsHandleResponse(resp *http.Response) (JobRouterOperationsClientListJobsResponse, error) {
	result := JobRouterOperationsClientListJobsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedRouterJob); err != nil {
		return JobRouterOperationsClientListJobsResponse{}, err
	}
	return result, nil
}

// NewListWorkersPager - Retrieves existing workers.
//   - options - JobRouterOperationsClientListWorkersOptions contains the optional parameters for the JobRouterOperationsClient.NewListWorkersPager
//     method.
func (client *JobRouterOperationsClient) NewListWorkersPager(options *JobRouterOperationsClientListWorkersOptions) (*runtime.Pager[JobRouterOperationsClientListWorkersResponse]) {
	return runtime.NewPager(runtime.PagingHandler[JobRouterOperationsClientListWorkersResponse]{
		More: func(page JobRouterOperationsClientListWorkersResponse) bool {
			return page.NextLink != nil && len(*page.NextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *JobRouterOperationsClientListWorkersResponse) (JobRouterOperationsClientListWorkersResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.NextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listWorkersCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return JobRouterOperationsClientListWorkersResponse{}, err
			}
			return client.listWorkersHandleResponse(resp)
			},
	})
}

// listWorkersCreateRequest creates the ListWorkers request.
func (client *JobRouterOperationsClient) listWorkersCreateRequest(ctx context.Context, options *JobRouterOperationsClientListWorkersOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/workers"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	if options != nil && options.ChannelID != nil {
		reqQP.Set("channelId", *options.ChannelID)
	}
	if options != nil && options.HasCapacity != nil {
		reqQP.Set("hasCapacity", strconv.FormatBool(*options.HasCapacity))
	}
	if options != nil && options.Maxpagesize != nil {
		reqQP.Set("maxpagesize", strconv.FormatInt(int64(*options.Maxpagesize), 10))
	}
	if options != nil && options.QueueID != nil {
		reqQP.Set("queueId", *options.QueueID)
	}
	if options != nil && options.State != nil {
		reqQP.Set("state", string(*options.State))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	return req, nil
}

// listWorkersHandleResponse handles the ListWorkers response.
func (client *JobRouterOperationsClient) listWorkersHandleResponse(resp *http.Response) (JobRouterOperationsClientListWorkersResponse, error) {
	result := JobRouterOperationsClientListWorkersResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PagedRouterWorker); err != nil {
		return JobRouterOperationsClientListWorkersResponse{}, err
	}
	return result, nil
}

// ReclassifyJob - Reclassify a job.
//   - jobID - Id of a job.
//   - opts - JobRouterOperationsClientReclassifyJobOptions contains the optional parameters for the JobRouterOperationsClient.ReclassifyJob
//     method.
func (client *JobRouterOperationsClient) ReclassifyJob(ctx context.Context, jobID string, opts *JobRouterOperationsClientReclassifyJobOptions) (JobRouterOperationsClientReclassifyJobResponse, error) {
	var err error
	req, err := client.reclassifyJobCreateRequest(ctx, jobID, opts)
	if err != nil {
		return JobRouterOperationsClientReclassifyJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientReclassifyJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientReclassifyJobResponse{}, err
	}
	resp, err := client.reclassifyJobHandleResponse(httpResp)
	return resp, err
}

// reclassifyJobCreateRequest creates the ReclassifyJob request.
func (client *JobRouterOperationsClient) reclassifyJobCreateRequest(ctx context.Context, jobID string, opts *JobRouterOperationsClientReclassifyJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}:reclassify"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if opts != nil && opts.Options != nil {
	if err := runtime.MarshalAsJSON(req, *opts.Options); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// reclassifyJobHandleResponse handles the ReclassifyJob response.
func (client *JobRouterOperationsClient) reclassifyJobHandleResponse(resp *http.Response) (JobRouterOperationsClientReclassifyJobResponse, error) {
	result := JobRouterOperationsClientReclassifyJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.reclassifyJobResult); err != nil {
		return JobRouterOperationsClientReclassifyJobResponse{}, err
	}
	return result, nil
}

// UnassignJob - Unassign a job.
//   - jobID - Id of a job.
//   - assignmentID - Id of a job assignment.
//   - opts - JobRouterOperationsClientUnassignJobOptions contains the optional parameters for the JobRouterOperationsClient.UnassignJob
//     method.
func (client *JobRouterOperationsClient) UnassignJob(ctx context.Context, jobID string, assignmentID string, opts *JobRouterOperationsClientUnassignJobOptions) (JobRouterOperationsClientUnassignJobResponse, error) {
	var err error
	req, err := client.unassignJobCreateRequest(ctx, jobID, assignmentID, opts)
	if err != nil {
		return JobRouterOperationsClientUnassignJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientUnassignJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientUnassignJobResponse{}, err
	}
	resp, err := client.unassignJobHandleResponse(httpResp)
	return resp, err
}

// unassignJobCreateRequest creates the UnassignJob request.
func (client *JobRouterOperationsClient) unassignJobCreateRequest(ctx context.Context, jobID string, assignmentID string, opts *JobRouterOperationsClientUnassignJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}/assignments/{assignmentId}:unassign"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if assignmentID == "" {
		return nil, errors.New("parameter assignmentID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{assignmentId}", url.PathEscape(assignmentID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/json"}
	if opts != nil && opts.Options != nil {
	if err := runtime.MarshalAsJSON(req, *opts.Options); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// unassignJobHandleResponse handles the UnassignJob response.
func (client *JobRouterOperationsClient) unassignJobHandleResponse(resp *http.Response) (JobRouterOperationsClientUnassignJobResponse, error) {
	result := JobRouterOperationsClientUnassignJobResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.UnassignJobResult); err != nil {
		return JobRouterOperationsClientUnassignJobResponse{}, err
	}
	return result, nil
}

// UpsertJob - Creates or updates a router job.
//   - jobID - Id of a job.
//   - resource - The resource instance.
//   - options - JobRouterOperationsClientUpsertJobOptions contains the optional parameters for the JobRouterOperationsClient.UpsertJob
//     method.
func (client *JobRouterOperationsClient) UpsertJob(ctx context.Context, jobID string, resource RouterJob, options *JobRouterOperationsClientUpsertJobOptions) (JobRouterOperationsClientUpsertJobResponse, error) {
	var err error
	req, err := client.upsertJobCreateRequest(ctx, jobID, resource, options)
	if err != nil {
		return JobRouterOperationsClientUpsertJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientUpsertJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientUpsertJobResponse{}, err
	}
	resp, err := client.upsertJobHandleResponse(httpResp)
	return resp, err
}

// upsertJobCreateRequest creates the UpsertJob request.
func (client *JobRouterOperationsClient) upsertJobCreateRequest(ctx context.Context, jobID string, resource RouterJob, options *JobRouterOperationsClientUpsertJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
	return nil, err
}
	return req, nil
}

// upsertJobHandleResponse handles the UpsertJob response.
func (client *JobRouterOperationsClient) upsertJobHandleResponse(resp *http.Response) (JobRouterOperationsClientUpsertJobResponse, error) {
	result := JobRouterOperationsClientUpsertJobResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterOperationsClientUpsertJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterJob); err != nil {
		return JobRouterOperationsClientUpsertJobResponse{}, err
	}
	return result, nil
}

// UpsertWorker - Creates or updates a worker.
//   - workerID - Id of a worker.
//   - resource - The resource instance.
//   - options - JobRouterOperationsClientUpsertWorkerOptions contains the optional parameters for the JobRouterOperationsClient.UpsertWorker
//     method.
func (client *JobRouterOperationsClient) UpsertWorker(ctx context.Context, workerID string, resource RouterWorker, options *JobRouterOperationsClientUpsertWorkerOptions) (JobRouterOperationsClientUpsertWorkerResponse, error) {
	var err error
	req, err := client.upsertWorkerCreateRequest(ctx, workerID, resource, options)
	if err != nil {
		return JobRouterOperationsClientUpsertWorkerResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return JobRouterOperationsClientUpsertWorkerResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return JobRouterOperationsClientUpsertWorkerResponse{}, err
	}
	resp, err := client.upsertWorkerHandleResponse(httpResp)
	return resp, err
}

// upsertWorkerCreateRequest creates the UpsertWorker request.
func (client *JobRouterOperationsClient) upsertWorkerCreateRequest(ctx context.Context, workerID string, resource RouterWorker, options *JobRouterOperationsClientUpsertWorkerOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/routing/workers/{workerId}"
	if workerID == "" {
		return nil, errors.New("parameter workerID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{workerId}", url.PathEscape(workerID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-01-18-preview")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	req.Raw().Header["Content-Type"] = []string{"application/merge-patch+json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if err := runtime.MarshalAsJSON(req, resource); err != nil {
	return nil, err
}
	return req, nil
}

// upsertWorkerHandleResponse handles the UpsertWorker response.
func (client *JobRouterOperationsClient) upsertWorkerHandleResponse(resp *http.Response) (JobRouterOperationsClientUpsertWorkerResponse, error) {
	result := JobRouterOperationsClientUpsertWorkerResponse{}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return JobRouterOperationsClientUpsertWorkerResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.RouterWorker); err != nil {
		return JobRouterOperationsClientUpsertWorkerResponse{}, err
	}
	return result, nil
}

