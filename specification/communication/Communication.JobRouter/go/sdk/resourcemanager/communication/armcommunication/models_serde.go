// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armcommunication

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AcceptJobOfferResult.
func (a AcceptJobOfferResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assignmentId", a.AssignmentID)
	populate(objectMap, "jobId", a.JobID)
	populate(objectMap, "workerId", a.WorkerID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AcceptJobOfferResult.
func (a *AcceptJobOfferResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignmentId":
				err = unpopulate(val, "AssignmentID", &a.AssignmentID)
			delete(rawMsg, key)
		case "jobId":
				err = unpopulate(val, "JobID", &a.JobID)
			delete(rawMsg, key)
		case "workerId":
				err = unpopulate(val, "WorkerID", &a.WorkerID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BestWorkerMode.
func (b BestWorkerMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bypassSelectors", b.BypassSelectors)
	objectMap["kind"] = DistributionModeKindBestWorker
	populate(objectMap, "maxConcurrentOffers", b.MaxConcurrentOffers)
	populate(objectMap, "minConcurrentOffers", b.MinConcurrentOffers)
	populate(objectMap, "scoringRule", b.ScoringRule)
	populate(objectMap, "scoringRuleOptions", b.ScoringRuleOptions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BestWorkerMode.
func (b *BestWorkerMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bypassSelectors":
				err = unpopulate(val, "BypassSelectors", &b.BypassSelectors)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &b.Kind)
			delete(rawMsg, key)
		case "maxConcurrentOffers":
				err = unpopulate(val, "MaxConcurrentOffers", &b.MaxConcurrentOffers)
			delete(rawMsg, key)
		case "minConcurrentOffers":
				err = unpopulate(val, "MinConcurrentOffers", &b.MinConcurrentOffers)
			delete(rawMsg, key)
		case "scoringRule":
			b.ScoringRule, err = unmarshalRouterRuleClassification(val)
			delete(rawMsg, key)
		case "scoringRuleOptions":
				err = unpopulate(val, "ScoringRuleOptions", &b.ScoringRuleOptions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CancelExceptionAction.
func (c CancelExceptionAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dispositionCode", c.DispositionCode)
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = ExceptionActionKindCancel
	populate(objectMap, "note", c.Note)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CancelExceptionAction.
func (c *CancelExceptionAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dispositionCode":
				err = unpopulate(val, "DispositionCode", &c.DispositionCode)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		case "note":
				err = unpopulate(val, "Note", &c.Note)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CancelJobOptions.
func (c CancelJobOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dispositionCode", c.DispositionCode)
	populate(objectMap, "note", c.Note)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CancelJobOptions.
func (c *CancelJobOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dispositionCode":
				err = unpopulate(val, "DispositionCode", &c.DispositionCode)
			delete(rawMsg, key)
		case "note":
				err = unpopulate(val, "Note", &c.Note)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClassificationPolicy.
func (c ClassificationPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "fallbackQueueId", c.FallbackQueueID)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "prioritizationRule", c.PrioritizationRule)
	populate(objectMap, "queueSelectorAttachments", c.QueueSelectorAttachments)
	populate(objectMap, "workerSelectorAttachments", c.WorkerSelectorAttachments)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClassificationPolicy.
func (c *ClassificationPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, "Etag", &c.Etag)
			delete(rawMsg, key)
		case "fallbackQueueId":
				err = unpopulate(val, "FallbackQueueID", &c.FallbackQueueID)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &c.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &c.Name)
			delete(rawMsg, key)
		case "prioritizationRule":
			c.PrioritizationRule, err = unmarshalRouterRuleClassification(val)
			delete(rawMsg, key)
		case "queueSelectorAttachments":
			c.QueueSelectorAttachments, err = unmarshalQueueSelectorAttachmentClassificationArray(val)
			delete(rawMsg, key)
		case "workerSelectorAttachments":
			c.WorkerSelectorAttachments, err = unmarshalWorkerSelectorAttachmentClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloseJobOptions.
func (c CloseJobOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "closeAt", c.CloseAt)
	populate(objectMap, "dispositionCode", c.DispositionCode)
	populate(objectMap, "note", c.Note)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloseJobOptions.
func (c *CloseJobOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "closeAt":
				err = unpopulateDateTimeRFC3339(val, "CloseAt", &c.CloseAt)
			delete(rawMsg, key)
		case "dispositionCode":
				err = unpopulate(val, "DispositionCode", &c.DispositionCode)
			delete(rawMsg, key)
		case "note":
				err = unpopulate(val, "Note", &c.Note)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CompleteJobOptions.
func (c CompleteJobOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "note", c.Note)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CompleteJobOptions.
func (c *CompleteJobOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "note":
				err = unpopulate(val, "Note", &c.Note)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConditionalQueueSelectorAttachment.
func (c ConditionalQueueSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "condition", c.Condition)
	objectMap["kind"] = QueueSelectorAttachmentKindConditional
	populate(objectMap, "queueSelectors", c.QueueSelectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConditionalQueueSelectorAttachment.
func (c *ConditionalQueueSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "condition":
			c.Condition, err = unmarshalRouterRuleClassification(val)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		case "queueSelectors":
				err = unpopulate(val, "QueueSelectors", &c.QueueSelectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConditionalWorkerSelectorAttachment.
func (c ConditionalWorkerSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "condition", c.Condition)
	objectMap["kind"] = WorkerSelectorAttachmentKindConditional
	populate(objectMap, "workerSelectors", c.WorkerSelectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConditionalWorkerSelectorAttachment.
func (c *ConditionalWorkerSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "condition":
			c.Condition, err = unmarshalRouterRuleClassification(val)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &c.Kind)
			delete(rawMsg, key)
		case "workerSelectors":
				err = unpopulate(val, "WorkerSelectors", &c.WorkerSelectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeclineJobOfferOptions.
func (d DeclineJobOfferOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "retryOfferAt", d.RetryOfferAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeclineJobOfferOptions.
func (d *DeclineJobOfferOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "retryOfferAt":
				err = unpopulateDateTimeRFC3339(val, "RetryOfferAt", &d.RetryOfferAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DirectMapRouterRule.
func (d DirectMapRouterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = RouterRuleKindDirectMap
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DirectMapRouterRule.
func (d *DirectMapRouterRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &d.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistributionMode.
func (d DistributionMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bypassSelectors", d.BypassSelectors)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "maxConcurrentOffers", d.MaxConcurrentOffers)
	populate(objectMap, "minConcurrentOffers", d.MinConcurrentOffers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistributionMode.
func (d *DistributionMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bypassSelectors":
				err = unpopulate(val, "BypassSelectors", &d.BypassSelectors)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &d.Kind)
			delete(rawMsg, key)
		case "maxConcurrentOffers":
				err = unpopulate(val, "MaxConcurrentOffers", &d.MaxConcurrentOffers)
			delete(rawMsg, key)
		case "minConcurrentOffers":
				err = unpopulate(val, "MinConcurrentOffers", &d.MinConcurrentOffers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DistributionPolicy.
func (d DistributionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "mode", d.Mode)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "offerExpiresAfterSeconds", d.OfferExpiresAfterSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DistributionPolicy.
func (d *DistributionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, "Etag", &d.Etag)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &d.ID)
			delete(rawMsg, key)
		case "mode":
			d.Mode, err = unmarshalDistributionModeClassification(val)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &d.Name)
			delete(rawMsg, key)
		case "offerExpiresAfterSeconds":
				err = unpopulate(val, "OfferExpiresAfterSeconds", &d.OfferExpiresAfterSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExceptionAction.
func (e ExceptionAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "kind", e.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExceptionAction.
func (e *ExceptionAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExceptionPolicy.
func (e ExceptionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "etag", e.Etag)
	populate(objectMap, "exceptionRules", e.ExceptionRules)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "name", e.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExceptionPolicy.
func (e *ExceptionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, "Etag", &e.Etag)
			delete(rawMsg, key)
		case "exceptionRules":
				err = unpopulate(val, "ExceptionRules", &e.ExceptionRules)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExceptionRule.
func (e ExceptionRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "actions", e.Actions)
	populate(objectMap, "id", e.ID)
	populate(objectMap, "trigger", e.Trigger)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExceptionRule.
func (e *ExceptionRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "actions":
			e.Actions, err = unmarshalExceptionActionClassificationArray(val)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &e.ID)
			delete(rawMsg, key)
		case "trigger":
			e.Trigger, err = unmarshalExceptionTriggerClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExceptionTrigger.
func (e ExceptionTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", e.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExceptionTrigger.
func (e *ExceptionTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExpressionRouterRule.
func (e ExpressionRouterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expression", e.Expression)
	objectMap["kind"] = RouterRuleKindExpression
	populate(objectMap, "language", e.Language)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExpressionRouterRule.
func (e *ExpressionRouterRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expression":
				err = unpopulate(val, "Expression", &e.Expression)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &e.Kind)
			delete(rawMsg, key)
		case "language":
				err = unpopulate(val, "Language", &e.Language)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FunctionRouterRule.
func (f FunctionRouterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "credential", f.Credential)
	populate(objectMap, "functionUri", f.FunctionURI)
	objectMap["kind"] = RouterRuleKindFunction
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FunctionRouterRule.
func (f *FunctionRouterRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "credential":
				err = unpopulate(val, "Credential", &f.Credential)
			delete(rawMsg, key)
		case "functionUri":
				err = unpopulate(val, "FunctionURI", &f.FunctionURI)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &f.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FunctionRouterRuleCredential.
func (f FunctionRouterRuleCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "appKey", f.AppKey)
	populate(objectMap, "clientId", f.ClientID)
	populate(objectMap, "functionKey", f.FunctionKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FunctionRouterRuleCredential.
func (f *FunctionRouterRuleCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appKey":
				err = unpopulate(val, "AppKey", &f.AppKey)
			delete(rawMsg, key)
		case "clientId":
				err = unpopulate(val, "ClientID", &f.ClientID)
			delete(rawMsg, key)
		case "functionKey":
				err = unpopulate(val, "FunctionKey", &f.FunctionKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type JobMatchingMode.
func (j JobMatchingMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", j.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobMatchingMode.
func (j *JobMatchingMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", j, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &j.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", j, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LongestIdleMode.
func (l LongestIdleMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bypassSelectors", l.BypassSelectors)
	objectMap["kind"] = DistributionModeKindLongestIdle
	populate(objectMap, "maxConcurrentOffers", l.MaxConcurrentOffers)
	populate(objectMap, "minConcurrentOffers", l.MinConcurrentOffers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LongestIdleMode.
func (l *LongestIdleMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bypassSelectors":
				err = unpopulate(val, "BypassSelectors", &l.BypassSelectors)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &l.Kind)
			delete(rawMsg, key)
		case "maxConcurrentOffers":
				err = unpopulate(val, "MaxConcurrentOffers", &l.MaxConcurrentOffers)
			delete(rawMsg, key)
		case "minConcurrentOffers":
				err = unpopulate(val, "MinConcurrentOffers", &l.MinConcurrentOffers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManualReclassifyExceptionAction.
func (m ManualReclassifyExceptionAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = ExceptionActionKindManualReclassify
	populate(objectMap, "priority", m.Priority)
	populate(objectMap, "queueId", m.QueueID)
	populate(objectMap, "workerSelectors", m.WorkerSelectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManualReclassifyExceptionAction.
func (m *ManualReclassifyExceptionAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &m.ID)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &m.Kind)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &m.Priority)
			delete(rawMsg, key)
		case "queueId":
				err = unpopulate(val, "QueueID", &m.QueueID)
			delete(rawMsg, key)
		case "workerSelectors":
				err = unpopulate(val, "WorkerSelectors", &m.WorkerSelectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OAuth2WebhookClientCredential.
func (o OAuth2WebhookClientCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", o.ClientID)
	populate(objectMap, "clientSecret", o.ClientSecret)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OAuth2WebhookClientCredential.
func (o *OAuth2WebhookClientCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
				err = unpopulate(val, "ClientID", &o.ClientID)
			delete(rawMsg, key)
		case "clientSecret":
				err = unpopulate(val, "ClientSecret", &o.ClientSecret)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedClassificationPolicy.
func (p PagedClassificationPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedClassificationPolicy.
func (p *PagedClassificationPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedDistributionPolicy.
func (p PagedDistributionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedDistributionPolicy.
func (p *PagedDistributionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedExceptionPolicy.
func (p PagedExceptionPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedExceptionPolicy.
func (p *PagedExceptionPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedRouterJob.
func (p PagedRouterJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedRouterJob.
func (p *PagedRouterJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedRouterQueue.
func (p PagedRouterQueue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedRouterQueue.
func (p *PagedRouterQueue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PagedRouterWorker.
func (p PagedRouterWorker) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PagedRouterWorker.
func (p *PagedRouterWorker) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nextLink":
				err = unpopulate(val, "NextLink", &p.NextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &p.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PassThroughQueueSelectorAttachment.
func (p PassThroughQueueSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", p.Key)
	objectMap["kind"] = QueueSelectorAttachmentKindPassThrough
	populate(objectMap, "labelOperator", p.LabelOperator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PassThroughQueueSelectorAttachment.
func (p *PassThroughQueueSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &p.Key)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &p.Kind)
			delete(rawMsg, key)
		case "labelOperator":
				err = unpopulate(val, "LabelOperator", &p.LabelOperator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PassThroughWorkerSelectorAttachment.
func (p PassThroughWorkerSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expiresAfterSeconds", p.ExpiresAfterSeconds)
	populate(objectMap, "key", p.Key)
	objectMap["kind"] = WorkerSelectorAttachmentKindPassThrough
	populate(objectMap, "labelOperator", p.LabelOperator)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PassThroughWorkerSelectorAttachment.
func (p *PassThroughWorkerSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiresAfterSeconds":
				err = unpopulate(val, "ExpiresAfterSeconds", &p.ExpiresAfterSeconds)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &p.Key)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &p.Kind)
			delete(rawMsg, key)
		case "labelOperator":
				err = unpopulate(val, "LabelOperator", &p.LabelOperator)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueueAndMatchMode.
func (q QueueAndMatchMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = JobMatchingModeKindQueueAndMatch
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueAndMatchMode.
func (q *QueueAndMatchMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &q.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueueLengthExceptionTrigger.
func (q QueueLengthExceptionTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = ExceptionTriggerKindQueueLength
	populate(objectMap, "threshold", q.Threshold)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueLengthExceptionTrigger.
func (q *QueueLengthExceptionTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &q.Kind)
			delete(rawMsg, key)
		case "threshold":
				err = unpopulate(val, "Threshold", &q.Threshold)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueueSelectorAttachment.
func (q QueueSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", q.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueSelectorAttachment.
func (q *QueueSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &q.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type QueueWeightedAllocation.
func (q QueueWeightedAllocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "queueSelectors", q.QueueSelectors)
	populate(objectMap, "weight", q.Weight)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type QueueWeightedAllocation.
func (q *QueueWeightedAllocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", q, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "queueSelectors":
				err = unpopulate(val, "QueueSelectors", &q.QueueSelectors)
			delete(rawMsg, key)
		case "weight":
				err = unpopulate(val, "Weight", &q.Weight)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", q, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ReclassifyExceptionAction.
func (r ReclassifyExceptionAction) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "classificationPolicyId", r.ClassificationPolicyID)
	populate(objectMap, "id", r.ID)
	objectMap["kind"] = ExceptionActionKindReclassify
	populate(objectMap, "labelsToUpsert", r.LabelsToUpsert)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ReclassifyExceptionAction.
func (r *ReclassifyExceptionAction) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "classificationPolicyId":
				err = unpopulate(val, "ClassificationPolicyID", &r.ClassificationPolicyID)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &r.Kind)
			delete(rawMsg, key)
		case "labelsToUpsert":
				err = unpopulate(val, "LabelsToUpsert", &r.LabelsToUpsert)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RoundRobinMode.
func (r RoundRobinMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "bypassSelectors", r.BypassSelectors)
	objectMap["kind"] = DistributionModeKindRoundRobin
	populate(objectMap, "maxConcurrentOffers", r.MaxConcurrentOffers)
	populate(objectMap, "minConcurrentOffers", r.MinConcurrentOffers)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RoundRobinMode.
func (r *RoundRobinMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bypassSelectors":
				err = unpopulate(val, "BypassSelectors", &r.BypassSelectors)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &r.Kind)
			delete(rawMsg, key)
		case "maxConcurrentOffers":
				err = unpopulate(val, "MaxConcurrentOffers", &r.MaxConcurrentOffers)
			delete(rawMsg, key)
		case "minConcurrentOffers":
				err = unpopulate(val, "MinConcurrentOffers", &r.MinConcurrentOffers)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterChannel.
func (r RouterChannel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityCostPerJob", r.CapacityCostPerJob)
	populate(objectMap, "channelId", r.ChannelID)
	populate(objectMap, "maxNumberOfJobs", r.MaxNumberOfJobs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterChannel.
func (r *RouterChannel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityCostPerJob":
				err = unpopulate(val, "CapacityCostPerJob", &r.CapacityCostPerJob)
			delete(rawMsg, key)
		case "channelId":
				err = unpopulate(val, "ChannelID", &r.ChannelID)
			delete(rawMsg, key)
		case "maxNumberOfJobs":
				err = unpopulate(val, "MaxNumberOfJobs", &r.MaxNumberOfJobs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterJob.
func (r RouterJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assignments", r.Assignments)
	populate(objectMap, "attachedWorkerSelectors", r.AttachedWorkerSelectors)
	populate(objectMap, "channelId", r.ChannelID)
	populate(objectMap, "channelReference", r.ChannelReference)
	populate(objectMap, "classificationPolicyId", r.ClassificationPolicyID)
	populate(objectMap, "dispositionCode", r.DispositionCode)
	populateDateTimeRFC3339(objectMap, "enqueuedAt", r.EnqueuedAt)
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "labels", r.Labels)
	populate(objectMap, "matchingMode", r.MatchingMode)
	populate(objectMap, "notes", r.Notes)
	populate(objectMap, "priority", r.Priority)
	populate(objectMap, "queueId", r.QueueID)
	populate(objectMap, "requestedWorkerSelectors", r.RequestedWorkerSelectors)
	populateDateTimeRFC3339(objectMap, "scheduledAt", r.ScheduledAt)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterJob.
func (r *RouterJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignments":
				err = unpopulate(val, "Assignments", &r.Assignments)
			delete(rawMsg, key)
		case "attachedWorkerSelectors":
				err = unpopulate(val, "AttachedWorkerSelectors", &r.AttachedWorkerSelectors)
			delete(rawMsg, key)
		case "channelId":
				err = unpopulate(val, "ChannelID", &r.ChannelID)
			delete(rawMsg, key)
		case "channelReference":
				err = unpopulate(val, "ChannelReference", &r.ChannelReference)
			delete(rawMsg, key)
		case "classificationPolicyId":
				err = unpopulate(val, "ClassificationPolicyID", &r.ClassificationPolicyID)
			delete(rawMsg, key)
		case "dispositionCode":
				err = unpopulate(val, "DispositionCode", &r.DispositionCode)
			delete(rawMsg, key)
		case "enqueuedAt":
				err = unpopulateDateTimeRFC3339(val, "EnqueuedAt", &r.EnqueuedAt)
			delete(rawMsg, key)
		case "etag":
				err = unpopulate(val, "Etag", &r.Etag)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &r.Labels)
			delete(rawMsg, key)
		case "matchingMode":
			r.MatchingMode, err = unmarshalJobMatchingModeClassification(val)
			delete(rawMsg, key)
		case "notes":
				err = unpopulate(val, "Notes", &r.Notes)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &r.Priority)
			delete(rawMsg, key)
		case "queueId":
				err = unpopulate(val, "QueueID", &r.QueueID)
			delete(rawMsg, key)
		case "requestedWorkerSelectors":
				err = unpopulate(val, "RequestedWorkerSelectors", &r.RequestedWorkerSelectors)
			delete(rawMsg, key)
		case "scheduledAt":
				err = unpopulateDateTimeRFC3339(val, "ScheduledAt", &r.ScheduledAt)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &r.Status)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterJobAssignment.
func (r RouterJobAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "assignedAt", r.AssignedAt)
	populate(objectMap, "assignmentId", r.AssignmentID)
	populateDateTimeRFC3339(objectMap, "closedAt", r.ClosedAt)
	populateDateTimeRFC3339(objectMap, "completedAt", r.CompletedAt)
	populate(objectMap, "workerId", r.WorkerID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterJobAssignment.
func (r *RouterJobAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignedAt":
				err = unpopulateDateTimeRFC3339(val, "AssignedAt", &r.AssignedAt)
			delete(rawMsg, key)
		case "assignmentId":
				err = unpopulate(val, "AssignmentID", &r.AssignmentID)
			delete(rawMsg, key)
		case "closedAt":
				err = unpopulateDateTimeRFC3339(val, "ClosedAt", &r.ClosedAt)
			delete(rawMsg, key)
		case "completedAt":
				err = unpopulateDateTimeRFC3339(val, "CompletedAt", &r.CompletedAt)
			delete(rawMsg, key)
		case "workerId":
				err = unpopulate(val, "WorkerID", &r.WorkerID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterJobNote.
func (r RouterJobNote) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "addedAt", r.AddedAt)
	populate(objectMap, "message", r.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterJobNote.
func (r *RouterJobNote) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "addedAt":
				err = unpopulateDateTimeRFC3339(val, "AddedAt", &r.AddedAt)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &r.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterJobOffer.
func (r RouterJobOffer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "capacityCost", r.CapacityCost)
	populateDateTimeRFC3339(objectMap, "expiresAt", r.ExpiresAt)
	populate(objectMap, "jobId", r.JobID)
	populate(objectMap, "offerId", r.OfferID)
	populateDateTimeRFC3339(objectMap, "offeredAt", r.OfferedAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterJobOffer.
func (r *RouterJobOffer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityCost":
				err = unpopulate(val, "CapacityCost", &r.CapacityCost)
			delete(rawMsg, key)
		case "expiresAt":
				err = unpopulateDateTimeRFC3339(val, "ExpiresAt", &r.ExpiresAt)
			delete(rawMsg, key)
		case "jobId":
				err = unpopulate(val, "JobID", &r.JobID)
			delete(rawMsg, key)
		case "offerId":
				err = unpopulate(val, "OfferID", &r.OfferID)
			delete(rawMsg, key)
		case "offeredAt":
				err = unpopulateDateTimeRFC3339(val, "OfferedAt", &r.OfferedAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterJobPositionDetails.
func (r RouterJobPositionDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedWaitTimeMinutes", r.EstimatedWaitTimeMinutes)
	populate(objectMap, "jobId", r.JobID)
	populate(objectMap, "position", r.Position)
	populate(objectMap, "queueId", r.QueueID)
	populate(objectMap, "queueLength", r.QueueLength)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterJobPositionDetails.
func (r *RouterJobPositionDetails) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedWaitTimeMinutes":
				err = unpopulate(val, "EstimatedWaitTimeMinutes", &r.EstimatedWaitTimeMinutes)
			delete(rawMsg, key)
		case "jobId":
				err = unpopulate(val, "JobID", &r.JobID)
			delete(rawMsg, key)
		case "position":
				err = unpopulate(val, "Position", &r.Position)
			delete(rawMsg, key)
		case "queueId":
				err = unpopulate(val, "QueueID", &r.QueueID)
			delete(rawMsg, key)
		case "queueLength":
				err = unpopulate(val, "QueueLength", &r.QueueLength)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterQueue.
func (r RouterQueue) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "distributionPolicyId", r.DistributionPolicyID)
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "exceptionPolicyId", r.ExceptionPolicyID)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "labels", r.Labels)
	populate(objectMap, "name", r.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterQueue.
func (r *RouterQueue) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "distributionPolicyId":
				err = unpopulate(val, "DistributionPolicyID", &r.DistributionPolicyID)
			delete(rawMsg, key)
		case "etag":
				err = unpopulate(val, "Etag", &r.Etag)
			delete(rawMsg, key)
		case "exceptionPolicyId":
				err = unpopulate(val, "ExceptionPolicyID", &r.ExceptionPolicyID)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &r.Labels)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &r.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterQueueSelector.
func (r RouterQueueSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", r.Key)
	populate(objectMap, "labelOperator", r.LabelOperator)
	populateAny(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterQueueSelector.
func (r *RouterQueueSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &r.Key)
			delete(rawMsg, key)
		case "labelOperator":
				err = unpopulate(val, "LabelOperator", &r.LabelOperator)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterQueueStatistics.
func (r RouterQueueStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "estimatedWaitTimeMinutes", r.EstimatedWaitTimeMinutes)
	populate(objectMap, "length", r.Length)
	populate(objectMap, "longestJobWaitTimeMinutes", r.LongestJobWaitTimeMinutes)
	populate(objectMap, "queueId", r.QueueID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterQueueStatistics.
func (r *RouterQueueStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "estimatedWaitTimeMinutes":
				err = unpopulate(val, "EstimatedWaitTimeMinutes", &r.EstimatedWaitTimeMinutes)
			delete(rawMsg, key)
		case "length":
				err = unpopulate(val, "Length", &r.Length)
			delete(rawMsg, key)
		case "longestJobWaitTimeMinutes":
				err = unpopulate(val, "LongestJobWaitTimeMinutes", &r.LongestJobWaitTimeMinutes)
			delete(rawMsg, key)
		case "queueId":
				err = unpopulate(val, "QueueID", &r.QueueID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterRule.
func (r RouterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", r.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterRule.
func (r *RouterRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &r.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterWorker.
func (r RouterWorker) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "assignedJobs", r.AssignedJobs)
	populate(objectMap, "availableForOffers", r.AvailableForOffers)
	populate(objectMap, "capacity", r.Capacity)
	populate(objectMap, "channels", r.Channels)
	populate(objectMap, "etag", r.Etag)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "labels", r.Labels)
	populate(objectMap, "loadRatio", r.LoadRatio)
	populate(objectMap, "maxConcurrentOffers", r.MaxConcurrentOffers)
	populate(objectMap, "offers", r.Offers)
	populate(objectMap, "queues", r.Queues)
	populate(objectMap, "state", r.State)
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterWorker.
func (r *RouterWorker) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignedJobs":
				err = unpopulate(val, "AssignedJobs", &r.AssignedJobs)
			delete(rawMsg, key)
		case "availableForOffers":
				err = unpopulate(val, "AvailableForOffers", &r.AvailableForOffers)
			delete(rawMsg, key)
		case "capacity":
				err = unpopulate(val, "Capacity", &r.Capacity)
			delete(rawMsg, key)
		case "channels":
				err = unpopulate(val, "Channels", &r.Channels)
			delete(rawMsg, key)
		case "etag":
				err = unpopulate(val, "Etag", &r.Etag)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "labels":
				err = unpopulate(val, "Labels", &r.Labels)
			delete(rawMsg, key)
		case "loadRatio":
				err = unpopulate(val, "LoadRatio", &r.LoadRatio)
			delete(rawMsg, key)
		case "maxConcurrentOffers":
				err = unpopulate(val, "MaxConcurrentOffers", &r.MaxConcurrentOffers)
			delete(rawMsg, key)
		case "offers":
				err = unpopulate(val, "Offers", &r.Offers)
			delete(rawMsg, key)
		case "queues":
				err = unpopulate(val, "Queues", &r.Queues)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &r.State)
			delete(rawMsg, key)
		case "tags":
				err = unpopulate(val, "Tags", &r.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterWorkerAssignment.
func (r RouterWorkerAssignment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "assignedAt", r.AssignedAt)
	populate(objectMap, "assignmentId", r.AssignmentID)
	populate(objectMap, "capacityCost", r.CapacityCost)
	populate(objectMap, "jobId", r.JobID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterWorkerAssignment.
func (r *RouterWorkerAssignment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "assignedAt":
				err = unpopulateDateTimeRFC3339(val, "AssignedAt", &r.AssignedAt)
			delete(rawMsg, key)
		case "assignmentId":
				err = unpopulate(val, "AssignmentID", &r.AssignmentID)
			delete(rawMsg, key)
		case "capacityCost":
				err = unpopulate(val, "CapacityCost", &r.CapacityCost)
			delete(rawMsg, key)
		case "jobId":
				err = unpopulate(val, "JobID", &r.JobID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RouterWorkerSelector.
func (r RouterWorkerSelector) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "expedite", r.Expedite)
	populate(objectMap, "expiresAfterSeconds", r.ExpiresAfterSeconds)
	populateDateTimeRFC3339(objectMap, "expiresAt", r.ExpiresAt)
	populate(objectMap, "key", r.Key)
	populate(objectMap, "labelOperator", r.LabelOperator)
	populate(objectMap, "status", r.Status)
	populateAny(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RouterWorkerSelector.
func (r *RouterWorkerSelector) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expedite":
				err = unpopulate(val, "Expedite", &r.Expedite)
			delete(rawMsg, key)
		case "expiresAfterSeconds":
				err = unpopulate(val, "ExpiresAfterSeconds", &r.ExpiresAfterSeconds)
			delete(rawMsg, key)
		case "expiresAt":
				err = unpopulateDateTimeRFC3339(val, "ExpiresAt", &r.ExpiresAt)
			delete(rawMsg, key)
		case "key":
				err = unpopulate(val, "Key", &r.Key)
			delete(rawMsg, key)
		case "labelOperator":
				err = unpopulate(val, "LabelOperator", &r.LabelOperator)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &r.Status)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &r.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuleEngineQueueSelectorAttachment.
func (r RuleEngineQueueSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = QueueSelectorAttachmentKindRuleEngine
	populate(objectMap, "rule", r.Rule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleEngineQueueSelectorAttachment.
func (r *RuleEngineQueueSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &r.Kind)
			delete(rawMsg, key)
		case "rule":
			r.Rule, err = unmarshalRouterRuleClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RuleEngineWorkerSelectorAttachment.
func (r RuleEngineWorkerSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = WorkerSelectorAttachmentKindRuleEngine
	populate(objectMap, "rule", r.Rule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RuleEngineWorkerSelectorAttachment.
func (r *RuleEngineWorkerSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &r.Kind)
			delete(rawMsg, key)
		case "rule":
			r.Rule, err = unmarshalRouterRuleClassification(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleAndSuspendMode.
func (s ScheduleAndSuspendMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = JobMatchingModeKindScheduleAndSuspend
	populateDateTimeRFC3339(objectMap, "scheduleAt", s.ScheduleAt)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScheduleAndSuspendMode.
func (s *ScheduleAndSuspendMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		case "scheduleAt":
				err = unpopulateDateTimeRFC3339(val, "ScheduleAt", &s.ScheduleAt)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ScoringRuleOptions.
func (s ScoringRuleOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "batchSize", s.BatchSize)
	populate(objectMap, "descendingOrder", s.DescendingOrder)
	populate(objectMap, "isBatchScoringEnabled", s.IsBatchScoringEnabled)
	populate(objectMap, "scoringParameters", s.ScoringParameters)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ScoringRuleOptions.
func (s *ScoringRuleOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSize":
				err = unpopulate(val, "BatchSize", &s.BatchSize)
			delete(rawMsg, key)
		case "descendingOrder":
				err = unpopulate(val, "DescendingOrder", &s.DescendingOrder)
			delete(rawMsg, key)
		case "isBatchScoringEnabled":
				err = unpopulate(val, "IsBatchScoringEnabled", &s.IsBatchScoringEnabled)
			delete(rawMsg, key)
		case "scoringParameters":
				err = unpopulate(val, "ScoringParameters", &s.ScoringParameters)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StaticQueueSelectorAttachment.
func (s StaticQueueSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = QueueSelectorAttachmentKindStatic
	populate(objectMap, "queueSelector", s.QueueSelector)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticQueueSelectorAttachment.
func (s *StaticQueueSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		case "queueSelector":
				err = unpopulate(val, "QueueSelector", &s.QueueSelector)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StaticRouterRule.
func (s StaticRouterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = RouterRuleKindStatic
	populateAny(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticRouterRule.
func (s *StaticRouterRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &s.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StaticWorkerSelectorAttachment.
func (s StaticWorkerSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = WorkerSelectorAttachmentKindStatic
	populate(objectMap, "workerSelector", s.WorkerSelector)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StaticWorkerSelectorAttachment.
func (s *StaticWorkerSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		case "workerSelector":
				err = unpopulate(val, "WorkerSelector", &s.WorkerSelector)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SuspendMode.
func (s SuspendMode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = JobMatchingModeKindSuspend
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SuspendMode.
func (s *SuspendMode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &s.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnassignJobOptions.
func (u UnassignJobOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "suspendMatching", u.SuspendMatching)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnassignJobOptions.
func (u *UnassignJobOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "suspendMatching":
				err = unpopulate(val, "SuspendMatching", &u.SuspendMatching)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UnassignJobResult.
func (u UnassignJobResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobId", u.JobID)
	populate(objectMap, "unassignmentCount", u.UnassignmentCount)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UnassignJobResult.
func (u *UnassignJobResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobId":
				err = unpopulate(val, "JobID", &u.JobID)
			delete(rawMsg, key)
		case "unassignmentCount":
				err = unpopulate(val, "UnassignmentCount", &u.UnassignmentCount)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WaitTimeExceptionTrigger.
func (w WaitTimeExceptionTrigger) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	objectMap["kind"] = ExceptionTriggerKindWaitTime
	populate(objectMap, "thresholdSeconds", w.ThresholdSeconds)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WaitTimeExceptionTrigger.
func (w *WaitTimeExceptionTrigger) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &w.Kind)
			delete(rawMsg, key)
		case "thresholdSeconds":
				err = unpopulate(val, "ThresholdSeconds", &w.ThresholdSeconds)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WebhookRouterRule.
func (w WebhookRouterRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "authorizationServerUri", w.AuthorizationServerURI)
	populate(objectMap, "clientCredential", w.ClientCredential)
	objectMap["kind"] = RouterRuleKindWebhook
	populate(objectMap, "webhookUri", w.WebhookURI)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WebhookRouterRule.
func (w *WebhookRouterRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "authorizationServerUri":
				err = unpopulate(val, "AuthorizationServerURI", &w.AuthorizationServerURI)
			delete(rawMsg, key)
		case "clientCredential":
				err = unpopulate(val, "ClientCredential", &w.ClientCredential)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &w.Kind)
			delete(rawMsg, key)
		case "webhookUri":
				err = unpopulate(val, "WebhookURI", &w.WebhookURI)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WeightedAllocationQueueSelectorAttachment.
func (w WeightedAllocationQueueSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allocations", w.Allocations)
	objectMap["kind"] = QueueSelectorAttachmentKindWeightedAllocation
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WeightedAllocationQueueSelectorAttachment.
func (w *WeightedAllocationQueueSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocations":
				err = unpopulate(val, "Allocations", &w.Allocations)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &w.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WeightedAllocationWorkerSelectorAttachment.
func (w WeightedAllocationWorkerSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allocations", w.Allocations)
	objectMap["kind"] = WorkerSelectorAttachmentKindWeightedAllocation
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WeightedAllocationWorkerSelectorAttachment.
func (w *WeightedAllocationWorkerSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocations":
				err = unpopulate(val, "Allocations", &w.Allocations)
			delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, "Kind", &w.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkerSelectorAttachment.
func (w WorkerSelectorAttachment) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kind", w.Kind)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkerSelectorAttachment.
func (w *WorkerSelectorAttachment) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kind":
				err = unpopulate(val, "Kind", &w.Kind)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WorkerWeightedAllocation.
func (w WorkerWeightedAllocation) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "weight", w.Weight)
	populate(objectMap, "workerSelectors", w.WorkerSelectors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WorkerWeightedAllocation.
func (w *WorkerWeightedAllocation) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "weight":
				err = unpopulate(val, "Weight", &w.Weight)
			delete(rawMsg, key)
		case "workerSelectors":
				err = unpopulate(val, "WorkerSelectors", &w.WorkerSelectors)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func populateAny(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

