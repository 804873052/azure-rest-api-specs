// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armbatch

import (
	"encoding/json"
	"fmt"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type AffinityInfo.
func (a AffinityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityId", a.AffinityID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AffinityInfo.
func (a *AffinityInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityId":
				err = unpopulate(val, "AffinityID", &a.AffinityID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AuthenticationTokenSettings.
func (a AuthenticationTokenSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access", a.Access)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AuthenticationTokenSettings.
func (a *AuthenticationTokenSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access":
				err = unpopulate(val, "Access", &a.Access)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoScaleRun.
func (a AutoScaleRun) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "error", a.Error)
	populate(objectMap, "results", a.Results)
	populateDateTimeRFC3339(objectMap, "timestamp", a.Timestamp)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoScaleRun.
func (a *AutoScaleRun) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
				err = unpopulate(val, "Error", &a.Error)
			delete(rawMsg, key)
		case "results":
				err = unpopulate(val, "Results", &a.Results)
			delete(rawMsg, key)
		case "timestamp":
				err = unpopulateDateTimeRFC3339(val, "Timestamp", &a.Timestamp)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoScaleRunError.
func (a AutoScaleRunError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", a.Code)
	populate(objectMap, "message", a.Message)
	populate(objectMap, "values", a.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoScaleRunError.
func (a *AutoScaleRunError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &a.Code)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &a.Message)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &a.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutoUserSpecification.
func (a AutoUserSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "elevationLevel", a.ElevationLevel)
	populate(objectMap, "scope", a.Scope)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutoUserSpecification.
func (a *AutoUserSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "elevationLevel":
				err = unpopulate(val, "ElevationLevel", &a.ElevationLevel)
			delete(rawMsg, key)
		case "scope":
				err = unpopulate(val, "Scope", &a.Scope)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AutomaticOsUpgradePolicy.
func (a AutomaticOsUpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableAutomaticRollback", a.DisableAutomaticRollback)
	populate(objectMap, "enableAutomaticOsUpgrade", a.EnableAutomaticOSUpgrade)
	populate(objectMap, "osRollingUpgradeDeferral", a.OSRollingUpgradeDeferral)
	populate(objectMap, "useRollingUpgradePolicy", a.UseRollingUpgradePolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AutomaticOsUpgradePolicy.
func (a *AutomaticOsUpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableAutomaticRollback":
				err = unpopulate(val, "DisableAutomaticRollback", &a.DisableAutomaticRollback)
			delete(rawMsg, key)
		case "enableAutomaticOsUpgrade":
				err = unpopulate(val, "EnableAutomaticOSUpgrade", &a.EnableAutomaticOSUpgrade)
			delete(rawMsg, key)
		case "osRollingUpgradeDeferral":
				err = unpopulate(val, "OSRollingUpgradeDeferral", &a.OSRollingUpgradeDeferral)
			delete(rawMsg, key)
		case "useRollingUpgradePolicy":
				err = unpopulate(val, "UseRollingUpgradePolicy", &a.UseRollingUpgradePolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureBlobFileSystemConfiguration.
func (a AzureBlobFileSystemConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "blobfuseOptions", a.BlobfuseOptions)
	populate(objectMap, "containerName", a.ContainerName)
	populate(objectMap, "identityReference", a.IdentityReference)
	populate(objectMap, "relativeMountPath", a.RelativeMountPath)
	populate(objectMap, "sasKey", a.SasKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureBlobFileSystemConfiguration.
func (a *AzureBlobFileSystemConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
				err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "accountName":
				err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "blobfuseOptions":
				err = unpopulate(val, "BlobfuseOptions", &a.BlobfuseOptions)
			delete(rawMsg, key)
		case "containerName":
				err = unpopulate(val, "ContainerName", &a.ContainerName)
			delete(rawMsg, key)
		case "identityReference":
				err = unpopulate(val, "IdentityReference", &a.IdentityReference)
			delete(rawMsg, key)
		case "relativeMountPath":
				err = unpopulate(val, "RelativeMountPath", &a.RelativeMountPath)
			delete(rawMsg, key)
		case "sasKey":
				err = unpopulate(val, "SasKey", &a.SasKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AzureFileShareConfiguration.
func (a AzureFileShareConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "accountKey", a.AccountKey)
	populate(objectMap, "accountName", a.AccountName)
	populate(objectMap, "azureFileUrl", a.AzureFileURL)
	populate(objectMap, "mountOptions", a.MountOptions)
	populate(objectMap, "relativeMountPath", a.RelativeMountPath)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureFileShareConfiguration.
func (a *AzureFileShareConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", a, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accountKey":
				err = unpopulate(val, "AccountKey", &a.AccountKey)
			delete(rawMsg, key)
		case "accountName":
				err = unpopulate(val, "AccountName", &a.AccountName)
			delete(rawMsg, key)
		case "azureFileUrl":
				err = unpopulate(val, "AzureFileURL", &a.AzureFileURL)
			delete(rawMsg, key)
		case "mountOptions":
				err = unpopulate(val, "MountOptions", &a.MountOptions)
			delete(rawMsg, key)
		case "relativeMountPath":
				err = unpopulate(val, "RelativeMountPath", &a.RelativeMountPath)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", a, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchAccountListSupportedImagesResult.
func (b BatchAccountListSupportedImagesResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchAccountListSupportedImagesResult.
func (b *BatchAccountListSupportedImagesResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchApplication.
func (b BatchApplication) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "versions", b.Versions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchApplication.
func (b *BatchApplication) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "versions":
				err = unpopulate(val, "Versions", &b.Versions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchApplicationListResult.
func (b BatchApplicationListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchApplicationListResult.
func (b *BatchApplicationListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchApplicationPackageReference.
func (b BatchApplicationPackageReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationId", b.ApplicationID)
	populate(objectMap, "version", b.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchApplicationPackageReference.
func (b *BatchApplicationPackageReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationId":
				err = unpopulate(val, "ApplicationID", &b.ApplicationID)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &b.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchAutoPoolSpecification.
func (b BatchAutoPoolSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoPoolIdPrefix", b.AutoPoolIDPrefix)
	populate(objectMap, "keepAlive", b.KeepAlive)
	populate(objectMap, "pool", b.Pool)
	populate(objectMap, "poolLifetimeOption", b.PoolLifetimeOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchAutoPoolSpecification.
func (b *BatchAutoPoolSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoPoolIdPrefix":
				err = unpopulate(val, "AutoPoolIDPrefix", &b.AutoPoolIDPrefix)
			delete(rawMsg, key)
		case "keepAlive":
				err = unpopulate(val, "KeepAlive", &b.KeepAlive)
			delete(rawMsg, key)
		case "pool":
				err = unpopulate(val, "Pool", &b.Pool)
			delete(rawMsg, key)
		case "poolLifetimeOption":
				err = unpopulate(val, "PoolLifetimeOption", &b.PoolLifetimeOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchCertificate.
func (b BatchCertificate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "certificateFormat", b.CertificateFormat)
	populate(objectMap, "data", b.Data)
	populate(objectMap, "deleteCertificateError", b.DeleteCertificateError)
	populate(objectMap, "password", b.Password)
	populate(objectMap, "previousState", b.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", b.PreviousStateTransitionTime)
	populate(objectMap, "publicData", b.PublicData)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	populate(objectMap, "thumbprint", b.Thumbprint)
	populate(objectMap, "thumbprintAlgorithm", b.ThumbprintAlgorithm)
	populate(objectMap, "url", b.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchCertificate.
func (b *BatchCertificate) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "certificateFormat":
				err = unpopulate(val, "CertificateFormat", &b.CertificateFormat)
			delete(rawMsg, key)
		case "data":
				err = unpopulate(val, "Data", &b.Data)
			delete(rawMsg, key)
		case "deleteCertificateError":
				err = unpopulate(val, "DeleteCertificateError", &b.DeleteCertificateError)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &b.Password)
			delete(rawMsg, key)
		case "previousState":
				err = unpopulate(val, "PreviousState", &b.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &b.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "publicData":
				err = unpopulate(val, "PublicData", &b.PublicData)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		case "thumbprint":
				err = unpopulate(val, "Thumbprint", &b.Thumbprint)
			delete(rawMsg, key)
		case "thumbprintAlgorithm":
				err = unpopulate(val, "ThumbprintAlgorithm", &b.ThumbprintAlgorithm)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchCertificateListResult.
func (b BatchCertificateListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchCertificateListResult.
func (b *BatchCertificateListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchCertificateReference.
func (b BatchCertificateReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "storeLocation", b.StoreLocation)
	populate(objectMap, "storeName", b.StoreName)
	populate(objectMap, "thumbprint", b.Thumbprint)
	populate(objectMap, "thumbprintAlgorithm", b.ThumbprintAlgorithm)
	populate(objectMap, "visibility", b.Visibility)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchCertificateReference.
func (b *BatchCertificateReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storeLocation":
				err = unpopulate(val, "StoreLocation", &b.StoreLocation)
			delete(rawMsg, key)
		case "storeName":
				err = unpopulate(val, "StoreName", &b.StoreName)
			delete(rawMsg, key)
		case "thumbprint":
				err = unpopulate(val, "Thumbprint", &b.Thumbprint)
			delete(rawMsg, key)
		case "thumbprintAlgorithm":
				err = unpopulate(val, "ThumbprintAlgorithm", &b.ThumbprintAlgorithm)
			delete(rawMsg, key)
		case "visibility":
				err = unpopulate(val, "Visibility", &b.Visibility)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchError.
func (b BatchError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", b.Code)
	populate(objectMap, "message", b.Message)
	populate(objectMap, "values", b.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchError.
func (b *BatchError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &b.Code)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &b.Message)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &b.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchErrorDetail.
func (b BatchErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "key", b.Key)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchErrorDetail.
func (b *BatchErrorDetail) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "key":
				err = unpopulate(val, "Key", &b.Key)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchErrorMessage.
func (b BatchErrorMessage) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "lang", b.Lang)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchErrorMessage.
func (b *BatchErrorMessage) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lang":
				err = unpopulate(val, "Lang", &b.Lang)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJob.
func (b BatchJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", b.AllowTaskPreemption)
	populate(objectMap, "commonEnvironmentSettings", b.CommonEnvironmentSettings)
	populate(objectMap, "constraints", b.Constraints)
	populateDateTimeRFC3339(objectMap, "creationTime", b.CreationTime)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "eTag", b.ETag)
	populate(objectMap, "executionInfo", b.ExecutionInfo)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "jobManagerTask", b.JobManagerTask)
	populate(objectMap, "jobPreparationTask", b.JobPreparationTask)
	populate(objectMap, "jobReleaseTask", b.JobReleaseTask)
	populateDateTimeRFC3339(objectMap, "lastModified", b.LastModified)
	populate(objectMap, "maxParallelTasks", b.MaxParallelTasks)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "networkConfiguration", b.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", b.OnAllTasksComplete)
	populate(objectMap, "onTaskFailure", b.OnTaskFailure)
	populate(objectMap, "poolInfo", b.PoolInfo)
	populate(objectMap, "previousState", b.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", b.PreviousStateTransitionTime)
	populate(objectMap, "priority", b.Priority)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	populate(objectMap, "stats", b.Stats)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "usesTaskDependencies", b.UsesTaskDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJob.
func (b *BatchJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
				err = unpopulate(val, "AllowTaskPreemption", &b.AllowTaskPreemption)
			delete(rawMsg, key)
		case "commonEnvironmentSettings":
				err = unpopulate(val, "CommonEnvironmentSettings", &b.CommonEnvironmentSettings)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &b.CreationTime)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "eTag":
				err = unpopulate(val, "ETag", &b.ETag)
			delete(rawMsg, key)
		case "executionInfo":
				err = unpopulate(val, "ExecutionInfo", &b.ExecutionInfo)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "jobManagerTask":
				err = unpopulate(val, "JobManagerTask", &b.JobManagerTask)
			delete(rawMsg, key)
		case "jobPreparationTask":
				err = unpopulate(val, "JobPreparationTask", &b.JobPreparationTask)
			delete(rawMsg, key)
		case "jobReleaseTask":
				err = unpopulate(val, "JobReleaseTask", &b.JobReleaseTask)
			delete(rawMsg, key)
		case "lastModified":
				err = unpopulateDateTimeRFC3339(val, "LastModified", &b.LastModified)
			delete(rawMsg, key)
		case "maxParallelTasks":
				err = unpopulate(val, "MaxParallelTasks", &b.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
				err = unpopulate(val, "NetworkConfiguration", &b.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
				err = unpopulate(val, "OnAllTasksComplete", &b.OnAllTasksComplete)
			delete(rawMsg, key)
		case "onTaskFailure":
				err = unpopulate(val, "OnTaskFailure", &b.OnTaskFailure)
			delete(rawMsg, key)
		case "poolInfo":
				err = unpopulate(val, "PoolInfo", &b.PoolInfo)
			delete(rawMsg, key)
		case "previousState":
				err = unpopulate(val, "PreviousState", &b.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &b.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &b.Priority)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
				err = unpopulate(val, "Stats", &b.Stats)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "usesTaskDependencies":
				err = unpopulate(val, "UsesTaskDependencies", &b.UsesTaskDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobConstraints.
func (b BatchJobConstraints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTaskRetryCount", b.MaxTaskRetryCount)
	populate(objectMap, "maxWallClockTime", b.MaxWallClockTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobConstraints.
func (b *BatchJobConstraints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTaskRetryCount":
				err = unpopulate(val, "MaxTaskRetryCount", &b.MaxTaskRetryCount)
			delete(rawMsg, key)
		case "maxWallClockTime":
				err = unpopulate(val, "MaxWallClockTime", &b.MaxWallClockTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobCreateContent.
func (b BatchJobCreateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", b.AllowTaskPreemption)
	populate(objectMap, "commonEnvironmentSettings", b.CommonEnvironmentSettings)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "jobManagerTask", b.JobManagerTask)
	populate(objectMap, "jobPreparationTask", b.JobPreparationTask)
	populate(objectMap, "jobReleaseTask", b.JobReleaseTask)
	populate(objectMap, "maxParallelTasks", b.MaxParallelTasks)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "networkConfiguration", b.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", b.OnAllTasksComplete)
	populate(objectMap, "onTaskFailure", b.OnTaskFailure)
	populate(objectMap, "poolInfo", b.PoolInfo)
	populate(objectMap, "priority", b.Priority)
	populate(objectMap, "usesTaskDependencies", b.UsesTaskDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobCreateContent.
func (b *BatchJobCreateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
				err = unpopulate(val, "AllowTaskPreemption", &b.AllowTaskPreemption)
			delete(rawMsg, key)
		case "commonEnvironmentSettings":
				err = unpopulate(val, "CommonEnvironmentSettings", &b.CommonEnvironmentSettings)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "jobManagerTask":
				err = unpopulate(val, "JobManagerTask", &b.JobManagerTask)
			delete(rawMsg, key)
		case "jobPreparationTask":
				err = unpopulate(val, "JobPreparationTask", &b.JobPreparationTask)
			delete(rawMsg, key)
		case "jobReleaseTask":
				err = unpopulate(val, "JobReleaseTask", &b.JobReleaseTask)
			delete(rawMsg, key)
		case "maxParallelTasks":
				err = unpopulate(val, "MaxParallelTasks", &b.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
				err = unpopulate(val, "NetworkConfiguration", &b.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
				err = unpopulate(val, "OnAllTasksComplete", &b.OnAllTasksComplete)
			delete(rawMsg, key)
		case "onTaskFailure":
				err = unpopulate(val, "OnTaskFailure", &b.OnTaskFailure)
			delete(rawMsg, key)
		case "poolInfo":
				err = unpopulate(val, "PoolInfo", &b.PoolInfo)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &b.Priority)
			delete(rawMsg, key)
		case "usesTaskDependencies":
				err = unpopulate(val, "UsesTaskDependencies", &b.UsesTaskDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobDisableContent.
func (b BatchJobDisableContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "disableTasks", b.DisableTasks)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobDisableContent.
func (b *BatchJobDisableContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "disableTasks":
				err = unpopulate(val, "DisableTasks", &b.DisableTasks)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobExecutionInfo.
func (b BatchJobExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "poolId", b.PoolID)
	populate(objectMap, "schedulingError", b.SchedulingError)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "terminateReason", b.TerminationReason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobExecutionInfo.
func (b *BatchJobExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "poolId":
				err = unpopulate(val, "PoolID", &b.PoolID)
			delete(rawMsg, key)
		case "schedulingError":
				err = unpopulate(val, "SchedulingError", &b.SchedulingError)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "terminateReason":
				err = unpopulate(val, "TerminationReason", &b.TerminationReason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobListResult.
func (b BatchJobListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobListResult.
func (b *BatchJobListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobManagerTask.
func (b BatchJobManagerTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowLowPriorityNode", b.AllowLowPriorityNode)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "authenticationTokenSettings", b.AuthenticationTokenSettings)
	populate(objectMap, "commandLine", b.CommandLine)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "containerSettings", b.ContainerSettings)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "environmentSettings", b.EnvironmentSettings)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "killJobOnCompletion", b.KillJobOnCompletion)
	populate(objectMap, "outputFiles", b.OutputFiles)
	populate(objectMap, "requiredSlots", b.RequiredSlots)
	populate(objectMap, "resourceFiles", b.ResourceFiles)
	populate(objectMap, "runExclusive", b.RunExclusive)
	populate(objectMap, "userIdentity", b.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobManagerTask.
func (b *BatchJobManagerTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowLowPriorityNode":
				err = unpopulate(val, "AllowLowPriorityNode", &b.AllowLowPriorityNode)
			delete(rawMsg, key)
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "authenticationTokenSettings":
				err = unpopulate(val, "AuthenticationTokenSettings", &b.AuthenticationTokenSettings)
			delete(rawMsg, key)
		case "commandLine":
				err = unpopulate(val, "CommandLine", &b.CommandLine)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
				err = unpopulate(val, "ContainerSettings", &b.ContainerSettings)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "environmentSettings":
				err = unpopulate(val, "EnvironmentSettings", &b.EnvironmentSettings)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "killJobOnCompletion":
				err = unpopulate(val, "KillJobOnCompletion", &b.KillJobOnCompletion)
			delete(rawMsg, key)
		case "outputFiles":
				err = unpopulate(val, "OutputFiles", &b.OutputFiles)
			delete(rawMsg, key)
		case "requiredSlots":
				err = unpopulate(val, "RequiredSlots", &b.RequiredSlots)
			delete(rawMsg, key)
		case "resourceFiles":
				err = unpopulate(val, "ResourceFiles", &b.ResourceFiles)
			delete(rawMsg, key)
		case "runExclusive":
				err = unpopulate(val, "RunExclusive", &b.RunExclusive)
			delete(rawMsg, key)
		case "userIdentity":
				err = unpopulate(val, "UserIdentity", &b.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobNetworkConfiguration.
func (b BatchJobNetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "subnetId", b.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobNetworkConfiguration.
func (b *BatchJobNetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "subnetId":
				err = unpopulate(val, "SubnetID", &b.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobPreparationAndReleaseTaskStatus.
func (b BatchJobPreparationAndReleaseTaskStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobPreparationTaskExecutionInfo", b.JobPreparationTaskExecutionInfo)
	populate(objectMap, "jobReleaseTaskExecutionInfo", b.JobReleaseTaskExecutionInfo)
	populate(objectMap, "nodeId", b.NodeID)
	populate(objectMap, "nodeUrl", b.NodeURL)
	populate(objectMap, "poolId", b.PoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobPreparationAndReleaseTaskStatus.
func (b *BatchJobPreparationAndReleaseTaskStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobPreparationTaskExecutionInfo":
				err = unpopulate(val, "JobPreparationTaskExecutionInfo", &b.JobPreparationTaskExecutionInfo)
			delete(rawMsg, key)
		case "jobReleaseTaskExecutionInfo":
				err = unpopulate(val, "JobReleaseTaskExecutionInfo", &b.JobReleaseTaskExecutionInfo)
			delete(rawMsg, key)
		case "nodeId":
				err = unpopulate(val, "NodeID", &b.NodeID)
			delete(rawMsg, key)
		case "nodeUrl":
				err = unpopulate(val, "NodeURL", &b.NodeURL)
			delete(rawMsg, key)
		case "poolId":
				err = unpopulate(val, "PoolID", &b.PoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobPreparationAndReleaseTaskStatusListResult.
func (b BatchJobPreparationAndReleaseTaskStatusListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobPreparationAndReleaseTaskStatusListResult.
func (b *BatchJobPreparationAndReleaseTaskStatusListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobPreparationTask.
func (b BatchJobPreparationTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commandLine", b.CommandLine)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "containerSettings", b.ContainerSettings)
	populate(objectMap, "environmentSettings", b.EnvironmentSettings)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "rerunOnNodeRebootAfterSuccess", b.RerunOnNodeRebootAfterSuccess)
	populate(objectMap, "resourceFiles", b.ResourceFiles)
	populate(objectMap, "userIdentity", b.UserIdentity)
	populate(objectMap, "waitForSuccess", b.WaitForSuccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobPreparationTask.
func (b *BatchJobPreparationTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandLine":
				err = unpopulate(val, "CommandLine", &b.CommandLine)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
				err = unpopulate(val, "ContainerSettings", &b.ContainerSettings)
			delete(rawMsg, key)
		case "environmentSettings":
				err = unpopulate(val, "EnvironmentSettings", &b.EnvironmentSettings)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "rerunOnNodeRebootAfterSuccess":
				err = unpopulate(val, "RerunOnNodeRebootAfterSuccess", &b.RerunOnNodeRebootAfterSuccess)
			delete(rawMsg, key)
		case "resourceFiles":
				err = unpopulate(val, "ResourceFiles", &b.ResourceFiles)
			delete(rawMsg, key)
		case "userIdentity":
				err = unpopulate(val, "UserIdentity", &b.UserIdentity)
			delete(rawMsg, key)
		case "waitForSuccess":
				err = unpopulate(val, "WaitForSuccess", &b.WaitForSuccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobPreparationTaskExecutionInfo.
func (b BatchJobPreparationTaskExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", b.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "exitCode", b.ExitCode)
	populate(objectMap, "failureInfo", b.FailureInfo)
	populateDateTimeRFC3339(objectMap, "lastRetryTime", b.LastRetryTime)
	populate(objectMap, "result", b.Result)
	populate(objectMap, "retryCount", b.RetryCount)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "state", b.State)
	populate(objectMap, "taskRootDirectory", b.TaskRootDirectory)
	populate(objectMap, "taskRootDirectoryUrl", b.TaskRootDirectoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobPreparationTaskExecutionInfo.
func (b *BatchJobPreparationTaskExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
				err = unpopulate(val, "ContainerInfo", &b.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "exitCode":
				err = unpopulate(val, "ExitCode", &b.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
				err = unpopulate(val, "FailureInfo", &b.FailureInfo)
			delete(rawMsg, key)
		case "lastRetryTime":
				err = unpopulateDateTimeRFC3339(val, "LastRetryTime", &b.LastRetryTime)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &b.Result)
			delete(rawMsg, key)
		case "retryCount":
				err = unpopulate(val, "RetryCount", &b.RetryCount)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "taskRootDirectory":
				err = unpopulate(val, "TaskRootDirectory", &b.TaskRootDirectory)
			delete(rawMsg, key)
		case "taskRootDirectoryUrl":
				err = unpopulate(val, "TaskRootDirectoryURL", &b.TaskRootDirectoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobReleaseTask.
func (b BatchJobReleaseTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commandLine", b.CommandLine)
	populate(objectMap, "containerSettings", b.ContainerSettings)
	populate(objectMap, "environmentSettings", b.EnvironmentSettings)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "maxWallClockTime", b.MaxWallClockTime)
	populate(objectMap, "resourceFiles", b.ResourceFiles)
	populate(objectMap, "retentionTime", b.RetentionTime)
	populate(objectMap, "userIdentity", b.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobReleaseTask.
func (b *BatchJobReleaseTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandLine":
				err = unpopulate(val, "CommandLine", &b.CommandLine)
			delete(rawMsg, key)
		case "containerSettings":
				err = unpopulate(val, "ContainerSettings", &b.ContainerSettings)
			delete(rawMsg, key)
		case "environmentSettings":
				err = unpopulate(val, "EnvironmentSettings", &b.EnvironmentSettings)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "maxWallClockTime":
				err = unpopulate(val, "MaxWallClockTime", &b.MaxWallClockTime)
			delete(rawMsg, key)
		case "resourceFiles":
				err = unpopulate(val, "ResourceFiles", &b.ResourceFiles)
			delete(rawMsg, key)
		case "retentionTime":
				err = unpopulate(val, "RetentionTime", &b.RetentionTime)
			delete(rawMsg, key)
		case "userIdentity":
				err = unpopulate(val, "UserIdentity", &b.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobReleaseTaskExecutionInfo.
func (b BatchJobReleaseTaskExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", b.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "exitCode", b.ExitCode)
	populate(objectMap, "failureInfo", b.FailureInfo)
	populate(objectMap, "result", b.Result)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "state", b.State)
	populate(objectMap, "taskRootDirectory", b.TaskRootDirectory)
	populate(objectMap, "taskRootDirectoryUrl", b.TaskRootDirectoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobReleaseTaskExecutionInfo.
func (b *BatchJobReleaseTaskExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
				err = unpopulate(val, "ContainerInfo", &b.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "exitCode":
				err = unpopulate(val, "ExitCode", &b.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
				err = unpopulate(val, "FailureInfo", &b.FailureInfo)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &b.Result)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "taskRootDirectory":
				err = unpopulate(val, "TaskRootDirectory", &b.TaskRootDirectory)
			delete(rawMsg, key)
		case "taskRootDirectoryUrl":
				err = unpopulate(val, "TaskRootDirectoryURL", &b.TaskRootDirectoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobSchedule.
func (b BatchJobSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "creationTime", b.CreationTime)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "eTag", b.ETag)
	populate(objectMap, "executionInfo", b.ExecutionInfo)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "jobSpecification", b.JobSpecification)
	populateDateTimeRFC3339(objectMap, "lastModified", b.LastModified)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "previousState", b.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", b.PreviousStateTransitionTime)
	populate(objectMap, "schedule", b.Schedule)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	populate(objectMap, "stats", b.Stats)
	populate(objectMap, "url", b.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobSchedule.
func (b *BatchJobSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &b.CreationTime)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "eTag":
				err = unpopulate(val, "ETag", &b.ETag)
			delete(rawMsg, key)
		case "executionInfo":
				err = unpopulate(val, "ExecutionInfo", &b.ExecutionInfo)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "jobSpecification":
				err = unpopulate(val, "JobSpecification", &b.JobSpecification)
			delete(rawMsg, key)
		case "lastModified":
				err = unpopulateDateTimeRFC3339(val, "LastModified", &b.LastModified)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "previousState":
				err = unpopulate(val, "PreviousState", &b.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &b.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "schedule":
				err = unpopulate(val, "Schedule", &b.Schedule)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
				err = unpopulate(val, "Stats", &b.Stats)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobScheduleConfiguration.
func (b BatchJobScheduleConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "doNotRunAfter", b.DoNotRunAfter)
	populateDateTimeRFC3339(objectMap, "doNotRunUntil", b.DoNotRunUntil)
	populate(objectMap, "recurrenceInterval", b.RecurrenceInterval)
	populate(objectMap, "startWindow", b.StartWindow)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobScheduleConfiguration.
func (b *BatchJobScheduleConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "doNotRunAfter":
				err = unpopulateDateTimeRFC3339(val, "DoNotRunAfter", &b.DoNotRunAfter)
			delete(rawMsg, key)
		case "doNotRunUntil":
				err = unpopulateDateTimeRFC3339(val, "DoNotRunUntil", &b.DoNotRunUntil)
			delete(rawMsg, key)
		case "recurrenceInterval":
				err = unpopulate(val, "RecurrenceInterval", &b.RecurrenceInterval)
			delete(rawMsg, key)
		case "startWindow":
				err = unpopulate(val, "StartWindow", &b.StartWindow)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobScheduleCreateContent.
func (b BatchJobScheduleCreateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "jobSpecification", b.JobSpecification)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "schedule", b.Schedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobScheduleCreateContent.
func (b *BatchJobScheduleCreateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "jobSpecification":
				err = unpopulate(val, "JobSpecification", &b.JobSpecification)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "schedule":
				err = unpopulate(val, "Schedule", &b.Schedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobScheduleExecutionInfo.
func (b BatchJobScheduleExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populateDateTimeRFC3339(objectMap, "nextRunTime", b.NextRunTime)
	populate(objectMap, "recentJob", b.RecentJob)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobScheduleExecutionInfo.
func (b *BatchJobScheduleExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "nextRunTime":
				err = unpopulateDateTimeRFC3339(val, "NextRunTime", &b.NextRunTime)
			delete(rawMsg, key)
		case "recentJob":
				err = unpopulate(val, "RecentJob", &b.RecentJob)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobScheduleListResult.
func (b BatchJobScheduleListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobScheduleListResult.
func (b *BatchJobScheduleListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobScheduleStatistics.
func (b BatchJobScheduleStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kernelCPUTime", b.KernelCPUTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populate(objectMap, "numFailedTasks", b.NumFailedTasks)
	populate(objectMap, "numSucceededTasks", b.NumSucceededTasks)
	populate(objectMap, "numTaskRetries", b.NumTaskRetries)
	populate(objectMap, "readIOGiB", b.ReadIOGiB)
	populate(objectMap, "readIOps", b.ReadIOps)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "userCPUTime", b.UserCPUTime)
	populate(objectMap, "waitTime", b.WaitTime)
	populate(objectMap, "wallClockTime", b.WallClockTime)
	populate(objectMap, "writeIOGiB", b.WriteIOGiB)
	populate(objectMap, "writeIOps", b.WriteIOps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobScheduleStatistics.
func (b *BatchJobScheduleStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelCPUTime":
				err = unpopulate(val, "KernelCPUTime", &b.KernelCPUTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "numFailedTasks":
				err = unpopulate(val, "NumFailedTasks", &b.NumFailedTasks)
			delete(rawMsg, key)
		case "numSucceededTasks":
				err = unpopulate(val, "NumSucceededTasks", &b.NumSucceededTasks)
			delete(rawMsg, key)
		case "numTaskRetries":
				err = unpopulate(val, "NumTaskRetries", &b.NumTaskRetries)
			delete(rawMsg, key)
		case "readIOGiB":
				err = unpopulate(val, "ReadIOGiB", &b.ReadIOGiB)
			delete(rawMsg, key)
		case "readIOps":
				err = unpopulate(val, "ReadIOps", &b.ReadIOps)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "userCPUTime":
				err = unpopulate(val, "UserCPUTime", &b.UserCPUTime)
			delete(rawMsg, key)
		case "waitTime":
				err = unpopulate(val, "WaitTime", &b.WaitTime)
			delete(rawMsg, key)
		case "wallClockTime":
				err = unpopulate(val, "WallClockTime", &b.WallClockTime)
			delete(rawMsg, key)
		case "writeIOGiB":
				err = unpopulate(val, "WriteIOGiB", &b.WriteIOGiB)
			delete(rawMsg, key)
		case "writeIOps":
				err = unpopulate(val, "WriteIOps", &b.WriteIOps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobScheduleUpdateContent.
func (b BatchJobScheduleUpdateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "jobSpecification", b.JobSpecification)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "schedule", b.Schedule)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobScheduleUpdateContent.
func (b *BatchJobScheduleUpdateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobSpecification":
				err = unpopulate(val, "JobSpecification", &b.JobSpecification)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "schedule":
				err = unpopulate(val, "Schedule", &b.Schedule)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobSchedulingError.
func (b BatchJobSchedulingError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", b.Category)
	populate(objectMap, "code", b.Code)
	populate(objectMap, "details", b.Details)
	populate(objectMap, "message", b.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobSchedulingError.
func (b *BatchJobSchedulingError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
				err = unpopulate(val, "Category", &b.Category)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &b.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &b.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &b.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobSpecification.
func (b BatchJobSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", b.AllowTaskPreemption)
	populate(objectMap, "commonEnvironmentSettings", b.CommonEnvironmentSettings)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "jobManagerTask", b.JobManagerTask)
	populate(objectMap, "jobPreparationTask", b.JobPreparationTask)
	populate(objectMap, "jobReleaseTask", b.JobReleaseTask)
	populate(objectMap, "maxParallelTasks", b.MaxParallelTasks)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "networkConfiguration", b.NetworkConfiguration)
	populate(objectMap, "onAllTasksComplete", b.OnAllTasksComplete)
	populate(objectMap, "onTaskFailure", b.OnTaskFailure)
	populate(objectMap, "poolInfo", b.PoolInfo)
	populate(objectMap, "priority", b.Priority)
	populate(objectMap, "usesTaskDependencies", b.UsesTaskDependencies)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobSpecification.
func (b *BatchJobSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
				err = unpopulate(val, "AllowTaskPreemption", &b.AllowTaskPreemption)
			delete(rawMsg, key)
		case "commonEnvironmentSettings":
				err = unpopulate(val, "CommonEnvironmentSettings", &b.CommonEnvironmentSettings)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "jobManagerTask":
				err = unpopulate(val, "JobManagerTask", &b.JobManagerTask)
			delete(rawMsg, key)
		case "jobPreparationTask":
				err = unpopulate(val, "JobPreparationTask", &b.JobPreparationTask)
			delete(rawMsg, key)
		case "jobReleaseTask":
				err = unpopulate(val, "JobReleaseTask", &b.JobReleaseTask)
			delete(rawMsg, key)
		case "maxParallelTasks":
				err = unpopulate(val, "MaxParallelTasks", &b.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "networkConfiguration":
				err = unpopulate(val, "NetworkConfiguration", &b.NetworkConfiguration)
			delete(rawMsg, key)
		case "onAllTasksComplete":
				err = unpopulate(val, "OnAllTasksComplete", &b.OnAllTasksComplete)
			delete(rawMsg, key)
		case "onTaskFailure":
				err = unpopulate(val, "OnTaskFailure", &b.OnTaskFailure)
			delete(rawMsg, key)
		case "poolInfo":
				err = unpopulate(val, "PoolInfo", &b.PoolInfo)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &b.Priority)
			delete(rawMsg, key)
		case "usesTaskDependencies":
				err = unpopulate(val, "UsesTaskDependencies", &b.UsesTaskDependencies)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobStatistics.
func (b BatchJobStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kernelCPUTime", b.KernelCPUTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populate(objectMap, "numFailedTasks", b.NumFailedTasks)
	populate(objectMap, "numSucceededTasks", b.NumSucceededTasks)
	populate(objectMap, "numTaskRetries", b.NumTaskRetries)
	populate(objectMap, "readIOGiB", b.ReadIOGiB)
	populate(objectMap, "readIOps", b.ReadIOps)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "userCPUTime", b.UserCPUTime)
	populate(objectMap, "waitTime", b.WaitTime)
	populate(objectMap, "wallClockTime", b.WallClockTime)
	populate(objectMap, "writeIOGiB", b.WriteIOGiB)
	populate(objectMap, "writeIOps", b.WriteIOps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobStatistics.
func (b *BatchJobStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelCPUTime":
				err = unpopulate(val, "KernelCPUTime", &b.KernelCPUTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "numFailedTasks":
				err = unpopulate(val, "NumFailedTasks", &b.NumFailedTasks)
			delete(rawMsg, key)
		case "numSucceededTasks":
				err = unpopulate(val, "NumSucceededTasks", &b.NumSucceededTasks)
			delete(rawMsg, key)
		case "numTaskRetries":
				err = unpopulate(val, "NumTaskRetries", &b.NumTaskRetries)
			delete(rawMsg, key)
		case "readIOGiB":
				err = unpopulate(val, "ReadIOGiB", &b.ReadIOGiB)
			delete(rawMsg, key)
		case "readIOps":
				err = unpopulate(val, "ReadIOps", &b.ReadIOps)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "userCPUTime":
				err = unpopulate(val, "UserCPUTime", &b.UserCPUTime)
			delete(rawMsg, key)
		case "waitTime":
				err = unpopulate(val, "WaitTime", &b.WaitTime)
			delete(rawMsg, key)
		case "wallClockTime":
				err = unpopulate(val, "WallClockTime", &b.WallClockTime)
			delete(rawMsg, key)
		case "writeIOGiB":
				err = unpopulate(val, "WriteIOGiB", &b.WriteIOGiB)
			delete(rawMsg, key)
		case "writeIOps":
				err = unpopulate(val, "WriteIOps", &b.WriteIOps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobTerminateContent.
func (b BatchJobTerminateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "terminateReason", b.TerminationReason)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobTerminateContent.
func (b *BatchJobTerminateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "terminateReason":
				err = unpopulate(val, "TerminationReason", &b.TerminationReason)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchJobUpdateContent.
func (b BatchJobUpdateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allowTaskPreemption", b.AllowTaskPreemption)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "maxParallelTasks", b.MaxParallelTasks)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "onAllTasksComplete", b.OnAllTasksComplete)
	populate(objectMap, "poolInfo", b.PoolInfo)
	populate(objectMap, "priority", b.Priority)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchJobUpdateContent.
func (b *BatchJobUpdateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allowTaskPreemption":
				err = unpopulate(val, "AllowTaskPreemption", &b.AllowTaskPreemption)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "maxParallelTasks":
				err = unpopulate(val, "MaxParallelTasks", &b.MaxParallelTasks)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "onAllTasksComplete":
				err = unpopulate(val, "OnAllTasksComplete", &b.OnAllTasksComplete)
			delete(rawMsg, key)
		case "poolInfo":
				err = unpopulate(val, "PoolInfo", &b.PoolInfo)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &b.Priority)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNode.
func (b BatchNode) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityId", b.AffinityID)
	populateDateTimeRFC3339(objectMap, "allocationTime", b.AllocationTime)
	populate(objectMap, "certificateReferences", b.CertificateReferences)
	populate(objectMap, "endpointConfiguration", b.EndpointConfiguration)
	populate(objectMap, "errors", b.Errors)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "ipAddress", b.IPAddress)
	populate(objectMap, "isDedicated", b.IsDedicated)
	populateDateTimeRFC3339(objectMap, "lastBootTime", b.LastBootTime)
	populate(objectMap, "nodeAgentInfo", b.NodeAgentInfo)
	populate(objectMap, "recentTasks", b.RecentTasks)
	populate(objectMap, "runningTaskSlotsCount", b.RunningTaskSlotsCount)
	populate(objectMap, "runningTasksCount", b.RunningTasksCount)
	populate(objectMap, "schedulingState", b.SchedulingState)
	populate(objectMap, "startTask", b.StartTask)
	populate(objectMap, "startTaskInfo", b.StartTaskInfo)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	populate(objectMap, "totalTasksRun", b.TotalTasksRun)
	populate(objectMap, "totalTasksSucceeded", b.TotalTasksSucceeded)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "vmSize", b.VMSize)
	populate(objectMap, "virtualMachineInfo", b.VirtualMachineInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNode.
func (b *BatchNode) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityId":
				err = unpopulate(val, "AffinityID", &b.AffinityID)
			delete(rawMsg, key)
		case "allocationTime":
				err = unpopulateDateTimeRFC3339(val, "AllocationTime", &b.AllocationTime)
			delete(rawMsg, key)
		case "certificateReferences":
				err = unpopulate(val, "CertificateReferences", &b.CertificateReferences)
			delete(rawMsg, key)
		case "endpointConfiguration":
				err = unpopulate(val, "EndpointConfiguration", &b.EndpointConfiguration)
			delete(rawMsg, key)
		case "errors":
				err = unpopulate(val, "Errors", &b.Errors)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "ipAddress":
				err = unpopulate(val, "IPAddress", &b.IPAddress)
			delete(rawMsg, key)
		case "isDedicated":
				err = unpopulate(val, "IsDedicated", &b.IsDedicated)
			delete(rawMsg, key)
		case "lastBootTime":
				err = unpopulateDateTimeRFC3339(val, "LastBootTime", &b.LastBootTime)
			delete(rawMsg, key)
		case "nodeAgentInfo":
				err = unpopulate(val, "NodeAgentInfo", &b.NodeAgentInfo)
			delete(rawMsg, key)
		case "recentTasks":
				err = unpopulate(val, "RecentTasks", &b.RecentTasks)
			delete(rawMsg, key)
		case "runningTaskSlotsCount":
				err = unpopulate(val, "RunningTaskSlotsCount", &b.RunningTaskSlotsCount)
			delete(rawMsg, key)
		case "runningTasksCount":
				err = unpopulate(val, "RunningTasksCount", &b.RunningTasksCount)
			delete(rawMsg, key)
		case "schedulingState":
				err = unpopulate(val, "SchedulingState", &b.SchedulingState)
			delete(rawMsg, key)
		case "startTask":
				err = unpopulate(val, "StartTask", &b.StartTask)
			delete(rawMsg, key)
		case "startTaskInfo":
				err = unpopulate(val, "StartTaskInfo", &b.StartTaskInfo)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		case "totalTasksRun":
				err = unpopulate(val, "TotalTasksRun", &b.TotalTasksRun)
			delete(rawMsg, key)
		case "totalTasksSucceeded":
				err = unpopulate(val, "TotalTasksSucceeded", &b.TotalTasksSucceeded)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &b.VMSize)
			delete(rawMsg, key)
		case "virtualMachineInfo":
				err = unpopulate(val, "VirtualMachineInfo", &b.VirtualMachineInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeAgentInfo.
func (b BatchNodeAgentInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populate(objectMap, "version", b.Version)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeAgentInfo.
func (b *BatchNodeAgentInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &b.Version)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeCounts.
func (b BatchNodeCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "creating", b.Creating)
	populate(objectMap, "idle", b.Idle)
	populate(objectMap, "leavingPool", b.LeavingPool)
	populate(objectMap, "offline", b.Offline)
	populate(objectMap, "preempted", b.Preempted)
	populate(objectMap, "rebooting", b.Rebooting)
	populate(objectMap, "reimaging", b.Reimaging)
	populate(objectMap, "running", b.Running)
	populate(objectMap, "startTaskFailed", b.StartTaskFailed)
	populate(objectMap, "starting", b.Starting)
	populate(objectMap, "total", b.Total)
	populate(objectMap, "unknown", b.Unknown)
	populate(objectMap, "unusable", b.Unusable)
	populate(objectMap, "upgradingOs", b.UpgradingOS)
	populate(objectMap, "waitingForStartTask", b.WaitingForStartTask)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeCounts.
func (b *BatchNodeCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creating":
				err = unpopulate(val, "Creating", &b.Creating)
			delete(rawMsg, key)
		case "idle":
				err = unpopulate(val, "Idle", &b.Idle)
			delete(rawMsg, key)
		case "leavingPool":
				err = unpopulate(val, "LeavingPool", &b.LeavingPool)
			delete(rawMsg, key)
		case "offline":
				err = unpopulate(val, "Offline", &b.Offline)
			delete(rawMsg, key)
		case "preempted":
				err = unpopulate(val, "Preempted", &b.Preempted)
			delete(rawMsg, key)
		case "rebooting":
				err = unpopulate(val, "Rebooting", &b.Rebooting)
			delete(rawMsg, key)
		case "reimaging":
				err = unpopulate(val, "Reimaging", &b.Reimaging)
			delete(rawMsg, key)
		case "running":
				err = unpopulate(val, "Running", &b.Running)
			delete(rawMsg, key)
		case "startTaskFailed":
				err = unpopulate(val, "StartTaskFailed", &b.StartTaskFailed)
			delete(rawMsg, key)
		case "starting":
				err = unpopulate(val, "Starting", &b.Starting)
			delete(rawMsg, key)
		case "total":
				err = unpopulate(val, "Total", &b.Total)
			delete(rawMsg, key)
		case "unknown":
				err = unpopulate(val, "Unknown", &b.Unknown)
			delete(rawMsg, key)
		case "unusable":
				err = unpopulate(val, "Unusable", &b.Unusable)
			delete(rawMsg, key)
		case "upgradingOs":
				err = unpopulate(val, "UpgradingOS", &b.UpgradingOS)
			delete(rawMsg, key)
		case "waitingForStartTask":
				err = unpopulate(val, "WaitingForStartTask", &b.WaitingForStartTask)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeDisableSchedulingContent.
func (b BatchNodeDisableSchedulingContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDisableSchedulingOption", b.NodeDisableSchedulingOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeDisableSchedulingContent.
func (b *BatchNodeDisableSchedulingContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDisableSchedulingOption":
				err = unpopulate(val, "NodeDisableSchedulingOption", &b.NodeDisableSchedulingOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeEndpointConfiguration.
func (b BatchNodeEndpointConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "inboundEndpoints", b.InboundEndpoints)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeEndpointConfiguration.
func (b *BatchNodeEndpointConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inboundEndpoints":
				err = unpopulate(val, "InboundEndpoints", &b.InboundEndpoints)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeError.
func (b BatchNodeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", b.Code)
	populate(objectMap, "errorDetails", b.ErrorDetails)
	populate(objectMap, "message", b.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeError.
func (b *BatchNodeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &b.Code)
			delete(rawMsg, key)
		case "errorDetails":
				err = unpopulate(val, "ErrorDetails", &b.ErrorDetails)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &b.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeFile.
func (b BatchNodeFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "isDirectory", b.IsDirectory)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "properties", b.Properties)
	populate(objectMap, "url", b.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeFile.
func (b *BatchNodeFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isDirectory":
				err = unpopulate(val, "IsDirectory", &b.IsDirectory)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, "Properties", &b.Properties)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeFileListResult.
func (b BatchNodeFileListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeFileListResult.
func (b *BatchNodeFileListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeIdentityReference.
func (b BatchNodeIdentityReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "resourceId", b.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeIdentityReference.
func (b *BatchNodeIdentityReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "resourceId":
				err = unpopulate(val, "ResourceID", &b.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeInfo.
func (b BatchNodeInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityId", b.AffinityID)
	populate(objectMap, "nodeId", b.NodeID)
	populate(objectMap, "nodeUrl", b.NodeURL)
	populate(objectMap, "poolId", b.PoolID)
	populate(objectMap, "taskRootDirectory", b.TaskRootDirectory)
	populate(objectMap, "taskRootDirectoryUrl", b.TaskRootDirectoryURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeInfo.
func (b *BatchNodeInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityId":
				err = unpopulate(val, "AffinityID", &b.AffinityID)
			delete(rawMsg, key)
		case "nodeId":
				err = unpopulate(val, "NodeID", &b.NodeID)
			delete(rawMsg, key)
		case "nodeUrl":
				err = unpopulate(val, "NodeURL", &b.NodeURL)
			delete(rawMsg, key)
		case "poolId":
				err = unpopulate(val, "PoolID", &b.PoolID)
			delete(rawMsg, key)
		case "taskRootDirectory":
				err = unpopulate(val, "TaskRootDirectory", &b.TaskRootDirectory)
			delete(rawMsg, key)
		case "taskRootDirectoryUrl":
				err = unpopulate(val, "TaskRootDirectoryURL", &b.TaskRootDirectoryURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeListResult.
func (b BatchNodeListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeListResult.
func (b *BatchNodeListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodePlacementConfiguration.
func (b BatchNodePlacementConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "policy", b.Policy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodePlacementConfiguration.
func (b *BatchNodePlacementConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "policy":
				err = unpopulate(val, "Policy", &b.Policy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeRebootContent.
func (b BatchNodeRebootContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeRebootOption", b.NodeRebootOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeRebootContent.
func (b *BatchNodeRebootContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeRebootOption":
				err = unpopulate(val, "NodeRebootOption", &b.NodeRebootOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeReimageContent.
func (b BatchNodeReimageContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeReimageOption", b.NodeReimageOption)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeReimageContent.
func (b *BatchNodeReimageContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeReimageOption":
				err = unpopulate(val, "NodeReimageOption", &b.NodeReimageOption)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeRemoteLoginSettings.
func (b BatchNodeRemoteLoginSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "remoteLoginIPAddress", b.RemoteLoginIPAddress)
	populate(objectMap, "remoteLoginPort", b.RemoteLoginPort)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeRemoteLoginSettings.
func (b *BatchNodeRemoteLoginSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "remoteLoginIPAddress":
				err = unpopulate(val, "RemoteLoginIPAddress", &b.RemoteLoginIPAddress)
			delete(rawMsg, key)
		case "remoteLoginPort":
				err = unpopulate(val, "RemoteLoginPort", &b.RemoteLoginPort)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeRemoveContent.
func (b BatchNodeRemoveContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDeallocationOption", b.NodeDeallocationOption)
	populate(objectMap, "nodeList", b.NodeList)
	populate(objectMap, "resizeTimeout", b.ResizeTimeout)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeRemoveContent.
func (b *BatchNodeRemoveContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDeallocationOption":
				err = unpopulate(val, "NodeDeallocationOption", &b.NodeDeallocationOption)
			delete(rawMsg, key)
		case "nodeList":
				err = unpopulate(val, "NodeList", &b.NodeList)
			delete(rawMsg, key)
		case "resizeTimeout":
				err = unpopulate(val, "ResizeTimeout", &b.ResizeTimeout)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeUserCreateContent.
func (b BatchNodeUserCreateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "expiryTime", b.ExpiryTime)
	populate(objectMap, "isAdmin", b.IsAdmin)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "password", b.Password)
	populate(objectMap, "sshPublicKey", b.SSHPublicKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeUserCreateContent.
func (b *BatchNodeUserCreateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
				err = unpopulateDateTimeRFC3339(val, "ExpiryTime", &b.ExpiryTime)
			delete(rawMsg, key)
		case "isAdmin":
				err = unpopulate(val, "IsAdmin", &b.IsAdmin)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &b.Name)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &b.Password)
			delete(rawMsg, key)
		case "sshPublicKey":
				err = unpopulate(val, "SSHPublicKey", &b.SSHPublicKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeUserUpdateContent.
func (b BatchNodeUserUpdateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "expiryTime", b.ExpiryTime)
	populate(objectMap, "password", b.Password)
	populate(objectMap, "sshPublicKey", b.SSHPublicKey)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeUserUpdateContent.
func (b *BatchNodeUserUpdateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "expiryTime":
				err = unpopulateDateTimeRFC3339(val, "ExpiryTime", &b.ExpiryTime)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &b.Password)
			delete(rawMsg, key)
		case "sshPublicKey":
				err = unpopulate(val, "SSHPublicKey", &b.SSHPublicKey)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeVMExtension.
func (b BatchNodeVMExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "instanceView", b.InstanceView)
	populate(objectMap, "provisioningState", b.ProvisioningState)
	populate(objectMap, "vmExtension", b.VMExtension)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeVMExtension.
func (b *BatchNodeVMExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "instanceView":
				err = unpopulate(val, "InstanceView", &b.InstanceView)
			delete(rawMsg, key)
		case "provisioningState":
				err = unpopulate(val, "ProvisioningState", &b.ProvisioningState)
			delete(rawMsg, key)
		case "vmExtension":
				err = unpopulate(val, "VMExtension", &b.VMExtension)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchNodeVMExtensionListResult.
func (b BatchNodeVMExtensionListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchNodeVMExtensionListResult.
func (b *BatchNodeVMExtensionListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPool.
func (b BatchPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "allocationState", b.AllocationState)
	populateDateTimeRFC3339(objectMap, "allocationStateTransitionTime", b.AllocationStateTransitionTime)
	populate(objectMap, "applicationLicenses", b.ApplicationLicenses)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "autoScaleEvaluationInterval", b.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", b.AutoScaleFormula)
	populate(objectMap, "autoScaleRun", b.AutoScaleRun)
	populate(objectMap, "certificateReferences", b.CertificateReferences)
	populate(objectMap, "cloudServiceConfiguration", b.CloudServiceConfiguration)
	populateDateTimeRFC3339(objectMap, "creationTime", b.CreationTime)
	populate(objectMap, "currentDedicatedNodes", b.CurrentDedicatedNodes)
	populate(objectMap, "currentLowPriorityNodes", b.CurrentLowPriorityNodes)
	populate(objectMap, "currentNodeCommunicationMode", b.CurrentNodeCommunicationMode)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "eTag", b.ETag)
	populate(objectMap, "enableAutoScale", b.EnableAutoScale)
	populate(objectMap, "enableInterNodeCommunication", b.EnableInterNodeCommunication)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "identity", b.Identity)
	populateDateTimeRFC3339(objectMap, "lastModified", b.LastModified)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "mountConfiguration", b.MountConfiguration)
	populate(objectMap, "networkConfiguration", b.NetworkConfiguration)
	populate(objectMap, "resizeErrors", b.ResizeErrors)
	populate(objectMap, "resizeTimeout", b.ResizeTimeout)
	populate(objectMap, "resourceTags", b.ResourceTags)
	populate(objectMap, "startTask", b.StartTask)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	populate(objectMap, "stats", b.Stats)
	populate(objectMap, "targetDedicatedNodes", b.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", b.TargetLowPriorityNodes)
	populate(objectMap, "targetNodeCommunicationMode", b.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", b.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", b.TaskSlotsPerNode)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "upgradePolicy", b.UpgradePolicy)
	populate(objectMap, "userAccounts", b.UserAccounts)
	populate(objectMap, "vmSize", b.VMSize)
	populate(objectMap, "virtualMachineConfiguration", b.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPool.
func (b *BatchPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "allocationState":
				err = unpopulate(val, "AllocationState", &b.AllocationState)
			delete(rawMsg, key)
		case "allocationStateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "AllocationStateTransitionTime", &b.AllocationStateTransitionTime)
			delete(rawMsg, key)
		case "applicationLicenses":
				err = unpopulate(val, "ApplicationLicenses", &b.ApplicationLicenses)
			delete(rawMsg, key)
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "autoScaleEvaluationInterval":
				err = unpopulate(val, "AutoScaleEvaluationInterval", &b.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
				err = unpopulate(val, "AutoScaleFormula", &b.AutoScaleFormula)
			delete(rawMsg, key)
		case "autoScaleRun":
				err = unpopulate(val, "AutoScaleRun", &b.AutoScaleRun)
			delete(rawMsg, key)
		case "certificateReferences":
				err = unpopulate(val, "CertificateReferences", &b.CertificateReferences)
			delete(rawMsg, key)
		case "cloudServiceConfiguration":
				err = unpopulate(val, "CloudServiceConfiguration", &b.CloudServiceConfiguration)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &b.CreationTime)
			delete(rawMsg, key)
		case "currentDedicatedNodes":
				err = unpopulate(val, "CurrentDedicatedNodes", &b.CurrentDedicatedNodes)
			delete(rawMsg, key)
		case "currentLowPriorityNodes":
				err = unpopulate(val, "CurrentLowPriorityNodes", &b.CurrentLowPriorityNodes)
			delete(rawMsg, key)
		case "currentNodeCommunicationMode":
				err = unpopulate(val, "CurrentNodeCommunicationMode", &b.CurrentNodeCommunicationMode)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "eTag":
				err = unpopulate(val, "ETag", &b.ETag)
			delete(rawMsg, key)
		case "enableAutoScale":
				err = unpopulate(val, "EnableAutoScale", &b.EnableAutoScale)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
				err = unpopulate(val, "EnableInterNodeCommunication", &b.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "identity":
				err = unpopulate(val, "Identity", &b.Identity)
			delete(rawMsg, key)
		case "lastModified":
				err = unpopulateDateTimeRFC3339(val, "LastModified", &b.LastModified)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
				err = unpopulate(val, "MountConfiguration", &b.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
				err = unpopulate(val, "NetworkConfiguration", &b.NetworkConfiguration)
			delete(rawMsg, key)
		case "resizeErrors":
				err = unpopulate(val, "ResizeErrors", &b.ResizeErrors)
			delete(rawMsg, key)
		case "resizeTimeout":
				err = unpopulate(val, "ResizeTimeout", &b.ResizeTimeout)
			delete(rawMsg, key)
		case "resourceTags":
				err = unpopulate(val, "ResourceTags", &b.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
				err = unpopulate(val, "StartTask", &b.StartTask)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
				err = unpopulate(val, "Stats", &b.Stats)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
				err = unpopulate(val, "TargetDedicatedNodes", &b.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
				err = unpopulate(val, "TargetLowPriorityNodes", &b.TargetLowPriorityNodes)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
				err = unpopulate(val, "TargetNodeCommunicationMode", &b.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
				err = unpopulate(val, "TaskSchedulingPolicy", &b.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
				err = unpopulate(val, "TaskSlotsPerNode", &b.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "upgradePolicy":
				err = unpopulate(val, "UpgradePolicy", &b.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
				err = unpopulate(val, "UserAccounts", &b.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &b.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
				err = unpopulate(val, "VirtualMachineConfiguration", &b.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolCreateContent.
func (b BatchPoolCreateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationLicenses", b.ApplicationLicenses)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "autoScaleEvaluationInterval", b.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", b.AutoScaleFormula)
	populate(objectMap, "certificateReferences", b.CertificateReferences)
	populate(objectMap, "cloudServiceConfiguration", b.CloudServiceConfiguration)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "enableAutoScale", b.EnableAutoScale)
	populate(objectMap, "enableInterNodeCommunication", b.EnableInterNodeCommunication)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "mountConfiguration", b.MountConfiguration)
	populate(objectMap, "networkConfiguration", b.NetworkConfiguration)
	populate(objectMap, "resizeTimeout", b.ResizeTimeout)
	populate(objectMap, "resourceTags", b.ResourceTags)
	populate(objectMap, "startTask", b.StartTask)
	populate(objectMap, "targetDedicatedNodes", b.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", b.TargetLowPriorityNodes)
	populate(objectMap, "targetNodeCommunicationMode", b.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", b.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", b.TaskSlotsPerNode)
	populate(objectMap, "upgradePolicy", b.UpgradePolicy)
	populate(objectMap, "userAccounts", b.UserAccounts)
	populate(objectMap, "vmSize", b.VMSize)
	populate(objectMap, "virtualMachineConfiguration", b.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolCreateContent.
func (b *BatchPoolCreateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationLicenses":
				err = unpopulate(val, "ApplicationLicenses", &b.ApplicationLicenses)
			delete(rawMsg, key)
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "autoScaleEvaluationInterval":
				err = unpopulate(val, "AutoScaleEvaluationInterval", &b.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
				err = unpopulate(val, "AutoScaleFormula", &b.AutoScaleFormula)
			delete(rawMsg, key)
		case "certificateReferences":
				err = unpopulate(val, "CertificateReferences", &b.CertificateReferences)
			delete(rawMsg, key)
		case "cloudServiceConfiguration":
				err = unpopulate(val, "CloudServiceConfiguration", &b.CloudServiceConfiguration)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "enableAutoScale":
				err = unpopulate(val, "EnableAutoScale", &b.EnableAutoScale)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
				err = unpopulate(val, "EnableInterNodeCommunication", &b.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
				err = unpopulate(val, "MountConfiguration", &b.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
				err = unpopulate(val, "NetworkConfiguration", &b.NetworkConfiguration)
			delete(rawMsg, key)
		case "resizeTimeout":
				err = unpopulate(val, "ResizeTimeout", &b.ResizeTimeout)
			delete(rawMsg, key)
		case "resourceTags":
				err = unpopulate(val, "ResourceTags", &b.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
				err = unpopulate(val, "StartTask", &b.StartTask)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
				err = unpopulate(val, "TargetDedicatedNodes", &b.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
				err = unpopulate(val, "TargetLowPriorityNodes", &b.TargetLowPriorityNodes)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
				err = unpopulate(val, "TargetNodeCommunicationMode", &b.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
				err = unpopulate(val, "TaskSchedulingPolicy", &b.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
				err = unpopulate(val, "TaskSlotsPerNode", &b.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "upgradePolicy":
				err = unpopulate(val, "UpgradePolicy", &b.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
				err = unpopulate(val, "UserAccounts", &b.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &b.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
				err = unpopulate(val, "VirtualMachineConfiguration", &b.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolEnableAutoScaleContent.
func (b BatchPoolEnableAutoScaleContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoScaleEvaluationInterval", b.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", b.AutoScaleFormula)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolEnableAutoScaleContent.
func (b *BatchPoolEnableAutoScaleContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoScaleEvaluationInterval":
				err = unpopulate(val, "AutoScaleEvaluationInterval", &b.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
				err = unpopulate(val, "AutoScaleFormula", &b.AutoScaleFormula)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolEndpointConfiguration.
func (b BatchPoolEndpointConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "inboundNATPools", b.InboundNatPools)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolEndpointConfiguration.
func (b *BatchPoolEndpointConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inboundNATPools":
				err = unpopulate(val, "InboundNatPools", &b.InboundNatPools)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolEvaluateAutoScaleContent.
func (b BatchPoolEvaluateAutoScaleContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoScaleFormula", b.AutoScaleFormula)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolEvaluateAutoScaleContent.
func (b *BatchPoolEvaluateAutoScaleContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoScaleFormula":
				err = unpopulate(val, "AutoScaleFormula", &b.AutoScaleFormula)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolIdentity.
func (b BatchPoolIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "type", b.Type)
	populate(objectMap, "userAssignedIdentities", b.UserAssignedIdentities)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolIdentity.
func (b *BatchPoolIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "type":
				err = unpopulate(val, "Type", &b.Type)
			delete(rawMsg, key)
		case "userAssignedIdentities":
				err = unpopulate(val, "UserAssignedIdentities", &b.UserAssignedIdentities)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolInfo.
func (b BatchPoolInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoPoolSpecification", b.AutoPoolSpecification)
	populate(objectMap, "poolId", b.PoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolInfo.
func (b *BatchPoolInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoPoolSpecification":
				err = unpopulate(val, "AutoPoolSpecification", &b.AutoPoolSpecification)
			delete(rawMsg, key)
		case "poolId":
				err = unpopulate(val, "PoolID", &b.PoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolListResult.
func (b BatchPoolListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolListResult.
func (b *BatchPoolListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolListUsageMetricsResult.
func (b BatchPoolListUsageMetricsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolListUsageMetricsResult.
func (b *BatchPoolListUsageMetricsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolNodeCounts.
func (b BatchPoolNodeCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dedicated", b.Dedicated)
	populate(objectMap, "lowPriority", b.LowPriority)
	populate(objectMap, "poolId", b.PoolID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolNodeCounts.
func (b *BatchPoolNodeCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dedicated":
				err = unpopulate(val, "Dedicated", &b.Dedicated)
			delete(rawMsg, key)
		case "lowPriority":
				err = unpopulate(val, "LowPriority", &b.LowPriority)
			delete(rawMsg, key)
		case "poolId":
				err = unpopulate(val, "PoolID", &b.PoolID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolNodeCountsListResult.
func (b BatchPoolNodeCountsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolNodeCountsListResult.
func (b *BatchPoolNodeCountsListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolReplaceContent.
func (b BatchPoolReplaceContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "certificateReferences", b.CertificateReferences)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "startTask", b.StartTask)
	populate(objectMap, "targetNodeCommunicationMode", b.TargetNodeCommunicationMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolReplaceContent.
func (b *BatchPoolReplaceContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "certificateReferences":
				err = unpopulate(val, "CertificateReferences", &b.CertificateReferences)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "startTask":
				err = unpopulate(val, "StartTask", &b.StartTask)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
				err = unpopulate(val, "TargetNodeCommunicationMode", &b.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolResizeContent.
func (b BatchPoolResizeContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeDeallocationOption", b.NodeDeallocationOption)
	populate(objectMap, "resizeTimeout", b.ResizeTimeout)
	populate(objectMap, "targetDedicatedNodes", b.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", b.TargetLowPriorityNodes)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolResizeContent.
func (b *BatchPoolResizeContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeDeallocationOption":
				err = unpopulate(val, "NodeDeallocationOption", &b.NodeDeallocationOption)
			delete(rawMsg, key)
		case "resizeTimeout":
				err = unpopulate(val, "ResizeTimeout", &b.ResizeTimeout)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
				err = unpopulate(val, "TargetDedicatedNodes", &b.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
				err = unpopulate(val, "TargetLowPriorityNodes", &b.TargetLowPriorityNodes)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolResourceStatistics.
func (b BatchPoolResourceStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "avgCPUPercentage", b.AvgCPUPercentage)
	populate(objectMap, "avgDiskGiB", b.AvgDiskGiB)
	populate(objectMap, "avgMemoryGiB", b.AvgMemoryGiB)
	populate(objectMap, "diskReadGiB", b.DiskReadGiB)
	populate(objectMap, "diskReadIOps", b.DiskReadIOps)
	populate(objectMap, "diskWriteGiB", b.DiskWriteGiB)
	populate(objectMap, "diskWriteIOps", b.DiskWriteIOps)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populate(objectMap, "networkReadGiB", b.NetworkReadGiB)
	populate(objectMap, "networkWriteGiB", b.NetworkWriteGiB)
	populate(objectMap, "peakDiskGiB", b.PeakDiskGiB)
	populate(objectMap, "peakMemoryGiB", b.PeakMemoryGiB)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolResourceStatistics.
func (b *BatchPoolResourceStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "avgCPUPercentage":
				err = unpopulate(val, "AvgCPUPercentage", &b.AvgCPUPercentage)
			delete(rawMsg, key)
		case "avgDiskGiB":
				err = unpopulate(val, "AvgDiskGiB", &b.AvgDiskGiB)
			delete(rawMsg, key)
		case "avgMemoryGiB":
				err = unpopulate(val, "AvgMemoryGiB", &b.AvgMemoryGiB)
			delete(rawMsg, key)
		case "diskReadGiB":
				err = unpopulate(val, "DiskReadGiB", &b.DiskReadGiB)
			delete(rawMsg, key)
		case "diskReadIOps":
				err = unpopulate(val, "DiskReadIOps", &b.DiskReadIOps)
			delete(rawMsg, key)
		case "diskWriteGiB":
				err = unpopulate(val, "DiskWriteGiB", &b.DiskWriteGiB)
			delete(rawMsg, key)
		case "diskWriteIOps":
				err = unpopulate(val, "DiskWriteIOps", &b.DiskWriteIOps)
			delete(rawMsg, key)
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "networkReadGiB":
				err = unpopulate(val, "NetworkReadGiB", &b.NetworkReadGiB)
			delete(rawMsg, key)
		case "networkWriteGiB":
				err = unpopulate(val, "NetworkWriteGiB", &b.NetworkWriteGiB)
			delete(rawMsg, key)
		case "peakDiskGiB":
				err = unpopulate(val, "PeakDiskGiB", &b.PeakDiskGiB)
			delete(rawMsg, key)
		case "peakMemoryGiB":
				err = unpopulate(val, "PeakMemoryGiB", &b.PeakMemoryGiB)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolSpecification.
func (b BatchPoolSpecification) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationLicenses", b.ApplicationLicenses)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "autoScaleEvaluationInterval", b.AutoScaleEvaluationInterval)
	populate(objectMap, "autoScaleFormula", b.AutoScaleFormula)
	populate(objectMap, "certificateReferences", b.CertificateReferences)
	populate(objectMap, "cloudServiceConfiguration", b.CloudServiceConfiguration)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "enableAutoScale", b.EnableAutoScale)
	populate(objectMap, "enableInterNodeCommunication", b.EnableInterNodeCommunication)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "mountConfiguration", b.MountConfiguration)
	populate(objectMap, "networkConfiguration", b.NetworkConfiguration)
	populate(objectMap, "resizeTimeout", b.ResizeTimeout)
	populate(objectMap, "resourceTags", b.ResourceTags)
	populate(objectMap, "startTask", b.StartTask)
	populate(objectMap, "targetDedicatedNodes", b.TargetDedicatedNodes)
	populate(objectMap, "targetLowPriorityNodes", b.TargetLowPriorityNodes)
	populate(objectMap, "targetNodeCommunicationMode", b.TargetNodeCommunicationMode)
	populate(objectMap, "taskSchedulingPolicy", b.TaskSchedulingPolicy)
	populate(objectMap, "taskSlotsPerNode", b.TaskSlotsPerNode)
	populate(objectMap, "upgradePolicy", b.UpgradePolicy)
	populate(objectMap, "userAccounts", b.UserAccounts)
	populate(objectMap, "vmSize", b.VMSize)
	populate(objectMap, "virtualMachineConfiguration", b.VirtualMachineConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolSpecification.
func (b *BatchPoolSpecification) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationLicenses":
				err = unpopulate(val, "ApplicationLicenses", &b.ApplicationLicenses)
			delete(rawMsg, key)
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "autoScaleEvaluationInterval":
				err = unpopulate(val, "AutoScaleEvaluationInterval", &b.AutoScaleEvaluationInterval)
			delete(rawMsg, key)
		case "autoScaleFormula":
				err = unpopulate(val, "AutoScaleFormula", &b.AutoScaleFormula)
			delete(rawMsg, key)
		case "certificateReferences":
				err = unpopulate(val, "CertificateReferences", &b.CertificateReferences)
			delete(rawMsg, key)
		case "cloudServiceConfiguration":
				err = unpopulate(val, "CloudServiceConfiguration", &b.CloudServiceConfiguration)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "enableAutoScale":
				err = unpopulate(val, "EnableAutoScale", &b.EnableAutoScale)
			delete(rawMsg, key)
		case "enableInterNodeCommunication":
				err = unpopulate(val, "EnableInterNodeCommunication", &b.EnableInterNodeCommunication)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "mountConfiguration":
				err = unpopulate(val, "MountConfiguration", &b.MountConfiguration)
			delete(rawMsg, key)
		case "networkConfiguration":
				err = unpopulate(val, "NetworkConfiguration", &b.NetworkConfiguration)
			delete(rawMsg, key)
		case "resizeTimeout":
				err = unpopulate(val, "ResizeTimeout", &b.ResizeTimeout)
			delete(rawMsg, key)
		case "resourceTags":
				err = unpopulate(val, "ResourceTags", &b.ResourceTags)
			delete(rawMsg, key)
		case "startTask":
				err = unpopulate(val, "StartTask", &b.StartTask)
			delete(rawMsg, key)
		case "targetDedicatedNodes":
				err = unpopulate(val, "TargetDedicatedNodes", &b.TargetDedicatedNodes)
			delete(rawMsg, key)
		case "targetLowPriorityNodes":
				err = unpopulate(val, "TargetLowPriorityNodes", &b.TargetLowPriorityNodes)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
				err = unpopulate(val, "TargetNodeCommunicationMode", &b.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		case "taskSchedulingPolicy":
				err = unpopulate(val, "TaskSchedulingPolicy", &b.TaskSchedulingPolicy)
			delete(rawMsg, key)
		case "taskSlotsPerNode":
				err = unpopulate(val, "TaskSlotsPerNode", &b.TaskSlotsPerNode)
			delete(rawMsg, key)
		case "upgradePolicy":
				err = unpopulate(val, "UpgradePolicy", &b.UpgradePolicy)
			delete(rawMsg, key)
		case "userAccounts":
				err = unpopulate(val, "UserAccounts", &b.UserAccounts)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &b.VMSize)
			delete(rawMsg, key)
		case "virtualMachineConfiguration":
				err = unpopulate(val, "VirtualMachineConfiguration", &b.VirtualMachineConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolStatistics.
func (b BatchPoolStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populate(objectMap, "resourceStats", b.ResourceStats)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "usageStats", b.UsageStats)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolStatistics.
func (b *BatchPoolStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "resourceStats":
				err = unpopulate(val, "ResourceStats", &b.ResourceStats)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "usageStats":
				err = unpopulate(val, "UsageStats", &b.UsageStats)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolUpdateContent.
func (b BatchPoolUpdateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "certificateReferences", b.CertificateReferences)
	populate(objectMap, "metadata", b.Metadata)
	populate(objectMap, "startTask", b.StartTask)
	populate(objectMap, "targetNodeCommunicationMode", b.TargetNodeCommunicationMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolUpdateContent.
func (b *BatchPoolUpdateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "certificateReferences":
				err = unpopulate(val, "CertificateReferences", &b.CertificateReferences)
			delete(rawMsg, key)
		case "metadata":
				err = unpopulate(val, "Metadata", &b.Metadata)
			delete(rawMsg, key)
		case "startTask":
				err = unpopulate(val, "StartTask", &b.StartTask)
			delete(rawMsg, key)
		case "targetNodeCommunicationMode":
				err = unpopulate(val, "TargetNodeCommunicationMode", &b.TargetNodeCommunicationMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolUsageMetrics.
func (b BatchPoolUsageMetrics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "poolId", b.PoolID)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "totalCoreHours", b.TotalCoreHours)
	populate(objectMap, "vmSize", b.VMSize)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolUsageMetrics.
func (b *BatchPoolUsageMetrics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "poolId":
				err = unpopulate(val, "PoolID", &b.PoolID)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "totalCoreHours":
				err = unpopulate(val, "TotalCoreHours", &b.TotalCoreHours)
			delete(rawMsg, key)
		case "vmSize":
				err = unpopulate(val, "VMSize", &b.VMSize)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchPoolUsageStatistics.
func (b BatchPoolUsageStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dedicatedCoreTime", b.DedicatedCoreTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchPoolUsageStatistics.
func (b *BatchPoolUsageStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dedicatedCoreTime":
				err = unpopulate(val, "DedicatedCoreTime", &b.DedicatedCoreTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchStartTask.
func (b BatchStartTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commandLine", b.CommandLine)
	populate(objectMap, "containerSettings", b.ContainerSettings)
	populate(objectMap, "environmentSettings", b.EnvironmentSettings)
	populate(objectMap, "maxTaskRetryCount", b.MaxTaskRetryCount)
	populate(objectMap, "resourceFiles", b.ResourceFiles)
	populate(objectMap, "userIdentity", b.UserIdentity)
	populate(objectMap, "waitForSuccess", b.WaitForSuccess)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchStartTask.
func (b *BatchStartTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandLine":
				err = unpopulate(val, "CommandLine", &b.CommandLine)
			delete(rawMsg, key)
		case "containerSettings":
				err = unpopulate(val, "ContainerSettings", &b.ContainerSettings)
			delete(rawMsg, key)
		case "environmentSettings":
				err = unpopulate(val, "EnvironmentSettings", &b.EnvironmentSettings)
			delete(rawMsg, key)
		case "maxTaskRetryCount":
				err = unpopulate(val, "MaxTaskRetryCount", &b.MaxTaskRetryCount)
			delete(rawMsg, key)
		case "resourceFiles":
				err = unpopulate(val, "ResourceFiles", &b.ResourceFiles)
			delete(rawMsg, key)
		case "userIdentity":
				err = unpopulate(val, "UserIdentity", &b.UserIdentity)
			delete(rawMsg, key)
		case "waitForSuccess":
				err = unpopulate(val, "WaitForSuccess", &b.WaitForSuccess)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchStartTaskInfo.
func (b BatchStartTaskInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", b.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "exitCode", b.ExitCode)
	populate(objectMap, "failureInfo", b.FailureInfo)
	populateDateTimeRFC3339(objectMap, "lastRetryTime", b.LastRetryTime)
	populate(objectMap, "result", b.Result)
	populate(objectMap, "retryCount", b.RetryCount)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "state", b.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchStartTaskInfo.
func (b *BatchStartTaskInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
				err = unpopulate(val, "ContainerInfo", &b.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "exitCode":
				err = unpopulate(val, "ExitCode", &b.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
				err = unpopulate(val, "FailureInfo", &b.FailureInfo)
			delete(rawMsg, key)
		case "lastRetryTime":
				err = unpopulateDateTimeRFC3339(val, "LastRetryTime", &b.LastRetryTime)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &b.Result)
			delete(rawMsg, key)
		case "retryCount":
				err = unpopulate(val, "RetryCount", &b.RetryCount)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchSubtask.
func (b BatchSubtask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", b.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "exitCode", b.ExitCode)
	populate(objectMap, "failureInfo", b.FailureInfo)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "nodeInfo", b.NodeInfo)
	populate(objectMap, "previousState", b.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", b.PreviousStateTransitionTime)
	populate(objectMap, "result", b.Result)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchSubtask.
func (b *BatchSubtask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
				err = unpopulate(val, "ContainerInfo", &b.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "exitCode":
				err = unpopulate(val, "ExitCode", &b.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
				err = unpopulate(val, "FailureInfo", &b.FailureInfo)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "nodeInfo":
				err = unpopulate(val, "NodeInfo", &b.NodeInfo)
			delete(rawMsg, key)
		case "previousState":
				err = unpopulate(val, "PreviousState", &b.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &b.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &b.Result)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTask.
func (b BatchTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityInfo", b.AffinityInfo)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "authenticationTokenSettings", b.AuthenticationTokenSettings)
	populate(objectMap, "commandLine", b.CommandLine)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "containerSettings", b.ContainerSettings)
	populateDateTimeRFC3339(objectMap, "creationTime", b.CreationTime)
	populate(objectMap, "dependsOn", b.DependsOn)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "eTag", b.ETag)
	populate(objectMap, "environmentSettings", b.EnvironmentSettings)
	populate(objectMap, "executionInfo", b.ExecutionInfo)
	populate(objectMap, "exitConditions", b.ExitConditions)
	populate(objectMap, "id", b.ID)
	populateDateTimeRFC3339(objectMap, "lastModified", b.LastModified)
	populate(objectMap, "multiInstanceSettings", b.MultiInstanceSettings)
	populate(objectMap, "nodeInfo", b.NodeInfo)
	populate(objectMap, "outputFiles", b.OutputFiles)
	populate(objectMap, "previousState", b.PreviousState)
	populateDateTimeRFC3339(objectMap, "previousStateTransitionTime", b.PreviousStateTransitionTime)
	populate(objectMap, "requiredSlots", b.RequiredSlots)
	populate(objectMap, "resourceFiles", b.ResourceFiles)
	populate(objectMap, "state", b.State)
	populateDateTimeRFC3339(objectMap, "stateTransitionTime", b.StateTransitionTime)
	populate(objectMap, "stats", b.Stats)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "userIdentity", b.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTask.
func (b *BatchTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityInfo":
				err = unpopulate(val, "AffinityInfo", &b.AffinityInfo)
			delete(rawMsg, key)
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "authenticationTokenSettings":
				err = unpopulate(val, "AuthenticationTokenSettings", &b.AuthenticationTokenSettings)
			delete(rawMsg, key)
		case "commandLine":
				err = unpopulate(val, "CommandLine", &b.CommandLine)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
				err = unpopulate(val, "ContainerSettings", &b.ContainerSettings)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &b.CreationTime)
			delete(rawMsg, key)
		case "dependsOn":
				err = unpopulate(val, "DependsOn", &b.DependsOn)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "eTag":
				err = unpopulate(val, "ETag", &b.ETag)
			delete(rawMsg, key)
		case "environmentSettings":
				err = unpopulate(val, "EnvironmentSettings", &b.EnvironmentSettings)
			delete(rawMsg, key)
		case "executionInfo":
				err = unpopulate(val, "ExecutionInfo", &b.ExecutionInfo)
			delete(rawMsg, key)
		case "exitConditions":
				err = unpopulate(val, "ExitConditions", &b.ExitConditions)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "lastModified":
				err = unpopulateDateTimeRFC3339(val, "LastModified", &b.LastModified)
			delete(rawMsg, key)
		case "multiInstanceSettings":
				err = unpopulate(val, "MultiInstanceSettings", &b.MultiInstanceSettings)
			delete(rawMsg, key)
		case "nodeInfo":
				err = unpopulate(val, "NodeInfo", &b.NodeInfo)
			delete(rawMsg, key)
		case "outputFiles":
				err = unpopulate(val, "OutputFiles", &b.OutputFiles)
			delete(rawMsg, key)
		case "previousState":
				err = unpopulate(val, "PreviousState", &b.PreviousState)
			delete(rawMsg, key)
		case "previousStateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "PreviousStateTransitionTime", &b.PreviousStateTransitionTime)
			delete(rawMsg, key)
		case "requiredSlots":
				err = unpopulate(val, "RequiredSlots", &b.RequiredSlots)
			delete(rawMsg, key)
		case "resourceFiles":
				err = unpopulate(val, "ResourceFiles", &b.ResourceFiles)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		case "stateTransitionTime":
				err = unpopulateDateTimeRFC3339(val, "StateTransitionTime", &b.StateTransitionTime)
			delete(rawMsg, key)
		case "stats":
				err = unpopulate(val, "Stats", &b.Stats)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "userIdentity":
				err = unpopulate(val, "UserIdentity", &b.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskAddCollectionResult.
func (b BatchTaskAddCollectionResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskAddCollectionResult.
func (b *BatchTaskAddCollectionResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskAddResult.
func (b BatchTaskAddResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "eTag", b.ETag)
	populate(objectMap, "error", b.Error)
	populateDateTimeRFC3339(objectMap, "lastModified", b.LastModified)
	populate(objectMap, "location", b.Location)
	populate(objectMap, "status", b.Status)
	populate(objectMap, "taskId", b.TaskID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskAddResult.
func (b *BatchTaskAddResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "eTag":
				err = unpopulate(val, "ETag", &b.ETag)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &b.Error)
			delete(rawMsg, key)
		case "lastModified":
				err = unpopulateDateTimeRFC3339(val, "LastModified", &b.LastModified)
			delete(rawMsg, key)
		case "location":
				err = unpopulate(val, "Location", &b.Location)
			delete(rawMsg, key)
		case "status":
				err = unpopulate(val, "Status", &b.Status)
			delete(rawMsg, key)
		case "taskId":
				err = unpopulate(val, "TaskID", &b.TaskID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskConstraints.
func (b BatchTaskConstraints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "maxTaskRetryCount", b.MaxTaskRetryCount)
	populate(objectMap, "maxWallClockTime", b.MaxWallClockTime)
	populate(objectMap, "retentionTime", b.RetentionTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskConstraints.
func (b *BatchTaskConstraints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "maxTaskRetryCount":
				err = unpopulate(val, "MaxTaskRetryCount", &b.MaxTaskRetryCount)
			delete(rawMsg, key)
		case "maxWallClockTime":
				err = unpopulate(val, "MaxWallClockTime", &b.MaxWallClockTime)
			delete(rawMsg, key)
		case "retentionTime":
				err = unpopulate(val, "RetentionTime", &b.RetentionTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskContainerExecutionInfo.
func (b BatchTaskContainerExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerId", b.ContainerID)
	populate(objectMap, "error", b.Error)
	populate(objectMap, "state", b.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskContainerExecutionInfo.
func (b *BatchTaskContainerExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerId":
				err = unpopulate(val, "ContainerID", &b.ContainerID)
			delete(rawMsg, key)
		case "error":
				err = unpopulate(val, "Error", &b.Error)
			delete(rawMsg, key)
		case "state":
				err = unpopulate(val, "State", &b.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskContainerSettings.
func (b BatchTaskContainerSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerRunOptions", b.ContainerRunOptions)
	populate(objectMap, "imageName", b.ImageName)
	populate(objectMap, "registry", b.Registry)
	populate(objectMap, "workingDirectory", b.WorkingDirectory)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskContainerSettings.
func (b *BatchTaskContainerSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerRunOptions":
				err = unpopulate(val, "ContainerRunOptions", &b.ContainerRunOptions)
			delete(rawMsg, key)
		case "imageName":
				err = unpopulate(val, "ImageName", &b.ImageName)
			delete(rawMsg, key)
		case "registry":
				err = unpopulate(val, "Registry", &b.Registry)
			delete(rawMsg, key)
		case "workingDirectory":
				err = unpopulate(val, "WorkingDirectory", &b.WorkingDirectory)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskCounts.
func (b BatchTaskCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "active", b.Active)
	populate(objectMap, "completed", b.Completed)
	populate(objectMap, "failed", b.Failed)
	populate(objectMap, "running", b.Running)
	populate(objectMap, "succeeded", b.Succeeded)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskCounts.
func (b *BatchTaskCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "active":
				err = unpopulate(val, "Active", &b.Active)
			delete(rawMsg, key)
		case "completed":
				err = unpopulate(val, "Completed", &b.Completed)
			delete(rawMsg, key)
		case "failed":
				err = unpopulate(val, "Failed", &b.Failed)
			delete(rawMsg, key)
		case "running":
				err = unpopulate(val, "Running", &b.Running)
			delete(rawMsg, key)
		case "succeeded":
				err = unpopulate(val, "Succeeded", &b.Succeeded)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskCountsResult.
func (b BatchTaskCountsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "taskCounts", b.TaskCounts)
	populate(objectMap, "taskSlotCounts", b.TaskSlotCounts)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskCountsResult.
func (b *BatchTaskCountsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "taskCounts":
				err = unpopulate(val, "TaskCounts", &b.TaskCounts)
			delete(rawMsg, key)
		case "taskSlotCounts":
				err = unpopulate(val, "TaskSlotCounts", &b.TaskSlotCounts)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskCreateContent.
func (b BatchTaskCreateContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "affinityInfo", b.AffinityInfo)
	populate(objectMap, "applicationPackageReferences", b.ApplicationPackageReferences)
	populate(objectMap, "authenticationTokenSettings", b.AuthenticationTokenSettings)
	populate(objectMap, "commandLine", b.CommandLine)
	populate(objectMap, "constraints", b.Constraints)
	populate(objectMap, "containerSettings", b.ContainerSettings)
	populate(objectMap, "dependsOn", b.DependsOn)
	populate(objectMap, "displayName", b.DisplayName)
	populate(objectMap, "environmentSettings", b.EnvironmentSettings)
	populate(objectMap, "exitConditions", b.ExitConditions)
	populate(objectMap, "id", b.ID)
	populate(objectMap, "multiInstanceSettings", b.MultiInstanceSettings)
	populate(objectMap, "outputFiles", b.OutputFiles)
	populate(objectMap, "requiredSlots", b.RequiredSlots)
	populate(objectMap, "resourceFiles", b.ResourceFiles)
	populate(objectMap, "userIdentity", b.UserIdentity)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskCreateContent.
func (b *BatchTaskCreateContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "affinityInfo":
				err = unpopulate(val, "AffinityInfo", &b.AffinityInfo)
			delete(rawMsg, key)
		case "applicationPackageReferences":
				err = unpopulate(val, "ApplicationPackageReferences", &b.ApplicationPackageReferences)
			delete(rawMsg, key)
		case "authenticationTokenSettings":
				err = unpopulate(val, "AuthenticationTokenSettings", &b.AuthenticationTokenSettings)
			delete(rawMsg, key)
		case "commandLine":
				err = unpopulate(val, "CommandLine", &b.CommandLine)
			delete(rawMsg, key)
		case "constraints":
				err = unpopulate(val, "Constraints", &b.Constraints)
			delete(rawMsg, key)
		case "containerSettings":
				err = unpopulate(val, "ContainerSettings", &b.ContainerSettings)
			delete(rawMsg, key)
		case "dependsOn":
				err = unpopulate(val, "DependsOn", &b.DependsOn)
			delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, "DisplayName", &b.DisplayName)
			delete(rawMsg, key)
		case "environmentSettings":
				err = unpopulate(val, "EnvironmentSettings", &b.EnvironmentSettings)
			delete(rawMsg, key)
		case "exitConditions":
				err = unpopulate(val, "ExitConditions", &b.ExitConditions)
			delete(rawMsg, key)
		case "id":
				err = unpopulate(val, "ID", &b.ID)
			delete(rawMsg, key)
		case "multiInstanceSettings":
				err = unpopulate(val, "MultiInstanceSettings", &b.MultiInstanceSettings)
			delete(rawMsg, key)
		case "outputFiles":
				err = unpopulate(val, "OutputFiles", &b.OutputFiles)
			delete(rawMsg, key)
		case "requiredSlots":
				err = unpopulate(val, "RequiredSlots", &b.RequiredSlots)
			delete(rawMsg, key)
		case "resourceFiles":
				err = unpopulate(val, "ResourceFiles", &b.ResourceFiles)
			delete(rawMsg, key)
		case "userIdentity":
				err = unpopulate(val, "UserIdentity", &b.UserIdentity)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskDependencies.
func (b BatchTaskDependencies) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "taskIdRanges", b.TaskIDRanges)
	populate(objectMap, "taskIds", b.TaskIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskDependencies.
func (b *BatchTaskDependencies) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "taskIdRanges":
				err = unpopulate(val, "TaskIDRanges", &b.TaskIDRanges)
			delete(rawMsg, key)
		case "taskIds":
				err = unpopulate(val, "TaskIDs", &b.TaskIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskExecutionInfo.
func (b BatchTaskExecutionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerInfo", b.ContainerInfo)
	populateDateTimeRFC3339(objectMap, "endTime", b.EndTime)
	populate(objectMap, "exitCode", b.ExitCode)
	populate(objectMap, "failureInfo", b.FailureInfo)
	populateDateTimeRFC3339(objectMap, "lastRequeueTime", b.LastRequeueTime)
	populateDateTimeRFC3339(objectMap, "lastRetryTime", b.LastRetryTime)
	populate(objectMap, "requeueCount", b.RequeueCount)
	populate(objectMap, "result", b.Result)
	populate(objectMap, "retryCount", b.RetryCount)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskExecutionInfo.
func (b *BatchTaskExecutionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerInfo":
				err = unpopulate(val, "ContainerInfo", &b.ContainerInfo)
			delete(rawMsg, key)
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &b.EndTime)
			delete(rawMsg, key)
		case "exitCode":
				err = unpopulate(val, "ExitCode", &b.ExitCode)
			delete(rawMsg, key)
		case "failureInfo":
				err = unpopulate(val, "FailureInfo", &b.FailureInfo)
			delete(rawMsg, key)
		case "lastRequeueTime":
				err = unpopulateDateTimeRFC3339(val, "LastRequeueTime", &b.LastRequeueTime)
			delete(rawMsg, key)
		case "lastRetryTime":
				err = unpopulateDateTimeRFC3339(val, "LastRetryTime", &b.LastRetryTime)
			delete(rawMsg, key)
		case "requeueCount":
				err = unpopulate(val, "RequeueCount", &b.RequeueCount)
			delete(rawMsg, key)
		case "result":
				err = unpopulate(val, "Result", &b.Result)
			delete(rawMsg, key)
		case "retryCount":
				err = unpopulate(val, "RetryCount", &b.RetryCount)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskFailureInfo.
func (b BatchTaskFailureInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "category", b.Category)
	populate(objectMap, "code", b.Code)
	populate(objectMap, "details", b.Details)
	populate(objectMap, "message", b.Message)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskFailureInfo.
func (b *BatchTaskFailureInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
				err = unpopulate(val, "Category", &b.Category)
			delete(rawMsg, key)
		case "code":
				err = unpopulate(val, "Code", &b.Code)
			delete(rawMsg, key)
		case "details":
				err = unpopulate(val, "Details", &b.Details)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &b.Message)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskGroup.
func (b BatchTaskGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskGroup.
func (b *BatchTaskGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskIDRange.
func (b BatchTaskIDRange) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "end", b.End)
	populate(objectMap, "start", b.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskIDRange.
func (b *BatchTaskIDRange) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
				err = unpopulate(val, "End", &b.End)
			delete(rawMsg, key)
		case "start":
				err = unpopulate(val, "Start", &b.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskInfo.
func (b BatchTaskInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "executionInfo", b.ExecutionInfo)
	populate(objectMap, "jobId", b.JobID)
	populate(objectMap, "subtaskId", b.SubtaskID)
	populate(objectMap, "taskId", b.TaskID)
	populate(objectMap, "taskState", b.TaskState)
	populate(objectMap, "taskUrl", b.TaskURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskInfo.
func (b *BatchTaskInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "executionInfo":
				err = unpopulate(val, "ExecutionInfo", &b.ExecutionInfo)
			delete(rawMsg, key)
		case "jobId":
				err = unpopulate(val, "JobID", &b.JobID)
			delete(rawMsg, key)
		case "subtaskId":
				err = unpopulate(val, "SubtaskID", &b.SubtaskID)
			delete(rawMsg, key)
		case "taskId":
				err = unpopulate(val, "TaskID", &b.TaskID)
			delete(rawMsg, key)
		case "taskState":
				err = unpopulate(val, "TaskState", &b.TaskState)
			delete(rawMsg, key)
		case "taskUrl":
				err = unpopulate(val, "TaskURL", &b.TaskURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskListResult.
func (b BatchTaskListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskListResult.
func (b *BatchTaskListResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskListSubtasksResult.
func (b BatchTaskListSubtasksResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "odata.nextLink", b.ODataNextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskListSubtasksResult.
func (b *BatchTaskListSubtasksResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "odata.nextLink":
				err = unpopulate(val, "ODataNextLink", &b.ODataNextLink)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &b.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskSchedulingPolicy.
func (b BatchTaskSchedulingPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "nodeFillType", b.NodeFillType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskSchedulingPolicy.
func (b *BatchTaskSchedulingPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "nodeFillType":
				err = unpopulate(val, "NodeFillType", &b.NodeFillType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskSlotCounts.
func (b BatchTaskSlotCounts) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "active", b.Active)
	populate(objectMap, "completed", b.Completed)
	populate(objectMap, "failed", b.Failed)
	populate(objectMap, "running", b.Running)
	populate(objectMap, "succeeded", b.Succeeded)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskSlotCounts.
func (b *BatchTaskSlotCounts) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "active":
				err = unpopulate(val, "Active", &b.Active)
			delete(rawMsg, key)
		case "completed":
				err = unpopulate(val, "Completed", &b.Completed)
			delete(rawMsg, key)
		case "failed":
				err = unpopulate(val, "Failed", &b.Failed)
			delete(rawMsg, key)
		case "running":
				err = unpopulate(val, "Running", &b.Running)
			delete(rawMsg, key)
		case "succeeded":
				err = unpopulate(val, "Succeeded", &b.Succeeded)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type BatchTaskStatistics.
func (b BatchTaskStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "kernelCPUTime", b.KernelCPUTime)
	populateDateTimeRFC3339(objectMap, "lastUpdateTime", b.LastUpdateTime)
	populate(objectMap, "readIOGiB", b.ReadIOGiB)
	populate(objectMap, "readIOps", b.ReadIOps)
	populateDateTimeRFC3339(objectMap, "startTime", b.StartTime)
	populate(objectMap, "url", b.URL)
	populate(objectMap, "userCPUTime", b.UserCPUTime)
	populate(objectMap, "waitTime", b.WaitTime)
	populate(objectMap, "wallClockTime", b.WallClockTime)
	populate(objectMap, "writeIOGiB", b.WriteIOGiB)
	populate(objectMap, "writeIOps", b.WriteIOps)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BatchTaskStatistics.
func (b *BatchTaskStatistics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", b, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "kernelCPUTime":
				err = unpopulate(val, "KernelCPUTime", &b.KernelCPUTime)
			delete(rawMsg, key)
		case "lastUpdateTime":
				err = unpopulateDateTimeRFC3339(val, "LastUpdateTime", &b.LastUpdateTime)
			delete(rawMsg, key)
		case "readIOGiB":
				err = unpopulate(val, "ReadIOGiB", &b.ReadIOGiB)
			delete(rawMsg, key)
		case "readIOps":
				err = unpopulate(val, "ReadIOps", &b.ReadIOps)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &b.StartTime)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &b.URL)
			delete(rawMsg, key)
		case "userCPUTime":
				err = unpopulate(val, "UserCPUTime", &b.UserCPUTime)
			delete(rawMsg, key)
		case "waitTime":
				err = unpopulate(val, "WaitTime", &b.WaitTime)
			delete(rawMsg, key)
		case "wallClockTime":
				err = unpopulate(val, "WallClockTime", &b.WallClockTime)
			delete(rawMsg, key)
		case "writeIOGiB":
				err = unpopulate(val, "WriteIOGiB", &b.WriteIOGiB)
			delete(rawMsg, key)
		case "writeIOps":
				err = unpopulate(val, "WriteIOps", &b.WriteIOps)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", b, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CifsMountConfiguration.
func (c CifsMountConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mountOptions", c.MountOptions)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "relativeMountPath", c.RelativeMountPath)
	populate(objectMap, "source", c.Source)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CifsMountConfiguration.
func (c *CifsMountConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mountOptions":
				err = unpopulate(val, "MountOptions", &c.MountOptions)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "relativeMountPath":
				err = unpopulate(val, "RelativeMountPath", &c.RelativeMountPath)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &c.Source)
			delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type CloudServiceConfiguration.
func (c CloudServiceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "osFamily", c.OSFamily)
	populate(objectMap, "osVersion", c.OSVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudServiceConfiguration.
func (c *CloudServiceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "osFamily":
				err = unpopulate(val, "OSFamily", &c.OSFamily)
			delete(rawMsg, key)
		case "osVersion":
				err = unpopulate(val, "OSVersion", &c.OSVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerConfiguration.
func (c ContainerConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerImageNames", c.ContainerImageNames)
	populate(objectMap, "containerRegistries", c.ContainerRegistries)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerConfiguration.
func (c *ContainerConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerImageNames":
				err = unpopulate(val, "ContainerImageNames", &c.ContainerImageNames)
			delete(rawMsg, key)
		case "containerRegistries":
				err = unpopulate(val, "ContainerRegistries", &c.ContainerRegistries)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &c.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ContainerRegistry.
func (c ContainerRegistry) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "identityReference", c.IdentityReference)
	populate(objectMap, "password", c.Password)
	populate(objectMap, "registryServer", c.RegistryServer)
	populate(objectMap, "username", c.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ContainerRegistry.
func (c *ContainerRegistry) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", c, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "identityReference":
				err = unpopulate(val, "IdentityReference", &c.IdentityReference)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &c.Password)
			delete(rawMsg, key)
		case "registryServer":
				err = unpopulate(val, "RegistryServer", &c.RegistryServer)
			delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &c.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", c, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DataDisk.
func (d DataDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "caching", d.Caching)
	populate(objectMap, "diskSizeGB", d.DiskSizeGb)
	populate(objectMap, "lun", d.LogicalUnitNumber)
	populate(objectMap, "storageAccountType", d.StorageAccountType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataDisk.
func (d *DataDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "caching":
				err = unpopulate(val, "Caching", &d.Caching)
			delete(rawMsg, key)
		case "diskSizeGB":
				err = unpopulate(val, "DiskSizeGb", &d.DiskSizeGb)
			delete(rawMsg, key)
		case "lun":
				err = unpopulate(val, "LogicalUnitNumber", &d.LogicalUnitNumber)
			delete(rawMsg, key)
		case "storageAccountType":
				err = unpopulate(val, "StorageAccountType", &d.StorageAccountType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DeleteBatchCertificateError.
func (d DeleteBatchCertificateError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", d.Code)
	populate(objectMap, "message", d.Message)
	populate(objectMap, "values", d.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeleteBatchCertificateError.
func (d *DeleteBatchCertificateError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &d.Code)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &d.Message)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &d.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiffDiskSettings.
func (d DiffDiskSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "placement", d.Placement)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiffDiskSettings.
func (d *DiffDiskSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "placement":
				err = unpopulate(val, "Placement", &d.Placement)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DiskEncryptionConfiguration.
func (d DiskEncryptionConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "targets", d.Targets)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DiskEncryptionConfiguration.
func (d *DiskEncryptionConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", d, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "targets":
				err = unpopulate(val, "Targets", &d.Targets)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", d, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type EnvironmentSetting.
func (e EnvironmentSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", e.Name)
	populate(objectMap, "value", e.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EnvironmentSetting.
func (e *EnvironmentSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &e.Name)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &e.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitCodeMapping.
func (e ExitCodeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", e.Code)
	populate(objectMap, "exitOptions", e.ExitOptions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitCodeMapping.
func (e *ExitCodeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &e.Code)
			delete(rawMsg, key)
		case "exitOptions":
				err = unpopulate(val, "ExitOptions", &e.ExitOptions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitCodeRangeMapping.
func (e ExitCodeRangeMapping) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "end", e.End)
	populate(objectMap, "exitOptions", e.ExitOptions)
	populate(objectMap, "start", e.Start)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitCodeRangeMapping.
func (e *ExitCodeRangeMapping) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "end":
				err = unpopulate(val, "End", &e.End)
			delete(rawMsg, key)
		case "exitOptions":
				err = unpopulate(val, "ExitOptions", &e.ExitOptions)
			delete(rawMsg, key)
		case "start":
				err = unpopulate(val, "Start", &e.Start)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitConditions.
func (e ExitConditions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "default", e.Default)
	populate(objectMap, "exitCodeRanges", e.ExitCodeRanges)
	populate(objectMap, "exitCodes", e.ExitCodes)
	populate(objectMap, "fileUploadError", e.FileUploadError)
	populate(objectMap, "preProcessingError", e.PreProcessingError)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitConditions.
func (e *ExitConditions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "default":
				err = unpopulate(val, "Default", &e.Default)
			delete(rawMsg, key)
		case "exitCodeRanges":
				err = unpopulate(val, "ExitCodeRanges", &e.ExitCodeRanges)
			delete(rawMsg, key)
		case "exitCodes":
				err = unpopulate(val, "ExitCodes", &e.ExitCodes)
			delete(rawMsg, key)
		case "fileUploadError":
				err = unpopulate(val, "FileUploadError", &e.FileUploadError)
			delete(rawMsg, key)
		case "preProcessingError":
				err = unpopulate(val, "PreProcessingError", &e.PreProcessingError)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ExitOptions.
func (e ExitOptions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dependencyAction", e.DependencyAction)
	populate(objectMap, "jobAction", e.JobAction)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ExitOptions.
func (e *ExitOptions) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", e, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dependencyAction":
				err = unpopulate(val, "DependencyAction", &e.DependencyAction)
			delete(rawMsg, key)
		case "jobAction":
				err = unpopulate(val, "JobAction", &e.JobAction)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", e, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type FileProperties.
func (f FileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "contentLength", f.ContentLength)
	populate(objectMap, "contentType", f.ContentType)
	populateDateTimeRFC3339(objectMap, "creationTime", f.CreationTime)
	populate(objectMap, "fileMode", f.FileMode)
	populateDateTimeRFC3339(objectMap, "lastModified", f.LastModified)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type FileProperties.
func (f *FileProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", f, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "contentLength":
				err = unpopulate(val, "ContentLength", &f.ContentLength)
			delete(rawMsg, key)
		case "contentType":
				err = unpopulate(val, "ContentType", &f.ContentType)
			delete(rawMsg, key)
		case "creationTime":
				err = unpopulateDateTimeRFC3339(val, "CreationTime", &f.CreationTime)
			delete(rawMsg, key)
		case "fileMode":
				err = unpopulate(val, "FileMode", &f.FileMode)
			delete(rawMsg, key)
		case "lastModified":
				err = unpopulateDateTimeRFC3339(val, "LastModified", &f.LastModified)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", f, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HTTPHeader.
func (h HTTPHeader) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HTTPHeader.
func (h *HTTPHeader) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", h, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &h.Name)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &h.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", h, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageInfo.
func (i ImageInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populateDateTimeRFC3339(objectMap, "batchSupportEndOfLife", i.BatchSupportEndOfLife)
	populate(objectMap, "capabilities", i.Capabilities)
	populate(objectMap, "imageReference", i.ImageReference)
	populate(objectMap, "nodeAgentSKUId", i.NodeAgentSKUID)
	populate(objectMap, "osType", i.OSType)
	populate(objectMap, "verificationType", i.VerificationType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageInfo.
func (i *ImageInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "batchSupportEndOfLife":
				err = unpopulateDateTimeRFC3339(val, "BatchSupportEndOfLife", &i.BatchSupportEndOfLife)
			delete(rawMsg, key)
		case "capabilities":
				err = unpopulate(val, "Capabilities", &i.Capabilities)
			delete(rawMsg, key)
		case "imageReference":
				err = unpopulate(val, "ImageReference", &i.ImageReference)
			delete(rawMsg, key)
		case "nodeAgentSKUId":
				err = unpopulate(val, "NodeAgentSKUID", &i.NodeAgentSKUID)
			delete(rawMsg, key)
		case "osType":
				err = unpopulate(val, "OSType", &i.OSType)
			delete(rawMsg, key)
		case "verificationType":
				err = unpopulate(val, "VerificationType", &i.VerificationType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ImageReference.
func (i ImageReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "exactVersion", i.ExactVersion)
	populate(objectMap, "offer", i.Offer)
	populate(objectMap, "publisher", i.Publisher)
	populate(objectMap, "sku", i.SKU)
	populate(objectMap, "version", i.Version)
	populate(objectMap, "virtualMachineImageId", i.VirtualMachineImageID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ImageReference.
func (i *ImageReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "exactVersion":
				err = unpopulate(val, "ExactVersion", &i.ExactVersion)
			delete(rawMsg, key)
		case "offer":
				err = unpopulate(val, "Offer", &i.Offer)
			delete(rawMsg, key)
		case "publisher":
				err = unpopulate(val, "Publisher", &i.Publisher)
			delete(rawMsg, key)
		case "sku":
				err = unpopulate(val, "SKU", &i.SKU)
			delete(rawMsg, key)
		case "version":
				err = unpopulate(val, "Version", &i.Version)
			delete(rawMsg, key)
		case "virtualMachineImageId":
				err = unpopulate(val, "VirtualMachineImageID", &i.VirtualMachineImageID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InboundEndpoint.
func (i InboundEndpoint) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendPort", i.BackendPort)
	populate(objectMap, "frontendPort", i.FrontendPort)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "protocol", i.Protocol)
	populate(objectMap, "publicFQDN", i.PublicFQDN)
	populate(objectMap, "publicIPAddress", i.PublicIPAddress)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InboundEndpoint.
func (i *InboundEndpoint) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPort":
				err = unpopulate(val, "BackendPort", &i.BackendPort)
			delete(rawMsg, key)
		case "frontendPort":
				err = unpopulate(val, "FrontendPort", &i.FrontendPort)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &i.Protocol)
			delete(rawMsg, key)
		case "publicFQDN":
				err = unpopulate(val, "PublicFQDN", &i.PublicFQDN)
			delete(rawMsg, key)
		case "publicIPAddress":
				err = unpopulate(val, "PublicIPAddress", &i.PublicIPAddress)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InboundNATPool.
func (i InboundNATPool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "backendPort", i.BackendPort)
	populate(objectMap, "frontendPortRangeEnd", i.FrontendPortRangeEnd)
	populate(objectMap, "frontendPortRangeStart", i.FrontendPortRangeStart)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "networkSecurityGroupRules", i.NetworkSecurityGroupRules)
	populate(objectMap, "protocol", i.Protocol)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InboundNATPool.
func (i *InboundNATPool) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backendPort":
				err = unpopulate(val, "BackendPort", &i.BackendPort)
			delete(rawMsg, key)
		case "frontendPortRangeEnd":
				err = unpopulate(val, "FrontendPortRangeEnd", &i.FrontendPortRangeEnd)
			delete(rawMsg, key)
		case "frontendPortRangeStart":
				err = unpopulate(val, "FrontendPortRangeStart", &i.FrontendPortRangeStart)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &i.Name)
			delete(rawMsg, key)
		case "networkSecurityGroupRules":
				err = unpopulate(val, "NetworkSecurityGroupRules", &i.NetworkSecurityGroupRules)
			delete(rawMsg, key)
		case "protocol":
				err = unpopulate(val, "Protocol", &i.Protocol)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type InstanceViewStatus.
func (i InstanceViewStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", i.Code)
	populate(objectMap, "displayStatus", i.DisplayStatus)
	populate(objectMap, "level", i.Level)
	populate(objectMap, "message", i.Message)
	populateDateTimeRFC3339(objectMap, "time", i.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstanceViewStatus.
func (i *InstanceViewStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", i, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &i.Code)
			delete(rawMsg, key)
		case "displayStatus":
				err = unpopulate(val, "DisplayStatus", &i.DisplayStatus)
			delete(rawMsg, key)
		case "level":
				err = unpopulate(val, "Level", &i.Level)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &i.Message)
			delete(rawMsg, key)
		case "time":
				err = unpopulateDateTimeRFC3339(val, "Time", &i.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", i, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type LinuxUserConfiguration.
func (l LinuxUserConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "gid", l.Gid)
	populate(objectMap, "sshPrivateKey", l.SSHPrivateKey)
	populate(objectMap, "uid", l.UID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type LinuxUserConfiguration.
func (l *LinuxUserConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", l, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "gid":
				err = unpopulate(val, "Gid", &l.Gid)
			delete(rawMsg, key)
		case "sshPrivateKey":
				err = unpopulate(val, "SSHPrivateKey", &l.SSHPrivateKey)
			delete(rawMsg, key)
		case "uid":
				err = unpopulate(val, "UID", &l.UID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", l, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ManagedDisk.
func (m ManagedDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "storageAccountType", m.StorageAccountType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagedDisk.
func (m *ManagedDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "storageAccountType":
				err = unpopulate(val, "StorageAccountType", &m.StorageAccountType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MetadataItem.
func (m MetadataItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetadataItem.
func (m *MetadataItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &m.Name)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &m.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MountConfiguration.
func (m MountConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "azureBlobFileSystemConfiguration", m.AzureBlobFileSystemConfiguration)
	populate(objectMap, "azureFileShareConfiguration", m.AzureFileShareConfiguration)
	populate(objectMap, "cifsMountConfiguration", m.CifsMountConfiguration)
	populate(objectMap, "nfsMountConfiguration", m.NfsMountConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MountConfiguration.
func (m *MountConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "azureBlobFileSystemConfiguration":
				err = unpopulate(val, "AzureBlobFileSystemConfiguration", &m.AzureBlobFileSystemConfiguration)
			delete(rawMsg, key)
		case "azureFileShareConfiguration":
				err = unpopulate(val, "AzureFileShareConfiguration", &m.AzureFileShareConfiguration)
			delete(rawMsg, key)
		case "cifsMountConfiguration":
				err = unpopulate(val, "CifsMountConfiguration", &m.CifsMountConfiguration)
			delete(rawMsg, key)
		case "nfsMountConfiguration":
				err = unpopulate(val, "NfsMountConfiguration", &m.NfsMountConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MultiInstanceSettings.
func (m MultiInstanceSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "commonResourceFiles", m.CommonResourceFiles)
	populate(objectMap, "coordinationCommandLine", m.CoordinationCommandLine)
	populate(objectMap, "numberOfInstances", m.NumberOfInstances)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultiInstanceSettings.
func (m *MultiInstanceSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", m, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commonResourceFiles":
				err = unpopulate(val, "CommonResourceFiles", &m.CommonResourceFiles)
			delete(rawMsg, key)
		case "coordinationCommandLine":
				err = unpopulate(val, "CoordinationCommandLine", &m.CoordinationCommandLine)
			delete(rawMsg, key)
		case "numberOfInstances":
				err = unpopulate(val, "NumberOfInstances", &m.NumberOfInstances)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", m, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NameValuePair.
func (n NameValuePair) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NameValuePair.
func (n *NameValuePair) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &n.Name)
			delete(rawMsg, key)
		case "value":
				err = unpopulate(val, "Value", &n.Value)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkConfiguration.
func (n NetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "dynamicVNetAssignmentScope", n.DynamicVNetAssignmentScope)
	populate(objectMap, "enableAcceleratedNetworking", n.EnableAcceleratedNetworking)
	populate(objectMap, "endpointConfiguration", n.EndpointConfiguration)
	populate(objectMap, "publicIPAddressConfiguration", n.PublicIPAddressConfiguration)
	populate(objectMap, "subnetId", n.SubnetID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkConfiguration.
func (n *NetworkConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dynamicVNetAssignmentScope":
				err = unpopulate(val, "DynamicVNetAssignmentScope", &n.DynamicVNetAssignmentScope)
			delete(rawMsg, key)
		case "enableAcceleratedNetworking":
				err = unpopulate(val, "EnableAcceleratedNetworking", &n.EnableAcceleratedNetworking)
			delete(rawMsg, key)
		case "endpointConfiguration":
				err = unpopulate(val, "EndpointConfiguration", &n.EndpointConfiguration)
			delete(rawMsg, key)
		case "publicIPAddressConfiguration":
				err = unpopulate(val, "PublicIPAddressConfiguration", &n.PublicIPAddressConfiguration)
			delete(rawMsg, key)
		case "subnetId":
				err = unpopulate(val, "SubnetID", &n.SubnetID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSecurityGroupRule.
func (n NetworkSecurityGroupRule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "access", n.Access)
	populate(objectMap, "priority", n.Priority)
	populate(objectMap, "sourceAddressPrefix", n.SourceAddressPrefix)
	populate(objectMap, "sourcePortRanges", n.SourcePortRanges)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkSecurityGroupRule.
func (n *NetworkSecurityGroupRule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "access":
				err = unpopulate(val, "Access", &n.Access)
			delete(rawMsg, key)
		case "priority":
				err = unpopulate(val, "Priority", &n.Priority)
			delete(rawMsg, key)
		case "sourceAddressPrefix":
				err = unpopulate(val, "SourceAddressPrefix", &n.SourceAddressPrefix)
			delete(rawMsg, key)
		case "sourcePortRanges":
				err = unpopulate(val, "SourcePortRanges", &n.SourcePortRanges)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NfsMountConfiguration.
func (n NfsMountConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "mountOptions", n.MountOptions)
	populate(objectMap, "relativeMountPath", n.RelativeMountPath)
	populate(objectMap, "source", n.Source)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NfsMountConfiguration.
func (n *NfsMountConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", n, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "mountOptions":
				err = unpopulate(val, "MountOptions", &n.MountOptions)
			delete(rawMsg, key)
		case "relativeMountPath":
				err = unpopulate(val, "RelativeMountPath", &n.RelativeMountPath)
			delete(rawMsg, key)
		case "source":
				err = unpopulate(val, "Source", &n.Source)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", n, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OSDisk.
func (o OSDisk) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "caching", o.Caching)
	populate(objectMap, "diskSizeGB", o.DiskSizeGB)
	populate(objectMap, "ephemeralOSDiskSettings", o.EphemeralOSDiskSettings)
	populate(objectMap, "managedDisk", o.ManagedDisk)
	populate(objectMap, "writeAcceleratorEnabled", o.WriteAcceleratorEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OSDisk.
func (o *OSDisk) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "caching":
				err = unpopulate(val, "Caching", &o.Caching)
			delete(rawMsg, key)
		case "diskSizeGB":
				err = unpopulate(val, "DiskSizeGB", &o.DiskSizeGB)
			delete(rawMsg, key)
		case "ephemeralOSDiskSettings":
				err = unpopulate(val, "EphemeralOSDiskSettings", &o.EphemeralOSDiskSettings)
			delete(rawMsg, key)
		case "managedDisk":
				err = unpopulate(val, "ManagedDisk", &o.ManagedDisk)
			delete(rawMsg, key)
		case "writeAcceleratorEnabled":
				err = unpopulate(val, "WriteAcceleratorEnabled", &o.WriteAcceleratorEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFile.
func (o OutputFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "destination", o.Destination)
	populate(objectMap, "filePattern", o.FilePattern)
	populate(objectMap, "uploadOptions", o.UploadOptions)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFile.
func (o *OutputFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				err = unpopulate(val, "Destination", &o.Destination)
			delete(rawMsg, key)
		case "filePattern":
				err = unpopulate(val, "FilePattern", &o.FilePattern)
			delete(rawMsg, key)
		case "uploadOptions":
				err = unpopulate(val, "UploadOptions", &o.UploadOptions)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFileBlobContainerDestination.
func (o OutputFileBlobContainerDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerUrl", o.ContainerURL)
	populate(objectMap, "identityReference", o.IdentityReference)
	populate(objectMap, "path", o.Path)
	populate(objectMap, "uploadHeaders", o.UploadHeaders)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFileBlobContainerDestination.
func (o *OutputFileBlobContainerDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerUrl":
				err = unpopulate(val, "ContainerURL", &o.ContainerURL)
			delete(rawMsg, key)
		case "identityReference":
				err = unpopulate(val, "IdentityReference", &o.IdentityReference)
			delete(rawMsg, key)
		case "path":
				err = unpopulate(val, "Path", &o.Path)
			delete(rawMsg, key)
		case "uploadHeaders":
				err = unpopulate(val, "UploadHeaders", &o.UploadHeaders)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFileDestination.
func (o OutputFileDestination) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "container", o.Container)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFileDestination.
func (o *OutputFileDestination) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "container":
				err = unpopulate(val, "Container", &o.Container)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type OutputFileUploadConfig.
func (o OutputFileUploadConfig) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "uploadCondition", o.UploadCondition)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OutputFileUploadConfig.
func (o *OutputFileUploadConfig) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", o, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "uploadCondition":
				err = unpopulate(val, "UploadCondition", &o.UploadCondition)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", o, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PublicIPAddressConfiguration.
func (p PublicIPAddressConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "ipAddressIds", p.IPAddressIDs)
	populate(objectMap, "provision", p.IPAddressProvisioningType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PublicIPAddressConfiguration.
func (p *PublicIPAddressConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", p, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "ipAddressIds":
				err = unpopulate(val, "IPAddressIDs", &p.IPAddressIDs)
			delete(rawMsg, key)
		case "provision":
				err = unpopulate(val, "IPAddressProvisioningType", &p.IPAddressProvisioningType)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", p, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RecentBatchJob.
func (r RecentBatchJob) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "url", r.URL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RecentBatchJob.
func (r *RecentBatchJob) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &r.ID)
			delete(rawMsg, key)
		case "url":
				err = unpopulate(val, "URL", &r.URL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResizeError.
func (r ResizeError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "code", r.Code)
	populate(objectMap, "message", r.Message)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResizeError.
func (r *ResizeError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
				err = unpopulate(val, "Code", &r.Code)
			delete(rawMsg, key)
		case "message":
				err = unpopulate(val, "Message", &r.Message)
			delete(rawMsg, key)
		case "values":
				err = unpopulate(val, "Values", &r.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourceFile.
func (r ResourceFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoStorageContainerName", r.AutoStorageContainerName)
	populate(objectMap, "blobPrefix", r.BlobPrefix)
	populate(objectMap, "fileMode", r.FileMode)
	populate(objectMap, "filePath", r.FilePath)
	populate(objectMap, "httpUrl", r.HTTPURL)
	populate(objectMap, "identityReference", r.IdentityReference)
	populate(objectMap, "storageContainerUrl", r.StorageContainerURL)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceFile.
func (r *ResourceFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoStorageContainerName":
				err = unpopulate(val, "AutoStorageContainerName", &r.AutoStorageContainerName)
			delete(rawMsg, key)
		case "blobPrefix":
				err = unpopulate(val, "BlobPrefix", &r.BlobPrefix)
			delete(rawMsg, key)
		case "fileMode":
				err = unpopulate(val, "FileMode", &r.FileMode)
			delete(rawMsg, key)
		case "filePath":
				err = unpopulate(val, "FilePath", &r.FilePath)
			delete(rawMsg, key)
		case "httpUrl":
				err = unpopulate(val, "HTTPURL", &r.HTTPURL)
			delete(rawMsg, key)
		case "identityReference":
				err = unpopulate(val, "IdentityReference", &r.IdentityReference)
			delete(rawMsg, key)
		case "storageContainerUrl":
				err = unpopulate(val, "StorageContainerURL", &r.StorageContainerURL)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type RollingUpgradePolicy.
func (r RollingUpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableCrossZoneUpgrade", r.EnableCrossZoneUpgrade)
	populate(objectMap, "maxBatchInstancePercent", r.MaxBatchInstancePercent)
	populate(objectMap, "maxUnhealthyInstancePercent", r.MaxUnhealthyInstancePercent)
	populate(objectMap, "maxUnhealthyUpgradedInstancePercent", r.MaxUnhealthyUpgradedInstancePercent)
	populate(objectMap, "pauseTimeBetweenBatches", r.PauseTimeBetweenBatches)
	populate(objectMap, "prioritizeUnhealthyInstances", r.PrioritizeUnhealthyInstances)
	populate(objectMap, "rollbackFailedInstancesOnPolicyBreach", r.RollbackFailedInstancesOnPolicyBreach)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RollingUpgradePolicy.
func (r *RollingUpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", r, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableCrossZoneUpgrade":
				err = unpopulate(val, "EnableCrossZoneUpgrade", &r.EnableCrossZoneUpgrade)
			delete(rawMsg, key)
		case "maxBatchInstancePercent":
				err = unpopulate(val, "MaxBatchInstancePercent", &r.MaxBatchInstancePercent)
			delete(rawMsg, key)
		case "maxUnhealthyInstancePercent":
				err = unpopulate(val, "MaxUnhealthyInstancePercent", &r.MaxUnhealthyInstancePercent)
			delete(rawMsg, key)
		case "maxUnhealthyUpgradedInstancePercent":
				err = unpopulate(val, "MaxUnhealthyUpgradedInstancePercent", &r.MaxUnhealthyUpgradedInstancePercent)
			delete(rawMsg, key)
		case "pauseTimeBetweenBatches":
				err = unpopulate(val, "PauseTimeBetweenBatches", &r.PauseTimeBetweenBatches)
			delete(rawMsg, key)
		case "prioritizeUnhealthyInstances":
				err = unpopulate(val, "PrioritizeUnhealthyInstances", &r.PrioritizeUnhealthyInstances)
			delete(rawMsg, key)
		case "rollbackFailedInstancesOnPolicyBreach":
				err = unpopulate(val, "RollbackFailedInstancesOnPolicyBreach", &r.RollbackFailedInstancesOnPolicyBreach)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", r, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SecurityProfile.
func (s SecurityProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "encryptionAtHost", s.EncryptionAtHost)
	populate(objectMap, "securityType", s.SecurityType)
	populate(objectMap, "uefiSettings", s.UefiSettings)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecurityProfile.
func (s *SecurityProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptionAtHost":
				err = unpopulate(val, "EncryptionAtHost", &s.EncryptionAtHost)
			delete(rawMsg, key)
		case "securityType":
				err = unpopulate(val, "SecurityType", &s.SecurityType)
			delete(rawMsg, key)
		case "uefiSettings":
				err = unpopulate(val, "UefiSettings", &s.UefiSettings)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ServiceArtifactReference.
func (s ServiceArtifactReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "id", s.ID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ServiceArtifactReference.
func (s *ServiceArtifactReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", s, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, "ID", &s.ID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", s, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UefiSettings.
func (u UefiSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "secureBootEnabled", u.SecureBootEnabled)
	populate(objectMap, "vTpmEnabled", u.VTpmEnabled)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UefiSettings.
func (u *UefiSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "secureBootEnabled":
				err = unpopulate(val, "SecureBootEnabled", &u.SecureBootEnabled)
			delete(rawMsg, key)
		case "vTpmEnabled":
				err = unpopulate(val, "VTpmEnabled", &u.VTpmEnabled)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UpgradePolicy.
func (u UpgradePolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "automaticOsUpgradePolicy", u.AutomaticOSUpgradePolicy)
	populate(objectMap, "mode", u.Mode)
	populate(objectMap, "rollingUpgradePolicy", u.RollingUpgradePolicy)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpgradePolicy.
func (u *UpgradePolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "automaticOsUpgradePolicy":
				err = unpopulate(val, "AutomaticOSUpgradePolicy", &u.AutomaticOSUpgradePolicy)
			delete(rawMsg, key)
		case "mode":
				err = unpopulate(val, "Mode", &u.Mode)
			delete(rawMsg, key)
		case "rollingUpgradePolicy":
				err = unpopulate(val, "RollingUpgradePolicy", &u.RollingUpgradePolicy)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UploadBatchServiceLogsContent.
func (u UploadBatchServiceLogsContent) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerUrl", u.ContainerURL)
	populateDateTimeRFC3339(objectMap, "endTime", u.EndTime)
	populate(objectMap, "identityReference", u.IdentityReference)
	populateDateTimeRFC3339(objectMap, "startTime", u.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadBatchServiceLogsContent.
func (u *UploadBatchServiceLogsContent) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerUrl":
				err = unpopulate(val, "ContainerURL", &u.ContainerURL)
			delete(rawMsg, key)
		case "endTime":
				err = unpopulateDateTimeRFC3339(val, "EndTime", &u.EndTime)
			delete(rawMsg, key)
		case "identityReference":
				err = unpopulate(val, "IdentityReference", &u.IdentityReference)
			delete(rawMsg, key)
		case "startTime":
				err = unpopulateDateTimeRFC3339(val, "StartTime", &u.StartTime)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UploadBatchServiceLogsResult.
func (u UploadBatchServiceLogsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "numberOfFilesUploaded", u.NumberOfFilesUploaded)
	populate(objectMap, "virtualDirectoryName", u.VirtualDirectoryName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadBatchServiceLogsResult.
func (u *UploadBatchServiceLogsResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "numberOfFilesUploaded":
				err = unpopulate(val, "NumberOfFilesUploaded", &u.NumberOfFilesUploaded)
			delete(rawMsg, key)
		case "virtualDirectoryName":
				err = unpopulate(val, "VirtualDirectoryName", &u.VirtualDirectoryName)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAccount.
func (u UserAccount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "elevationLevel", u.ElevationLevel)
	populate(objectMap, "linuxUserConfiguration", u.LinuxUserConfiguration)
	populate(objectMap, "name", u.Name)
	populate(objectMap, "password", u.Password)
	populate(objectMap, "windowsUserConfiguration", u.WindowsUserConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAccount.
func (u *UserAccount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "elevationLevel":
				err = unpopulate(val, "ElevationLevel", &u.ElevationLevel)
			delete(rawMsg, key)
		case "linuxUserConfiguration":
				err = unpopulate(val, "LinuxUserConfiguration", &u.LinuxUserConfiguration)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &u.Name)
			delete(rawMsg, key)
		case "password":
				err = unpopulate(val, "Password", &u.Password)
			delete(rawMsg, key)
		case "windowsUserConfiguration":
				err = unpopulate(val, "WindowsUserConfiguration", &u.WindowsUserConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserAssignedIdentity.
func (u UserAssignedIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "clientId", u.ClientID)
	populate(objectMap, "principalId", u.PrincipalID)
	populate(objectMap, "resourceId", u.ResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserAssignedIdentity.
func (u *UserAssignedIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientId":
				err = unpopulate(val, "ClientID", &u.ClientID)
			delete(rawMsg, key)
		case "principalId":
				err = unpopulate(val, "PrincipalID", &u.PrincipalID)
			delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, "ResourceID", &u.ResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type UserIdentity.
func (u UserIdentity) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUser", u.AutoUser)
	populate(objectMap, "username", u.Username)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UserIdentity.
func (u *UserIdentity) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", u, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUser":
				err = unpopulate(val, "AutoUser", &u.AutoUser)
			delete(rawMsg, key)
		case "username":
				err = unpopulate(val, "Username", &u.Username)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", u, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMExtension.
func (v VMExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "autoUpgradeMinorVersion", v.AutoUpgradeMinorVersion)
	populate(objectMap, "enableAutomaticUpgrade", v.EnableAutomaticUpgrade)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "protectedSettings", v.ProtectedSettings)
	populate(objectMap, "provisionAfterExtensions", v.ProvisionAfterExtensions)
	populate(objectMap, "publisher", v.Publisher)
	populate(objectMap, "settings", v.Settings)
	populate(objectMap, "type", v.Type)
	populate(objectMap, "typeHandlerVersion", v.TypeHandlerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMExtension.
func (v *VMExtension) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "autoUpgradeMinorVersion":
				err = unpopulate(val, "AutoUpgradeMinorVersion", &v.AutoUpgradeMinorVersion)
			delete(rawMsg, key)
		case "enableAutomaticUpgrade":
				err = unpopulate(val, "EnableAutomaticUpgrade", &v.EnableAutomaticUpgrade)
			delete(rawMsg, key)
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "protectedSettings":
				err = unpopulate(val, "ProtectedSettings", &v.ProtectedSettings)
			delete(rawMsg, key)
		case "provisionAfterExtensions":
				err = unpopulate(val, "ProvisionAfterExtensions", &v.ProvisionAfterExtensions)
			delete(rawMsg, key)
		case "publisher":
				err = unpopulate(val, "Publisher", &v.Publisher)
			delete(rawMsg, key)
		case "settings":
				err = unpopulate(val, "Settings", &v.Settings)
			delete(rawMsg, key)
		case "type":
				err = unpopulate(val, "Type", &v.Type)
			delete(rawMsg, key)
		case "typeHandlerVersion":
				err = unpopulate(val, "TypeHandlerVersion", &v.TypeHandlerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VMExtensionInstanceView.
func (v VMExtensionInstanceView) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "subStatuses", v.SubStatuses)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VMExtensionInstanceView.
func (v *VMExtensionInstanceView) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "name":
				err = unpopulate(val, "Name", &v.Name)
			delete(rawMsg, key)
		case "statuses":
				err = unpopulate(val, "Statuses", &v.Statuses)
			delete(rawMsg, key)
		case "subStatuses":
				err = unpopulate(val, "SubStatuses", &v.SubStatuses)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineConfiguration.
func (v VirtualMachineConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "containerConfiguration", v.ContainerConfiguration)
	populate(objectMap, "dataDisks", v.DataDisks)
	populate(objectMap, "diskEncryptionConfiguration", v.DiskEncryptionConfiguration)
	populate(objectMap, "extensions", v.Extensions)
	populate(objectMap, "imageReference", v.ImageReference)
	populate(objectMap, "licenseType", v.LicenseType)
	populate(objectMap, "nodeAgentSKUId", v.NodeAgentSKUID)
	populate(objectMap, "nodePlacementConfiguration", v.NodePlacementConfiguration)
	populate(objectMap, "osDisk", v.OSDisk)
	populate(objectMap, "securityProfile", v.SecurityProfile)
	populate(objectMap, "serviceArtifactReference", v.ServiceArtifactReference)
	populate(objectMap, "windowsConfiguration", v.WindowsConfiguration)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineConfiguration.
func (v *VirtualMachineConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "containerConfiguration":
				err = unpopulate(val, "ContainerConfiguration", &v.ContainerConfiguration)
			delete(rawMsg, key)
		case "dataDisks":
				err = unpopulate(val, "DataDisks", &v.DataDisks)
			delete(rawMsg, key)
		case "diskEncryptionConfiguration":
				err = unpopulate(val, "DiskEncryptionConfiguration", &v.DiskEncryptionConfiguration)
			delete(rawMsg, key)
		case "extensions":
				err = unpopulate(val, "Extensions", &v.Extensions)
			delete(rawMsg, key)
		case "imageReference":
				err = unpopulate(val, "ImageReference", &v.ImageReference)
			delete(rawMsg, key)
		case "licenseType":
				err = unpopulate(val, "LicenseType", &v.LicenseType)
			delete(rawMsg, key)
		case "nodeAgentSKUId":
				err = unpopulate(val, "NodeAgentSKUID", &v.NodeAgentSKUID)
			delete(rawMsg, key)
		case "nodePlacementConfiguration":
				err = unpopulate(val, "NodePlacementConfiguration", &v.NodePlacementConfiguration)
			delete(rawMsg, key)
		case "osDisk":
				err = unpopulate(val, "OSDisk", &v.OSDisk)
			delete(rawMsg, key)
		case "securityProfile":
				err = unpopulate(val, "SecurityProfile", &v.SecurityProfile)
			delete(rawMsg, key)
		case "serviceArtifactReference":
				err = unpopulate(val, "ServiceArtifactReference", &v.ServiceArtifactReference)
			delete(rawMsg, key)
		case "windowsConfiguration":
				err = unpopulate(val, "WindowsConfiguration", &v.WindowsConfiguration)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineInfo.
func (v VirtualMachineInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "imageReference", v.ImageReference)
	populate(objectMap, "scaleSetVmResourceId", v.ScaleSetVMResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineInfo.
func (v *VirtualMachineInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", v, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "imageReference":
				err = unpopulate(val, "ImageReference", &v.ImageReference)
			delete(rawMsg, key)
		case "scaleSetVmResourceId":
				err = unpopulate(val, "ScaleSetVMResourceID", &v.ScaleSetVMResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", v, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsConfiguration.
func (w WindowsConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "enableAutomaticUpdates", w.EnableAutomaticUpdates)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsConfiguration.
func (w *WindowsConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "enableAutomaticUpdates":
				err = unpopulate(val, "EnableAutomaticUpdates", &w.EnableAutomaticUpdates)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type WindowsUserConfiguration.
func (w WindowsUserConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]any)
	populate(objectMap, "loginMode", w.LoginMode)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type WindowsUserConfiguration.
func (w *WindowsUserConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return fmt.Errorf("unmarshalling type %T: %v", w, err)
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "loginMode":
				err = unpopulate(val, "LoginMode", &w.LoginMode)
			delete(rawMsg, key)
		}
		if err != nil {
			return fmt.Errorf("unmarshalling type %T: %v", w, err)
		}
	}
	return nil
}

func populate(m map[string]any, k string, v any) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, fn string, v any) error {
	if data == nil || string(data) == "null" {
		return nil
	}
	if err := json.Unmarshal(data, v); err != nil {
		return fmt.Errorf("struct field %s: %v", fn, err)
	}
	return nil
}

