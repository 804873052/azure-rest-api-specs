// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Go Code Generator. DO NOT EDIT.

package armbatch

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// BatchApiClient contains the methods for the Azure.Batch namespace.
// Don't use this type directly, use [BatchClient.NewBatchApiClient] instead.
type BatchApiClient struct {
	internal *azcore.Client
	endpoint string
}

// CancelCertificateDeletion - Cancels a failed deletion of a Certificate from the specified Account.
//   - thumbprintAlgorithm - The algorithm used to derive the thumbprint parameter. This must be sha1.
//   - thumbprint - The thumbprint of the Certificate being deleted.
//   - options - BatchApiClientCancelCertificateDeletionOptions contains the optional parameters for the BatchApiClient.CancelCertificateDeletion
//     method.
func (client *BatchApiClient) CancelCertificateDeletion(ctx context.Context, thumbprintAlgorithm string, thumbprint string, options *BatchApiClientCancelCertificateDeletionOptions) (BatchApiClientCancelCertificateDeletionResponse, error) {
	var err error
	req, err := client.cancelCertificateDeletionCreateRequest(ctx, thumbprintAlgorithm, thumbprint, options)
	if err != nil {
		return BatchApiClientCancelCertificateDeletionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCancelCertificateDeletionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCancelCertificateDeletionResponse{}, err
	}
	resp, err := client.cancelCertificateDeletionHandleResponse(httpResp)
	return resp, err
}

// cancelCertificateDeletionCreateRequest creates the CancelCertificateDeletion request.
func (client *BatchApiClient) cancelCertificateDeletionCreateRequest(ctx context.Context, thumbprintAlgorithm string, thumbprint string, options *BatchApiClientCancelCertificateDeletionOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})/canceldelete"
	if thumbprintAlgorithm == "" {
		return nil, errors.New("parameter thumbprintAlgorithm cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{thumbprintAlgorithm}", url.PathEscape(thumbprintAlgorithm))
	if thumbprint == "" {
		return nil, errors.New("parameter thumbprint cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{thumbprint}", url.PathEscape(thumbprint))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// cancelCertificateDeletionHandleResponse handles the CancelCertificateDeletion response.
func (client *BatchApiClient) cancelCertificateDeletionHandleResponse(resp *http.Response) (BatchApiClientCancelCertificateDeletionResponse, error) {
	result := BatchApiClientCancelCertificateDeletionResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCancelCertificateDeletionResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateCertificate - Creates a Certificate to the specified Account.
//   - certificate - The Certificate to be created.
//   - options - BatchApiClientCreateCertificateOptions contains the optional parameters for the BatchApiClient.CreateCertificate
//     method.
func (client *BatchApiClient) CreateCertificate(ctx context.Context, certificate BatchCertificate, options *BatchApiClientCreateCertificateOptions) (BatchApiClientCreateCertificateResponse, error) {
	var err error
	req, err := client.createCertificateCreateRequest(ctx, certificate, options)
	if err != nil {
		return BatchApiClientCreateCertificateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreateCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreateCertificateResponse{}, err
	}
	resp, err := client.createCertificateHandleResponse(httpResp)
	return resp, err
}

// createCertificateCreateRequest creates the CreateCertificate request.
func (client *BatchApiClient) createCertificateCreateRequest(ctx context.Context, certificate BatchCertificate, options *BatchApiClientCreateCertificateOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/certificates"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, certificate); err != nil {
	return nil, err
}
	return req, nil
}

// createCertificateHandleResponse handles the CreateCertificate response.
func (client *BatchApiClient) createCertificateHandleResponse(resp *http.Response) (BatchApiClientCreateCertificateResponse, error) {
	result := BatchApiClientCreateCertificateResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreateCertificateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateJob - Creates a Job to the specified Account.
//   - job - The Job to be created.
//   - options - BatchApiClientCreateJobOptions contains the optional parameters for the BatchApiClient.CreateJob method.
func (client *BatchApiClient) CreateJob(ctx context.Context, job BatchJobCreateContent, options *BatchApiClientCreateJobOptions) (BatchApiClientCreateJobResponse, error) {
	var err error
	req, err := client.createJobCreateRequest(ctx, job, options)
	if err != nil {
		return BatchApiClientCreateJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreateJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreateJobResponse{}, err
	}
	resp, err := client.createJobHandleResponse(httpResp)
	return resp, err
}

// createJobCreateRequest creates the CreateJob request.
func (client *BatchApiClient) createJobCreateRequest(ctx context.Context, job BatchJobCreateContent, options *BatchApiClientCreateJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, job); err != nil {
	return nil, err
}
	return req, nil
}

// createJobHandleResponse handles the CreateJob response.
func (client *BatchApiClient) createJobHandleResponse(resp *http.Response) (BatchApiClientCreateJobResponse, error) {
	result := BatchApiClientCreateJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreateJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateJobSchedule - Creates a Job Schedule to the specified Account.
//   - jobSchedule - The Job Schedule to be created.
//   - options - BatchApiClientCreateJobScheduleOptions contains the optional parameters for the BatchApiClient.CreateJobSchedule
//     method.
func (client *BatchApiClient) CreateJobSchedule(ctx context.Context, jobSchedule BatchJobScheduleCreateContent, options *BatchApiClientCreateJobScheduleOptions) (BatchApiClientCreateJobScheduleResponse, error) {
	var err error
	req, err := client.createJobScheduleCreateRequest(ctx, jobSchedule, options)
	if err != nil {
		return BatchApiClientCreateJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreateJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreateJobScheduleResponse{}, err
	}
	resp, err := client.createJobScheduleHandleResponse(httpResp)
	return resp, err
}

// createJobScheduleCreateRequest creates the CreateJobSchedule request.
func (client *BatchApiClient) createJobScheduleCreateRequest(ctx context.Context, jobSchedule BatchJobScheduleCreateContent, options *BatchApiClientCreateJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, jobSchedule); err != nil {
	return nil, err
}
	return req, nil
}

// createJobScheduleHandleResponse handles the CreateJobSchedule response.
func (client *BatchApiClient) createJobScheduleHandleResponse(resp *http.Response) (BatchApiClientCreateJobScheduleResponse, error) {
	result := BatchApiClientCreateJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreateJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateNodeUser - Adds a user Account to the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the machine on which you want to create a user Account.
//   - userParam - The options to use for creating the user.
//   - options - BatchApiClientCreateNodeUserOptions contains the optional parameters for the BatchApiClient.CreateNodeUser method.
func (client *BatchApiClient) CreateNodeUser(ctx context.Context, poolID string, nodeID string, userParam BatchNodeUserCreateContent, options *BatchApiClientCreateNodeUserOptions) (BatchApiClientCreateNodeUserResponse, error) {
	var err error
	req, err := client.createNodeUserCreateRequest(ctx, poolID, nodeID, userParam, options)
	if err != nil {
		return BatchApiClientCreateNodeUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreateNodeUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreateNodeUserResponse{}, err
	}
	resp, err := client.createNodeUserHandleResponse(httpResp)
	return resp, err
}

// createNodeUserCreateRequest creates the CreateNodeUser request.
func (client *BatchApiClient) createNodeUserCreateRequest(ctx context.Context, poolID string, nodeID string, userParam BatchNodeUserCreateContent, options *BatchApiClientCreateNodeUserOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/users"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, userParam); err != nil {
	return nil, err
}
	return req, nil
}

// createNodeUserHandleResponse handles the CreateNodeUser response.
func (client *BatchApiClient) createNodeUserHandleResponse(resp *http.Response) (BatchApiClientCreateNodeUserResponse, error) {
	result := BatchApiClientCreateNodeUserResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreateNodeUserResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreatePool - Creates a Pool to the specified Account.
//   - pool - The Pool to be created.
//   - options - BatchApiClientCreatePoolOptions contains the optional parameters for the BatchApiClient.CreatePool method.
func (client *BatchApiClient) CreatePool(ctx context.Context, pool BatchPoolCreateContent, options *BatchApiClientCreatePoolOptions) (BatchApiClientCreatePoolResponse, error) {
	var err error
	req, err := client.createPoolCreateRequest(ctx, pool, options)
	if err != nil {
		return BatchApiClientCreatePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreatePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreatePoolResponse{}, err
	}
	resp, err := client.createPoolHandleResponse(httpResp)
	return resp, err
}

// createPoolCreateRequest creates the CreatePool request.
func (client *BatchApiClient) createPoolCreateRequest(ctx context.Context, pool BatchPoolCreateContent, options *BatchApiClientCreatePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools"
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, pool); err != nil {
	return nil, err
}
	return req, nil
}

// createPoolHandleResponse handles the CreatePool response.
func (client *BatchApiClient) createPoolHandleResponse(resp *http.Response) (BatchApiClientCreatePoolResponse, error) {
	result := BatchApiClientCreatePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreatePoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateTask - Creates a Task to the specified Job.
//   - jobID - The ID of the Job to which the Task is to be created.
//   - task - The Task to be created.
//   - options - BatchApiClientCreateTaskOptions contains the optional parameters for the BatchApiClient.CreateTask method.
func (client *BatchApiClient) CreateTask(ctx context.Context, jobID string, task BatchTaskCreateContent, options *BatchApiClientCreateTaskOptions) (BatchApiClientCreateTaskResponse, error) {
	var err error
	req, err := client.createTaskCreateRequest(ctx, jobID, task, options)
	if err != nil {
		return BatchApiClientCreateTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreateTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusCreated) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreateTaskResponse{}, err
	}
	resp, err := client.createTaskHandleResponse(httpResp)
	return resp, err
}

// createTaskCreateRequest creates the CreateTask request.
func (client *BatchApiClient) createTaskCreateRequest(ctx context.Context, jobID string, task BatchTaskCreateContent, options *BatchApiClientCreateTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, task); err != nil {
	return nil, err
}
	return req, nil
}

// createTaskHandleResponse handles the CreateTask response.
func (client *BatchApiClient) createTaskHandleResponse(resp *http.Response) (BatchApiClientCreateTaskResponse, error) {
	result := BatchApiClientCreateTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreateTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// CreateTaskCollection - Adds a collection of Tasks to the specified Job.
//   - jobID - The ID of the Job to which the Task collection is to be added.
//   - taskCollection - The Tasks to be added.
//   - options - BatchApiClientCreateTaskCollectionOptions contains the optional parameters for the BatchApiClient.CreateTaskCollection
//     method.
func (client *BatchApiClient) CreateTaskCollection(ctx context.Context, jobID string, taskCollection BatchTaskGroup, options *BatchApiClientCreateTaskCollectionOptions) (BatchApiClientCreateTaskCollectionResponse, error) {
	var err error
	req, err := client.createTaskCollectionCreateRequest(ctx, jobID, taskCollection, options)
	if err != nil {
		return BatchApiClientCreateTaskCollectionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientCreateTaskCollectionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientCreateTaskCollectionResponse{}, err
	}
	resp, err := client.createTaskCollectionHandleResponse(httpResp)
	return resp, err
}

// createTaskCollectionCreateRequest creates the CreateTaskCollection request.
func (client *BatchApiClient) createTaskCollectionCreateRequest(ctx context.Context, jobID string, taskCollection BatchTaskGroup, options *BatchApiClientCreateTaskCollectionOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/addtaskcollection"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, taskCollection); err != nil {
	return nil, err
}
	return req, nil
}

// createTaskCollectionHandleResponse handles the CreateTaskCollection response.
func (client *BatchApiClient) createTaskCollectionHandleResponse(resp *http.Response) (BatchApiClientCreateTaskCollectionResponse, error) {
	result := BatchApiClientCreateTaskCollectionResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientCreateTaskCollectionResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchTaskAddCollectionResult); err != nil {
		return BatchApiClientCreateTaskCollectionResponse{}, err
	}
	return result, nil
}

// DeleteCertificate - Deletes a Certificate from the specified Account.
//   - thumbprintAlgorithm - The algorithm used to derive the thumbprint parameter. This must be sha1.
//   - thumbprint - The thumbprint of the Certificate to be deleted.
//   - options - BatchApiClientDeleteCertificateOptions contains the optional parameters for the BatchApiClient.DeleteCertificate
//     method.
func (client *BatchApiClient) DeleteCertificate(ctx context.Context, thumbprintAlgorithm string, thumbprint string, options *BatchApiClientDeleteCertificateOptions) (BatchApiClientDeleteCertificateResponse, error) {
	var err error
	req, err := client.deleteCertificateCreateRequest(ctx, thumbprintAlgorithm, thumbprint, options)
	if err != nil {
		return BatchApiClientDeleteCertificateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteCertificateResponse{}, err
	}
	resp, err := client.deleteCertificateHandleResponse(httpResp)
	return resp, err
}

// deleteCertificateCreateRequest creates the DeleteCertificate request.
func (client *BatchApiClient) deleteCertificateCreateRequest(ctx context.Context, thumbprintAlgorithm string, thumbprint string, options *BatchApiClientDeleteCertificateOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})"
	if thumbprintAlgorithm == "" {
		return nil, errors.New("parameter thumbprintAlgorithm cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{thumbprintAlgorithm}", url.PathEscape(thumbprintAlgorithm))
	if thumbprint == "" {
		return nil, errors.New("parameter thumbprint cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{thumbprint}", url.PathEscape(thumbprint))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteCertificateHandleResponse handles the DeleteCertificate response.
func (client *BatchApiClient) deleteCertificateHandleResponse(resp *http.Response) (BatchApiClientDeleteCertificateResponse, error) {
	result := BatchApiClientDeleteCertificateResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientDeleteCertificateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteJob - Deletes a Job.
//   - jobID - The ID of the Job to delete.
//   - options - BatchApiClientDeleteJobOptions contains the optional parameters for the BatchApiClient.DeleteJob method.
func (client *BatchApiClient) DeleteJob(ctx context.Context, jobID string, options *BatchApiClientDeleteJobOptions) (BatchApiClientDeleteJobResponse, error) {
	var err error
	req, err := client.deleteJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return BatchApiClientDeleteJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteJobResponse{}, err
	}
	resp, err := client.deleteJobHandleResponse(httpResp)
	return resp, err
}

// deleteJobCreateRequest creates the DeleteJob request.
func (client *BatchApiClient) deleteJobCreateRequest(ctx context.Context, jobID string, options *BatchApiClientDeleteJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteJobHandleResponse handles the DeleteJob response.
func (client *BatchApiClient) deleteJobHandleResponse(resp *http.Response) (BatchApiClientDeleteJobResponse, error) {
	result := BatchApiClientDeleteJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteJobSchedule - Deletes a Job Schedule from the specified Account.
//   - jobScheduleID - The ID of the Job Schedule to delete.
//   - options - BatchApiClientDeleteJobScheduleOptions contains the optional parameters for the BatchApiClient.DeleteJobSchedule
//     method.
func (client *BatchApiClient) DeleteJobSchedule(ctx context.Context, jobScheduleID string, options *BatchApiClientDeleteJobScheduleOptions) (BatchApiClientDeleteJobScheduleResponse, error) {
	var err error
	req, err := client.deleteJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return BatchApiClientDeleteJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteJobScheduleResponse{}, err
	}
	resp, err := client.deleteJobScheduleHandleResponse(httpResp)
	return resp, err
}

// deleteJobScheduleCreateRequest creates the DeleteJobSchedule request.
func (client *BatchApiClient) deleteJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientDeleteJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteJobScheduleHandleResponse handles the DeleteJobSchedule response.
func (client *BatchApiClient) deleteJobScheduleHandleResponse(resp *http.Response) (BatchApiClientDeleteJobScheduleResponse, error) {
	result := BatchApiClientDeleteJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteNodeFile - Deletes the specified file from the Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node.
//   - filePath - The path to the file or directory.
//   - options - BatchApiClientDeleteNodeFileOptions contains the optional parameters for the BatchApiClient.DeleteNodeFile method.
func (client *BatchApiClient) DeleteNodeFile(ctx context.Context, poolID string, nodeID string, filePath string, options *BatchApiClientDeleteNodeFileOptions) (BatchApiClientDeleteNodeFileResponse, error) {
	var err error
	req, err := client.deleteNodeFileCreateRequest(ctx, poolID, nodeID, filePath, options)
	if err != nil {
		return BatchApiClientDeleteNodeFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteNodeFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteNodeFileResponse{}, err
	}
	resp, err := client.deleteNodeFileHandleResponse(httpResp)
	return resp, err
}

// deleteNodeFileCreateRequest creates the DeleteNodeFile request.
func (client *BatchApiClient) deleteNodeFileCreateRequest(ctx context.Context, poolID string, nodeID string, filePath string, options *BatchApiClientDeleteNodeFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files/{filePath}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteNodeFileHandleResponse handles the DeleteNodeFile response.
func (client *BatchApiClient) deleteNodeFileHandleResponse(resp *http.Response) (BatchApiClientDeleteNodeFileResponse, error) {
	result := BatchApiClientDeleteNodeFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteNodeUser - Deletes a user Account from the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the machine on which you want to delete a user Account.
//   - userName - The name of the user Account to delete.
//   - options - BatchApiClientDeleteNodeUserOptions contains the optional parameters for the BatchApiClient.DeleteNodeUser method.
func (client *BatchApiClient) DeleteNodeUser(ctx context.Context, poolID string, nodeID string, userName string, options *BatchApiClientDeleteNodeUserOptions) (BatchApiClientDeleteNodeUserResponse, error) {
	var err error
	req, err := client.deleteNodeUserCreateRequest(ctx, poolID, nodeID, userName, options)
	if err != nil {
		return BatchApiClientDeleteNodeUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteNodeUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteNodeUserResponse{}, err
	}
	resp, err := client.deleteNodeUserHandleResponse(httpResp)
	return resp, err
}

// deleteNodeUserCreateRequest creates the DeleteNodeUser request.
func (client *BatchApiClient) deleteNodeUserCreateRequest(ctx context.Context, poolID string, nodeID string, userName string, options *BatchApiClientDeleteNodeUserOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/users/{userName}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if userName == "" {
		return nil, errors.New("parameter userName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userName}", url.PathEscape(userName))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteNodeUserHandleResponse handles the DeleteNodeUser response.
func (client *BatchApiClient) deleteNodeUserHandleResponse(resp *http.Response) (BatchApiClientDeleteNodeUserResponse, error) {
	result := BatchApiClientDeleteNodeUserResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeletePool - Deletes a Pool from the specified Account.
//   - poolID - The ID of the Pool to get.
//   - options - BatchApiClientDeletePoolOptions contains the optional parameters for the BatchApiClient.DeletePool method.
func (client *BatchApiClient) DeletePool(ctx context.Context, poolID string, options *BatchApiClientDeletePoolOptions) (BatchApiClientDeletePoolResponse, error) {
	var err error
	req, err := client.deletePoolCreateRequest(ctx, poolID, options)
	if err != nil {
		return BatchApiClientDeletePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeletePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeletePoolResponse{}, err
	}
	resp, err := client.deletePoolHandleResponse(httpResp)
	return resp, err
}

// deletePoolCreateRequest creates the DeletePool request.
func (client *BatchApiClient) deletePoolCreateRequest(ctx context.Context, poolID string, options *BatchApiClientDeletePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deletePoolHandleResponse handles the DeletePool response.
func (client *BatchApiClient) deletePoolHandleResponse(resp *http.Response) (BatchApiClientDeletePoolResponse, error) {
	result := BatchApiClientDeletePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteTask - Deletes a Task from the specified Job.
//   - jobID - The ID of the Job from which to delete the Task.
//   - taskID - The ID of the Task to delete.
//   - options - BatchApiClientDeleteTaskOptions contains the optional parameters for the BatchApiClient.DeleteTask method.
func (client *BatchApiClient) DeleteTask(ctx context.Context, jobID string, taskID string, options *BatchApiClientDeleteTaskOptions) (BatchApiClientDeleteTaskResponse, error) {
	var err error
	req, err := client.deleteTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return BatchApiClientDeleteTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteTaskResponse{}, err
	}
	resp, err := client.deleteTaskHandleResponse(httpResp)
	return resp, err
}

// deleteTaskCreateRequest creates the DeleteTask request.
func (client *BatchApiClient) deleteTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *BatchApiClientDeleteTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteTaskHandleResponse handles the DeleteTask response.
func (client *BatchApiClient) deleteTaskHandleResponse(resp *http.Response) (BatchApiClientDeleteTaskResponse, error) {
	result := BatchApiClientDeleteTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DeleteTaskFile - Deletes the specified Task file from the Compute Node where the Task ran.
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose file you want to retrieve.
//   - filePath - The path to the Task file that you want to get the content of.
//   - options - BatchApiClientDeleteTaskFileOptions contains the optional parameters for the BatchApiClient.DeleteTaskFile method.
func (client *BatchApiClient) DeleteTaskFile(ctx context.Context, jobID string, taskID string, filePath string, options *BatchApiClientDeleteTaskFileOptions) (BatchApiClientDeleteTaskFileResponse, error) {
	var err error
	req, err := client.deleteTaskFileCreateRequest(ctx, jobID, taskID, filePath, options)
	if err != nil {
		return BatchApiClientDeleteTaskFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDeleteTaskFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDeleteTaskFileResponse{}, err
	}
	resp, err := client.deleteTaskFileHandleResponse(httpResp)
	return resp, err
}

// deleteTaskFileCreateRequest creates the DeleteTaskFile request.
func (client *BatchApiClient) deleteTaskFileCreateRequest(ctx context.Context, jobID string, taskID string, filePath string, options *BatchApiClientDeleteTaskFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files/{filePath}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// deleteTaskFileHandleResponse handles the DeleteTaskFile response.
func (client *BatchApiClient) deleteTaskFileHandleResponse(resp *http.Response) (BatchApiClientDeleteTaskFileResponse, error) {
	result := BatchApiClientDeleteTaskFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisableJob - Disables the specified Job, preventing new Tasks from running.
//   - jobID - The ID of the Job to disable.
//   - content - The options to use for disabling the Job.
//   - options - BatchApiClientDisableJobOptions contains the optional parameters for the BatchApiClient.DisableJob method.
func (client *BatchApiClient) DisableJob(ctx context.Context, jobID string, content BatchJobDisableContent, options *BatchApiClientDisableJobOptions) (BatchApiClientDisableJobResponse, error) {
	var err error
	req, err := client.disableJobCreateRequest(ctx, jobID, content, options)
	if err != nil {
		return BatchApiClientDisableJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDisableJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDisableJobResponse{}, err
	}
	resp, err := client.disableJobHandleResponse(httpResp)
	return resp, err
}

// disableJobCreateRequest creates the DisableJob request.
func (client *BatchApiClient) disableJobCreateRequest(ctx context.Context, jobID string, content BatchJobDisableContent, options *BatchApiClientDisableJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/disable"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// disableJobHandleResponse handles the DisableJob response.
func (client *BatchApiClient) disableJobHandleResponse(resp *http.Response) (BatchApiClientDisableJobResponse, error) {
	result := BatchApiClientDisableJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientDisableJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisableJobSchedule - Disables a Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule to disable.
//   - options - BatchApiClientDisableJobScheduleOptions contains the optional parameters for the BatchApiClient.DisableJobSchedule
//     method.
func (client *BatchApiClient) DisableJobSchedule(ctx context.Context, jobScheduleID string, options *BatchApiClientDisableJobScheduleOptions) (BatchApiClientDisableJobScheduleResponse, error) {
	var err error
	req, err := client.disableJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return BatchApiClientDisableJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDisableJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDisableJobScheduleResponse{}, err
	}
	resp, err := client.disableJobScheduleHandleResponse(httpResp)
	return resp, err
}

// disableJobScheduleCreateRequest creates the DisableJobSchedule request.
func (client *BatchApiClient) disableJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientDisableJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/disable"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// disableJobScheduleHandleResponse handles the DisableJobSchedule response.
func (client *BatchApiClient) disableJobScheduleHandleResponse(resp *http.Response) (BatchApiClientDisableJobScheduleResponse, error) {
	result := BatchApiClientDisableJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientDisableJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisableNodeScheduling - Disables Task scheduling on the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node on which you want to disable Task scheduling.
//   - options - BatchApiClientDisableNodeSchedulingOptions contains the optional parameters for the BatchApiClient.DisableNodeScheduling
//     method.
func (client *BatchApiClient) DisableNodeScheduling(ctx context.Context, poolID string, nodeID string, options *BatchApiClientDisableNodeSchedulingOptions) (BatchApiClientDisableNodeSchedulingResponse, error) {
	var err error
	req, err := client.disableNodeSchedulingCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientDisableNodeSchedulingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDisableNodeSchedulingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDisableNodeSchedulingResponse{}, err
	}
	resp, err := client.disableNodeSchedulingHandleResponse(httpResp)
	return resp, err
}

// disableNodeSchedulingCreateRequest creates the DisableNodeScheduling request.
func (client *BatchApiClient) disableNodeSchedulingCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientDisableNodeSchedulingOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/disablescheduling"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
	if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// disableNodeSchedulingHandleResponse handles the DisableNodeScheduling response.
func (client *BatchApiClient) disableNodeSchedulingHandleResponse(resp *http.Response) (BatchApiClientDisableNodeSchedulingResponse, error) {
	result := BatchApiClientDisableNodeSchedulingResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientDisableNodeSchedulingResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// DisablePoolAutoScale - Disables automatic scaling for a Pool.
//   - poolID - The ID of the Pool on which to disable automatic scaling.
//   - options - BatchApiClientDisablePoolAutoScaleOptions contains the optional parameters for the BatchApiClient.DisablePoolAutoScale
//     method.
func (client *BatchApiClient) DisablePoolAutoScale(ctx context.Context, poolID string, options *BatchApiClientDisablePoolAutoScaleOptions) (BatchApiClientDisablePoolAutoScaleResponse, error) {
	var err error
	req, err := client.disablePoolAutoScaleCreateRequest(ctx, poolID, options)
	if err != nil {
		return BatchApiClientDisablePoolAutoScaleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientDisablePoolAutoScaleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientDisablePoolAutoScaleResponse{}, err
	}
	resp, err := client.disablePoolAutoScaleHandleResponse(httpResp)
	return resp, err
}

// disablePoolAutoScaleCreateRequest creates the DisablePoolAutoScale request.
func (client *BatchApiClient) disablePoolAutoScaleCreateRequest(ctx context.Context, poolID string, options *BatchApiClientDisablePoolAutoScaleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/disableautoscale"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// disablePoolAutoScaleHandleResponse handles the DisablePoolAutoScale response.
func (client *BatchApiClient) disablePoolAutoScaleHandleResponse(resp *http.Response) (BatchApiClientDisablePoolAutoScaleResponse, error) {
	result := BatchApiClientDisablePoolAutoScaleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientDisablePoolAutoScaleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnableJob - Enables the specified Job, allowing new Tasks to run.
//   - jobID - The ID of the Job to enable.
//   - options - BatchApiClientEnableJobOptions contains the optional parameters for the BatchApiClient.EnableJob method.
func (client *BatchApiClient) EnableJob(ctx context.Context, jobID string, options *BatchApiClientEnableJobOptions) (BatchApiClientEnableJobResponse, error) {
	var err error
	req, err := client.enableJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return BatchApiClientEnableJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientEnableJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientEnableJobResponse{}, err
	}
	resp, err := client.enableJobHandleResponse(httpResp)
	return resp, err
}

// enableJobCreateRequest creates the EnableJob request.
func (client *BatchApiClient) enableJobCreateRequest(ctx context.Context, jobID string, options *BatchApiClientEnableJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/enable"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// enableJobHandleResponse handles the EnableJob response.
func (client *BatchApiClient) enableJobHandleResponse(resp *http.Response) (BatchApiClientEnableJobResponse, error) {
	result := BatchApiClientEnableJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientEnableJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnableJobSchedule - Enables a Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule to enable.
//   - options - BatchApiClientEnableJobScheduleOptions contains the optional parameters for the BatchApiClient.EnableJobSchedule
//     method.
func (client *BatchApiClient) EnableJobSchedule(ctx context.Context, jobScheduleID string, options *BatchApiClientEnableJobScheduleOptions) (BatchApiClientEnableJobScheduleResponse, error) {
	var err error
	req, err := client.enableJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return BatchApiClientEnableJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientEnableJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientEnableJobScheduleResponse{}, err
	}
	resp, err := client.enableJobScheduleHandleResponse(httpResp)
	return resp, err
}

// enableJobScheduleCreateRequest creates the EnableJobSchedule request.
func (client *BatchApiClient) enableJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientEnableJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/enable"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// enableJobScheduleHandleResponse handles the EnableJobSchedule response.
func (client *BatchApiClient) enableJobScheduleHandleResponse(resp *http.Response) (BatchApiClientEnableJobScheduleResponse, error) {
	result := BatchApiClientEnableJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientEnableJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnableNodeScheduling - Enables Task scheduling on the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node on which you want to enable Task scheduling.
//   - options - BatchApiClientEnableNodeSchedulingOptions contains the optional parameters for the BatchApiClient.EnableNodeScheduling
//     method.
func (client *BatchApiClient) EnableNodeScheduling(ctx context.Context, poolID string, nodeID string, options *BatchApiClientEnableNodeSchedulingOptions) (BatchApiClientEnableNodeSchedulingResponse, error) {
	var err error
	req, err := client.enableNodeSchedulingCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientEnableNodeSchedulingResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientEnableNodeSchedulingResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientEnableNodeSchedulingResponse{}, err
	}
	resp, err := client.enableNodeSchedulingHandleResponse(httpResp)
	return resp, err
}

// enableNodeSchedulingCreateRequest creates the EnableNodeScheduling request.
func (client *BatchApiClient) enableNodeSchedulingCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientEnableNodeSchedulingOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/enablescheduling"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// enableNodeSchedulingHandleResponse handles the EnableNodeScheduling response.
func (client *BatchApiClient) enableNodeSchedulingHandleResponse(resp *http.Response) (BatchApiClientEnableNodeSchedulingResponse, error) {
	result := BatchApiClientEnableNodeSchedulingResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientEnableNodeSchedulingResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EnablePoolAutoScale - Enables automatic scaling for a Pool.
//   - poolID - The ID of the Pool to get.
//   - content - The options to use for enabling automatic scaling.
//   - options - BatchApiClientEnablePoolAutoScaleOptions contains the optional parameters for the BatchApiClient.EnablePoolAutoScale
//     method.
func (client *BatchApiClient) EnablePoolAutoScale(ctx context.Context, poolID string, content BatchPoolEnableAutoScaleContent, options *BatchApiClientEnablePoolAutoScaleOptions) (BatchApiClientEnablePoolAutoScaleResponse, error) {
	var err error
	req, err := client.enablePoolAutoScaleCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return BatchApiClientEnablePoolAutoScaleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientEnablePoolAutoScaleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientEnablePoolAutoScaleResponse{}, err
	}
	resp, err := client.enablePoolAutoScaleHandleResponse(httpResp)
	return resp, err
}

// enablePoolAutoScaleCreateRequest creates the EnablePoolAutoScale request.
func (client *BatchApiClient) enablePoolAutoScaleCreateRequest(ctx context.Context, poolID string, content BatchPoolEnableAutoScaleContent, options *BatchApiClientEnablePoolAutoScaleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/enableautoscale"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// enablePoolAutoScaleHandleResponse handles the EnablePoolAutoScale response.
func (client *BatchApiClient) enablePoolAutoScaleHandleResponse(resp *http.Response) (BatchApiClientEnablePoolAutoScaleResponse, error) {
	result := BatchApiClientEnablePoolAutoScaleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientEnablePoolAutoScaleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// EvaluatePoolAutoScale - Gets the result of evaluating an automatic scaling formula on the Pool.
//   - poolID - The ID of the Pool on which to evaluate the automatic scaling formula.
//   - content - The options to use for evaluating the automatic scaling formula.
//   - options - BatchApiClientEvaluatePoolAutoScaleOptions contains the optional parameters for the BatchApiClient.EvaluatePoolAutoScale
//     method.
func (client *BatchApiClient) EvaluatePoolAutoScale(ctx context.Context, poolID string, content BatchPoolEvaluateAutoScaleContent, options *BatchApiClientEvaluatePoolAutoScaleOptions) (BatchApiClientEvaluatePoolAutoScaleResponse, error) {
	var err error
	req, err := client.evaluatePoolAutoScaleCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return BatchApiClientEvaluatePoolAutoScaleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientEvaluatePoolAutoScaleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientEvaluatePoolAutoScaleResponse{}, err
	}
	resp, err := client.evaluatePoolAutoScaleHandleResponse(httpResp)
	return resp, err
}

// evaluatePoolAutoScaleCreateRequest creates the EvaluatePoolAutoScale request.
func (client *BatchApiClient) evaluatePoolAutoScaleCreateRequest(ctx context.Context, poolID string, content BatchPoolEvaluateAutoScaleContent, options *BatchApiClientEvaluatePoolAutoScaleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/evaluateautoscale"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// evaluatePoolAutoScaleHandleResponse handles the EvaluatePoolAutoScale response.
func (client *BatchApiClient) evaluatePoolAutoScaleHandleResponse(resp *http.Response) (BatchApiClientEvaluatePoolAutoScaleResponse, error) {
	result := BatchApiClientEvaluatePoolAutoScaleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientEvaluatePoolAutoScaleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.AutoScaleRun); err != nil {
		return BatchApiClientEvaluatePoolAutoScaleResponse{}, err
	}
	return result, nil
}

// GetApplication - Gets information about the specified Application.
//   - applicationID - The ID of the Application
//   - options - BatchApiClientGetApplicationOptions contains the optional parameters for the BatchApiClient.GetApplication method.
func (client *BatchApiClient) GetApplication(ctx context.Context, applicationID string, options *BatchApiClientGetApplicationOptions) (BatchApiClientGetApplicationResponse, error) {
	var err error
	req, err := client.getApplicationCreateRequest(ctx, applicationID, options)
	if err != nil {
		return BatchApiClientGetApplicationResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetApplicationResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetApplicationResponse{}, err
	}
	resp, err := client.getApplicationHandleResponse(httpResp)
	return resp, err
}

// getApplicationCreateRequest creates the GetApplication request.
func (client *BatchApiClient) getApplicationCreateRequest(ctx context.Context, applicationID string, options *BatchApiClientGetApplicationOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/applications/{applicationId}"
	if applicationID == "" {
		return nil, errors.New("parameter applicationID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{applicationId}", url.PathEscape(applicationID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getApplicationHandleResponse handles the GetApplication response.
func (client *BatchApiClient) getApplicationHandleResponse(resp *http.Response) (BatchApiClientGetApplicationResponse, error) {
	result := BatchApiClientGetApplicationResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetApplicationResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchApplication); err != nil {
		return BatchApiClientGetApplicationResponse{}, err
	}
	return result, nil
}

// GetCertificate - Gets information about the specified Certificate.
//   - thumbprintAlgorithm - The algorithm used to derive the thumbprint parameter. This must be sha1.
//   - thumbprint - The thumbprint of the Certificate to get.
//   - options - BatchApiClientGetCertificateOptions contains the optional parameters for the BatchApiClient.GetCertificate method.
func (client *BatchApiClient) GetCertificate(ctx context.Context, thumbprintAlgorithm string, thumbprint string, options *BatchApiClientGetCertificateOptions) (BatchApiClientGetCertificateResponse, error) {
	var err error
	req, err := client.getCertificateCreateRequest(ctx, thumbprintAlgorithm, thumbprint, options)
	if err != nil {
		return BatchApiClientGetCertificateResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetCertificateResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetCertificateResponse{}, err
	}
	resp, err := client.getCertificateHandleResponse(httpResp)
	return resp, err
}

// getCertificateCreateRequest creates the GetCertificate request.
func (client *BatchApiClient) getCertificateCreateRequest(ctx context.Context, thumbprintAlgorithm string, thumbprint string, options *BatchApiClientGetCertificateOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/certificates(thumbprintAlgorithm={thumbprintAlgorithm},thumbprint={thumbprint})"
	if thumbprintAlgorithm == "" {
		return nil, errors.New("parameter thumbprintAlgorithm cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{thumbprintAlgorithm}", url.PathEscape(thumbprintAlgorithm))
	if thumbprint == "" {
		return nil, errors.New("parameter thumbprint cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{thumbprint}", url.PathEscape(thumbprint))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getCertificateHandleResponse handles the GetCertificate response.
func (client *BatchApiClient) getCertificateHandleResponse(resp *http.Response) (BatchApiClientGetCertificateResponse, error) {
	result := BatchApiClientGetCertificateResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetCertificateResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchCertificate); err != nil {
		return BatchApiClientGetCertificateResponse{}, err
	}
	return result, nil
}

// GetJob - Gets information about the specified Job.
//   - jobID - The ID of the Job.
//   - options - BatchApiClientGetJobOptions contains the optional parameters for the BatchApiClient.GetJob method.
func (client *BatchApiClient) GetJob(ctx context.Context, jobID string, options *BatchApiClientGetJobOptions) (BatchApiClientGetJobResponse, error) {
	var err error
	req, err := client.getJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return BatchApiClientGetJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetJobResponse{}, err
	}
	resp, err := client.getJobHandleResponse(httpResp)
	return resp, err
}

// getJobCreateRequest creates the GetJob request.
func (client *BatchApiClient) getJobCreateRequest(ctx context.Context, jobID string, options *BatchApiClientGetJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getJobHandleResponse handles the GetJob response.
func (client *BatchApiClient) getJobHandleResponse(resp *http.Response) (BatchApiClientGetJobResponse, error) {
	result := BatchApiClientGetJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchJob); err != nil {
		return BatchApiClientGetJobResponse{}, err
	}
	return result, nil
}

// GetJobSchedule - Gets information about the specified Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule to get.
//   - options - BatchApiClientGetJobScheduleOptions contains the optional parameters for the BatchApiClient.GetJobSchedule method.
func (client *BatchApiClient) GetJobSchedule(ctx context.Context, jobScheduleID string, options *BatchApiClientGetJobScheduleOptions) (BatchApiClientGetJobScheduleResponse, error) {
	var err error
	req, err := client.getJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return BatchApiClientGetJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetJobScheduleResponse{}, err
	}
	resp, err := client.getJobScheduleHandleResponse(httpResp)
	return resp, err
}

// getJobScheduleCreateRequest creates the GetJobSchedule request.
func (client *BatchApiClient) getJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientGetJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getJobScheduleHandleResponse handles the GetJobSchedule response.
func (client *BatchApiClient) getJobScheduleHandleResponse(resp *http.Response) (BatchApiClientGetJobScheduleResponse, error) {
	result := BatchApiClientGetJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchJobSchedule); err != nil {
		return BatchApiClientGetJobScheduleResponse{}, err
	}
	return result, nil
}

// GetJobTaskCounts - Gets the Task counts for the specified Job.
//   - jobID - The ID of the Job.
//   - options - BatchApiClientGetJobTaskCountsOptions contains the optional parameters for the BatchApiClient.GetJobTaskCounts
//     method.
func (client *BatchApiClient) GetJobTaskCounts(ctx context.Context, jobID string, options *BatchApiClientGetJobTaskCountsOptions) (BatchApiClientGetJobTaskCountsResponse, error) {
	var err error
	req, err := client.getJobTaskCountsCreateRequest(ctx, jobID, options)
	if err != nil {
		return BatchApiClientGetJobTaskCountsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetJobTaskCountsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetJobTaskCountsResponse{}, err
	}
	resp, err := client.getJobTaskCountsHandleResponse(httpResp)
	return resp, err
}

// getJobTaskCountsCreateRequest creates the GetJobTaskCounts request.
func (client *BatchApiClient) getJobTaskCountsCreateRequest(ctx context.Context, jobID string, options *BatchApiClientGetJobTaskCountsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/taskcounts"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getJobTaskCountsHandleResponse handles the GetJobTaskCounts response.
func (client *BatchApiClient) getJobTaskCountsHandleResponse(resp *http.Response) (BatchApiClientGetJobTaskCountsResponse, error) {
	result := BatchApiClientGetJobTaskCountsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetJobTaskCountsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchTaskCountsResult); err != nil {
		return BatchApiClientGetJobTaskCountsResponse{}, err
	}
	return result, nil
}

// GetNode - Gets information about the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to get information about.
//   - options - BatchApiClientGetNodeOptions contains the optional parameters for the BatchApiClient.GetNode method.
func (client *BatchApiClient) GetNode(ctx context.Context, poolID string, nodeID string, options *BatchApiClientGetNodeOptions) (BatchApiClientGetNodeResponse, error) {
	var err error
	req, err := client.getNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientGetNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetNodeResponse{}, err
	}
	resp, err := client.getNodeHandleResponse(httpResp)
	return resp, err
}

// getNodeCreateRequest creates the GetNode request.
func (client *BatchApiClient) getNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientGetNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeHandleResponse handles the GetNode response.
func (client *BatchApiClient) getNodeHandleResponse(resp *http.Response) (BatchApiClientGetNodeResponse, error) {
	result := BatchApiClientGetNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNode); err != nil {
		return BatchApiClientGetNodeResponse{}, err
	}
	return result, nil
}

// GetNodeExtension - Gets information about the specified Compute Node Extension.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that contains the extensions.
//   - extensionName - The name of the Compute Node Extension that you want to get information about.
//   - options - BatchApiClientGetNodeExtensionOptions contains the optional parameters for the BatchApiClient.GetNodeExtension
//     method.
func (client *BatchApiClient) GetNodeExtension(ctx context.Context, poolID string, nodeID string, extensionName string, options *BatchApiClientGetNodeExtensionOptions) (BatchApiClientGetNodeExtensionResponse, error) {
	var err error
	req, err := client.getNodeExtensionCreateRequest(ctx, poolID, nodeID, extensionName, options)
	if err != nil {
		return BatchApiClientGetNodeExtensionResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetNodeExtensionResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetNodeExtensionResponse{}, err
	}
	resp, err := client.getNodeExtensionHandleResponse(httpResp)
	return resp, err
}

// getNodeExtensionCreateRequest creates the GetNodeExtension request.
func (client *BatchApiClient) getNodeExtensionCreateRequest(ctx context.Context, poolID string, nodeID string, extensionName string, options *BatchApiClientGetNodeExtensionOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/extensions/{extensionName}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if extensionName == "" {
		return nil, errors.New("parameter extensionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{extensionName}", url.PathEscape(extensionName))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeExtensionHandleResponse handles the GetNodeExtension response.
func (client *BatchApiClient) getNodeExtensionHandleResponse(resp *http.Response) (BatchApiClientGetNodeExtensionResponse, error) {
	result := BatchApiClientGetNodeExtensionResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeExtensionResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNodeVMExtension); err != nil {
		return BatchApiClientGetNodeExtensionResponse{}, err
	}
	return result, nil
}

// GetNodeFile - Returns the content of the specified Compute Node file.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node.
//   - filePath - The path to the file or directory.
//   - options - BatchApiClientGetNodeFileOptions contains the optional parameters for the BatchApiClient.GetNodeFile method.
func (client *BatchApiClient) GetNodeFile(ctx context.Context, poolID string, nodeID string, filePath string, options *BatchApiClientGetNodeFileOptions) (BatchApiClientGetNodeFileResponse, error) {
	var err error
	req, err := client.getNodeFileCreateRequest(ctx, poolID, nodeID, filePath, options)
	if err != nil {
		return BatchApiClientGetNodeFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetNodeFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetNodeFileResponse{}, err
	}
	resp, err := client.getNodeFileHandleResponse(httpResp)
	return resp, err
}

// getNodeFileCreateRequest creates the GetNodeFile request.
func (client *BatchApiClient) getNodeFileCreateRequest(ctx context.Context, poolID string, nodeID string, filePath string, options *BatchApiClientGetNodeFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files/{filePath}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.OcpRange != nil {
		req.Raw().Header["ocp-range"] = []string{*options.OcpRange}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeFileHandleResponse handles the GetNodeFile response.
func (client *BatchApiClient) getNodeFileHandleResponse(resp *http.Response) (BatchApiClientGetNodeFileResponse, error) {
	result := BatchApiClientGetNodeFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BatchApiClientGetNodeFileResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeFileResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return BatchApiClientGetNodeFileResponse{}, err
		}
		result.OcpBatchFileIsdirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OcpBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OcpBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeFileResponse{}, err
		}
		result.OcpCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsByteArray(resp, &result.Value, runtime.Base64StdFormat); err != nil {
		return BatchApiClientGetNodeFileResponse{}, err
	}
	return result, nil
}

// GetNodeFileProperties - Gets the properties of the specified Compute Node file.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node.
//   - filePath - The path to the file or directory.
//   - options - BatchApiClientGetNodeFilePropertiesOptions contains the optional parameters for the BatchApiClient.GetNodeFileProperties
//     method.
func (client *BatchApiClient) GetNodeFileProperties(ctx context.Context, poolID string, nodeID string, filePath string, options *BatchApiClientGetNodeFilePropertiesOptions) (BatchApiClientGetNodeFilePropertiesResponse, error) {
	var err error
	req, err := client.getNodeFilePropertiesCreateRequest(ctx, poolID, nodeID, filePath, options)
	if err != nil {
		return BatchApiClientGetNodeFilePropertiesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetNodeFilePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetNodeFilePropertiesResponse{}, err
	}
	resp, err := client.getNodeFilePropertiesHandleResponse(httpResp)
	return resp, err
}

// getNodeFilePropertiesCreateRequest creates the GetNodeFileProperties request.
func (client *BatchApiClient) getNodeFilePropertiesCreateRequest(ctx context.Context, poolID string, nodeID string, filePath string, options *BatchApiClientGetNodeFilePropertiesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files/{filePath}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeFilePropertiesHandleResponse handles the GetNodeFileProperties response.
func (client *BatchApiClient) getNodeFilePropertiesHandleResponse(resp *http.Response) (BatchApiClientGetNodeFilePropertiesResponse, error) {
	result := BatchApiClientGetNodeFilePropertiesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BatchApiClientGetNodeFilePropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeFilePropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return BatchApiClientGetNodeFilePropertiesResponse{}, err
		}
		result.OcpBatchFileIsdirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OcpBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OcpBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeFilePropertiesResponse{}, err
		}
		result.OcpCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// GetNodeRemoteDesktopFile - Gets the Remote Desktop Protocol file for the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node for which you want to get the Remote Desktop
//     Protocol file.
//   - options - BatchApiClientGetNodeRemoteDesktopFileOptions contains the optional parameters for the BatchApiClient.GetNodeRemoteDesktopFile
//     method.
func (client *BatchApiClient) GetNodeRemoteDesktopFile(ctx context.Context, poolID string, nodeID string, options *BatchApiClientGetNodeRemoteDesktopFileOptions) (BatchApiClientGetNodeRemoteDesktopFileResponse, error) {
	var err error
	req, err := client.getNodeRemoteDesktopFileCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientGetNodeRemoteDesktopFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetNodeRemoteDesktopFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetNodeRemoteDesktopFileResponse{}, err
	}
	resp, err := client.getNodeRemoteDesktopFileHandleResponse(httpResp)
	return resp, err
}

// getNodeRemoteDesktopFileCreateRequest creates the GetNodeRemoteDesktopFile request.
func (client *BatchApiClient) getNodeRemoteDesktopFileCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientGetNodeRemoteDesktopFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/rdp"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeRemoteDesktopFileHandleResponse handles the GetNodeRemoteDesktopFile response.
func (client *BatchApiClient) getNodeRemoteDesktopFileHandleResponse(resp *http.Response) (BatchApiClientGetNodeRemoteDesktopFileResponse, error) {
	result := BatchApiClientGetNodeRemoteDesktopFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeRemoteDesktopFileResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsByteArray(resp, &result.Value, runtime.Base64StdFormat); err != nil {
		return BatchApiClientGetNodeRemoteDesktopFileResponse{}, err
	}
	return result, nil
}

// GetNodeRemoteLoginSettings - Gets the settings required for remote login to a Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node for which to obtain the remote login settings.
//   - options - BatchApiClientGetNodeRemoteLoginSettingsOptions contains the optional parameters for the BatchApiClient.GetNodeRemoteLoginSettings
//     method.
func (client *BatchApiClient) GetNodeRemoteLoginSettings(ctx context.Context, poolID string, nodeID string, options *BatchApiClientGetNodeRemoteLoginSettingsOptions) (BatchApiClientGetNodeRemoteLoginSettingsResponse, error) {
	var err error
	req, err := client.getNodeRemoteLoginSettingsCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientGetNodeRemoteLoginSettingsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetNodeRemoteLoginSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetNodeRemoteLoginSettingsResponse{}, err
	}
	resp, err := client.getNodeRemoteLoginSettingsHandleResponse(httpResp)
	return resp, err
}

// getNodeRemoteLoginSettingsCreateRequest creates the GetNodeRemoteLoginSettings request.
func (client *BatchApiClient) getNodeRemoteLoginSettingsCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientGetNodeRemoteLoginSettingsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/remoteloginsettings"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getNodeRemoteLoginSettingsHandleResponse handles the GetNodeRemoteLoginSettings response.
func (client *BatchApiClient) getNodeRemoteLoginSettingsHandleResponse(resp *http.Response) (BatchApiClientGetNodeRemoteLoginSettingsResponse, error) {
	result := BatchApiClientGetNodeRemoteLoginSettingsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetNodeRemoteLoginSettingsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNodeRemoteLoginSettings); err != nil {
		return BatchApiClientGetNodeRemoteLoginSettingsResponse{}, err
	}
	return result, nil
}

// GetPool - Gets information about the specified Pool.
//   - poolID - The ID of the Pool to get.
//   - options - BatchApiClientGetPoolOptions contains the optional parameters for the BatchApiClient.GetPool method.
func (client *BatchApiClient) GetPool(ctx context.Context, poolID string, options *BatchApiClientGetPoolOptions) (BatchApiClientGetPoolResponse, error) {
	var err error
	req, err := client.getPoolCreateRequest(ctx, poolID, options)
	if err != nil {
		return BatchApiClientGetPoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetPoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetPoolResponse{}, err
	}
	resp, err := client.getPoolHandleResponse(httpResp)
	return resp, err
}

// getPoolCreateRequest creates the GetPool request.
func (client *BatchApiClient) getPoolCreateRequest(ctx context.Context, poolID string, options *BatchApiClientGetPoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getPoolHandleResponse handles the GetPool response.
func (client *BatchApiClient) getPoolHandleResponse(resp *http.Response) (BatchApiClientGetPoolResponse, error) {
	result := BatchApiClientGetPoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetPoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchPool); err != nil {
		return BatchApiClientGetPoolResponse{}, err
	}
	return result, nil
}

// GetTask - Gets information about the specified Task.
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task to get information about.
//   - options - BatchApiClientGetTaskOptions contains the optional parameters for the BatchApiClient.GetTask method.
func (client *BatchApiClient) GetTask(ctx context.Context, jobID string, taskID string, options *BatchApiClientGetTaskOptions) (BatchApiClientGetTaskResponse, error) {
	var err error
	req, err := client.getTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return BatchApiClientGetTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetTaskResponse{}, err
	}
	resp, err := client.getTaskHandleResponse(httpResp)
	return resp, err
}

// getTaskCreateRequest creates the GetTask request.
func (client *BatchApiClient) getTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *BatchApiClientGetTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getTaskHandleResponse handles the GetTask response.
func (client *BatchApiClient) getTaskHandleResponse(resp *http.Response) (BatchApiClientGetTaskResponse, error) {
	result := BatchApiClientGetTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchTask); err != nil {
		return BatchApiClientGetTaskResponse{}, err
	}
	return result, nil
}

// GetTaskFile - Returns the content of the specified Task file.
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose file you want to retrieve.
//   - filePath - The path to the Task file that you want to get the content of.
//   - options - BatchApiClientGetTaskFileOptions contains the optional parameters for the BatchApiClient.GetTaskFile method.
func (client *BatchApiClient) GetTaskFile(ctx context.Context, jobID string, taskID string, filePath string, options *BatchApiClientGetTaskFileOptions) (BatchApiClientGetTaskFileResponse, error) {
	var err error
	req, err := client.getTaskFileCreateRequest(ctx, jobID, taskID, filePath, options)
	if err != nil {
		return BatchApiClientGetTaskFileResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetTaskFileResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetTaskFileResponse{}, err
	}
	resp, err := client.getTaskFileHandleResponse(httpResp)
	return resp, err
}

// getTaskFileCreateRequest creates the GetTaskFile request.
func (client *BatchApiClient) getTaskFileCreateRequest(ctx context.Context, jobID string, taskID string, filePath string, options *BatchApiClientGetTaskFileOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files/{filePath}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/octet-stream"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.OcpRange != nil {
		req.Raw().Header["ocp-range"] = []string{*options.OcpRange}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getTaskFileHandleResponse handles the GetTaskFile response.
func (client *BatchApiClient) getTaskFileHandleResponse(resp *http.Response) (BatchApiClientGetTaskFileResponse, error) {
	result := BatchApiClientGetTaskFileResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BatchApiClientGetTaskFileResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetTaskFileResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return BatchApiClientGetTaskFileResponse{}, err
		}
		result.OcpBatchFileIsdirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OcpBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OcpBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetTaskFileResponse{}, err
		}
		result.OcpCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsByteArray(resp, &result.Value, runtime.Base64StdFormat); err != nil {
		return BatchApiClientGetTaskFileResponse{}, err
	}
	return result, nil
}

// GetTaskFileProperties - Gets the properties of the specified Task file.
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose file you want to retrieve.
//   - filePath - The path to the Task file that you want to get the content of.
//   - options - BatchApiClientGetTaskFilePropertiesOptions contains the optional parameters for the BatchApiClient.GetTaskFileProperties
//     method.
func (client *BatchApiClient) GetTaskFileProperties(ctx context.Context, jobID string, taskID string, filePath string, options *BatchApiClientGetTaskFilePropertiesOptions) (BatchApiClientGetTaskFilePropertiesResponse, error) {
	var err error
	req, err := client.getTaskFilePropertiesCreateRequest(ctx, jobID, taskID, filePath, options)
	if err != nil {
		return BatchApiClientGetTaskFilePropertiesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientGetTaskFilePropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientGetTaskFilePropertiesResponse{}, err
	}
	resp, err := client.getTaskFilePropertiesHandleResponse(httpResp)
	return resp, err
}

// getTaskFilePropertiesCreateRequest creates the GetTaskFileProperties request.
func (client *BatchApiClient) getTaskFilePropertiesCreateRequest(ctx context.Context, jobID string, taskID string, filePath string, options *BatchApiClientGetTaskFilePropertiesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files/{filePath}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	if filePath == "" {
		return nil, errors.New("parameter filePath cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{filePath}", url.PathEscape(filePath))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// getTaskFilePropertiesHandleResponse handles the GetTaskFileProperties response.
func (client *BatchApiClient) getTaskFilePropertiesHandleResponse(resp *http.Response) (BatchApiClientGetTaskFilePropertiesResponse, error) {
	result := BatchApiClientGetTaskFilePropertiesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("Content-Length"); val != "" {
		contentLength, err := strconv.ParseInt(val, 10, 64)
		if err != nil {
			return BatchApiClientGetTaskFilePropertiesResponse{}, err
		}
		result.ContentLength = &contentLength
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetTaskFilePropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("ocp-batch-file-isdirectory"); val != "" {
		ocpBatchFileIsdirectory, err := strconv.ParseBool(val)
		if err != nil {
			return BatchApiClientGetTaskFilePropertiesResponse{}, err
		}
		result.OcpBatchFileIsdirectory = &ocpBatchFileIsdirectory
	}
	if val := resp.Header.Get("ocp-batch-file-mode"); val != "" {
		result.OcpBatchFileMode = &val
	}
	if val := resp.Header.Get("ocp-batch-file-url"); val != "" {
		result.OcpBatchFileURL = &val
	}
	if val := resp.Header.Get("ocp-creation-time"); val != "" {
		ocpCreationTime, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientGetTaskFilePropertiesResponse{}, err
		}
		result.OcpCreationTime = &ocpCreationTime
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// JobScheduleExists - Checks the specified Job Schedule exists.
//   - jobScheduleID - The ID of the Job Schedule which you want to check.
//   - options - BatchApiClientJobScheduleExistsOptions contains the optional parameters for the BatchApiClient.JobScheduleExists
//     method.
func (client *BatchApiClient) JobScheduleExists(ctx context.Context, jobScheduleID string, options *BatchApiClientJobScheduleExistsOptions) (BatchApiClientJobScheduleExistsResponse, error) {
	var err error
	req, err := client.jobScheduleExistsCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return BatchApiClientJobScheduleExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientJobScheduleExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientJobScheduleExistsResponse{}, err
	}
	resp, err := client.jobScheduleExistsHandleResponse(httpResp)
	return resp, err
}

// jobScheduleExistsCreateRequest creates the JobScheduleExists request.
func (client *BatchApiClient) jobScheduleExistsCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientJobScheduleExistsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// jobScheduleExistsHandleResponse handles the JobScheduleExists response.
func (client *BatchApiClient) jobScheduleExistsHandleResponse(resp *http.Response) (BatchApiClientJobScheduleExistsResponse, error) {
	result := BatchApiClientJobScheduleExistsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientJobScheduleExistsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// NewListApplicationsPager - Lists all of the applications available in the specified Account.
//   - options - BatchApiClientListApplicationsOptions contains the optional parameters for the BatchApiClient.NewListApplicationsPager
//     method.
func (client *BatchApiClient) NewListApplicationsPager(options *BatchApiClientListApplicationsOptions) (*runtime.Pager[BatchApiClientListApplicationsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListApplicationsResponse]{
		More: func(page BatchApiClientListApplicationsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListApplicationsResponse) (BatchApiClientListApplicationsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listApplicationsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListApplicationsResponse{}, err
			}
			return client.listApplicationsHandleResponse(resp)
			},
	})
}

// listApplicationsCreateRequest creates the ListApplications request.
func (client *BatchApiClient) listApplicationsCreateRequest(ctx context.Context, options *BatchApiClientListApplicationsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/applications"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listApplicationsHandleResponse handles the ListApplications response.
func (client *BatchApiClient) listApplicationsHandleResponse(resp *http.Response) (BatchApiClientListApplicationsResponse, error) {
	result := BatchApiClientListApplicationsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListApplicationsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchApplicationListResult); err != nil {
		return BatchApiClientListApplicationsResponse{}, err
	}
	return result, nil
}

// NewListCertificatesPager - Lists all of the Certificates that have been added to the specified Account.
//   - options - BatchApiClientListCertificatesOptions contains the optional parameters for the BatchApiClient.NewListCertificatesPager
//     method.
func (client *BatchApiClient) NewListCertificatesPager(options *BatchApiClientListCertificatesOptions) (*runtime.Pager[BatchApiClientListCertificatesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListCertificatesResponse]{
		More: func(page BatchApiClientListCertificatesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListCertificatesResponse) (BatchApiClientListCertificatesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listCertificatesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListCertificatesResponse{}, err
			}
			return client.listCertificatesHandleResponse(resp)
			},
	})
}

// listCertificatesCreateRequest creates the ListCertificates request.
func (client *BatchApiClient) listCertificatesCreateRequest(ctx context.Context, options *BatchApiClientListCertificatesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/certificates"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listCertificatesHandleResponse handles the ListCertificates response.
func (client *BatchApiClient) listCertificatesHandleResponse(resp *http.Response) (BatchApiClientListCertificatesResponse, error) {
	result := BatchApiClientListCertificatesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListCertificatesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchCertificateListResult); err != nil {
		return BatchApiClientListCertificatesResponse{}, err
	}
	return result, nil
}

// NewListJobPreparationAndReleaseTaskStatusPager - Lists the execution status of the Job Preparation and Job Release Task
// for the
// specified Job across the Compute Nodes where the Job has run.
//   - jobID - The ID of the Job.
//   - options - BatchApiClientListJobPreparationAndReleaseTaskStatusOptions contains the optional parameters for the BatchApiClient.NewListJobPreparationAndReleaseTaskStatusPager
//     method.
func (client *BatchApiClient) NewListJobPreparationAndReleaseTaskStatusPager(jobID string, options *BatchApiClientListJobPreparationAndReleaseTaskStatusOptions) (*runtime.Pager[BatchApiClientListJobPreparationAndReleaseTaskStatusResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListJobPreparationAndReleaseTaskStatusResponse]{
		More: func(page BatchApiClientListJobPreparationAndReleaseTaskStatusResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListJobPreparationAndReleaseTaskStatusResponse) (BatchApiClientListJobPreparationAndReleaseTaskStatusResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobPreparationAndReleaseTaskStatusCreateRequest(ctx, jobID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListJobPreparationAndReleaseTaskStatusResponse{}, err
			}
			return client.listJobPreparationAndReleaseTaskStatusHandleResponse(resp)
			},
	})
}

// listJobPreparationAndReleaseTaskStatusCreateRequest creates the ListJobPreparationAndReleaseTaskStatus request.
func (client *BatchApiClient) listJobPreparationAndReleaseTaskStatusCreateRequest(ctx context.Context, jobID string, options *BatchApiClientListJobPreparationAndReleaseTaskStatusOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/jobpreparationandreleasetaskstatus"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobPreparationAndReleaseTaskStatusHandleResponse handles the ListJobPreparationAndReleaseTaskStatus response.
func (client *BatchApiClient) listJobPreparationAndReleaseTaskStatusHandleResponse(resp *http.Response) (BatchApiClientListJobPreparationAndReleaseTaskStatusResponse, error) {
	result := BatchApiClientListJobPreparationAndReleaseTaskStatusResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListJobPreparationAndReleaseTaskStatusResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchJobPreparationAndReleaseTaskStatusListResult); err != nil {
		return BatchApiClientListJobPreparationAndReleaseTaskStatusResponse{}, err
	}
	return result, nil
}

// NewListJobSchedulesPager - Lists all of the Job Schedules in the specified Account.
//   - options - BatchApiClientListJobSchedulesOptions contains the optional parameters for the BatchApiClient.NewListJobSchedulesPager
//     method.
func (client *BatchApiClient) NewListJobSchedulesPager(options *BatchApiClientListJobSchedulesOptions) (*runtime.Pager[BatchApiClientListJobSchedulesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListJobSchedulesResponse]{
		More: func(page BatchApiClientListJobSchedulesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListJobSchedulesResponse) (BatchApiClientListJobSchedulesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobSchedulesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListJobSchedulesResponse{}, err
			}
			return client.listJobSchedulesHandleResponse(resp)
			},
	})
}

// listJobSchedulesCreateRequest creates the ListJobSchedules request.
func (client *BatchApiClient) listJobSchedulesCreateRequest(ctx context.Context, options *BatchApiClientListJobSchedulesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobSchedulesHandleResponse handles the ListJobSchedules response.
func (client *BatchApiClient) listJobSchedulesHandleResponse(resp *http.Response) (BatchApiClientListJobSchedulesResponse, error) {
	result := BatchApiClientListJobSchedulesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListJobSchedulesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchJobScheduleListResult); err != nil {
		return BatchApiClientListJobSchedulesResponse{}, err
	}
	return result, nil
}

// NewListJobsPager - Lists all of the Jobs in the specified Account.
//   - options - BatchApiClientListJobsOptions contains the optional parameters for the BatchApiClient.NewListJobsPager method.
func (client *BatchApiClient) NewListJobsPager(options *BatchApiClientListJobsOptions) (*runtime.Pager[BatchApiClientListJobsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListJobsResponse]{
		More: func(page BatchApiClientListJobsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListJobsResponse) (BatchApiClientListJobsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListJobsResponse{}, err
			}
			return client.listJobsHandleResponse(resp)
			},
	})
}

// listJobsCreateRequest creates the ListJobs request.
func (client *BatchApiClient) listJobsCreateRequest(ctx context.Context, options *BatchApiClientListJobsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobsHandleResponse handles the ListJobs response.
func (client *BatchApiClient) listJobsHandleResponse(resp *http.Response) (BatchApiClientListJobsResponse, error) {
	result := BatchApiClientListJobsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListJobsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchJobListResult); err != nil {
		return BatchApiClientListJobsResponse{}, err
	}
	return result, nil
}

// NewListJobsFromSchedulePager - Lists the Jobs that have been created under the specified Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule from which you want to get a list of Jobs.
//   - options - BatchApiClientListJobsFromScheduleOptions contains the optional parameters for the BatchApiClient.NewListJobsFromSchedulePager
//     method.
func (client *BatchApiClient) NewListJobsFromSchedulePager(jobScheduleID string, options *BatchApiClientListJobsFromScheduleOptions) (*runtime.Pager[BatchApiClientListJobsFromScheduleResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListJobsFromScheduleResponse]{
		More: func(page BatchApiClientListJobsFromScheduleResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListJobsFromScheduleResponse) (BatchApiClientListJobsFromScheduleResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listJobsFromScheduleCreateRequest(ctx, jobScheduleID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListJobsFromScheduleResponse{}, err
			}
			return client.listJobsFromScheduleHandleResponse(resp)
			},
	})
}

// listJobsFromScheduleCreateRequest creates the ListJobsFromSchedule request.
func (client *BatchApiClient) listJobsFromScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientListJobsFromScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/jobs"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listJobsFromScheduleHandleResponse handles the ListJobsFromSchedule response.
func (client *BatchApiClient) listJobsFromScheduleHandleResponse(resp *http.Response) (BatchApiClientListJobsFromScheduleResponse, error) {
	result := BatchApiClientListJobsFromScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListJobsFromScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchJobListResult); err != nil {
		return BatchApiClientListJobsFromScheduleResponse{}, err
	}
	return result, nil
}

// NewListNodeExtensionsPager - Lists the Compute Nodes Extensions in the specified Pool.
//   - poolID - The ID of the Pool that contains Compute Node.
//   - nodeID - The ID of the Compute Node that you want to list extensions.
//   - options - BatchApiClientListNodeExtensionsOptions contains the optional parameters for the BatchApiClient.NewListNodeExtensionsPager
//     method.
func (client *BatchApiClient) NewListNodeExtensionsPager(poolID string, nodeID string, options *BatchApiClientListNodeExtensionsOptions) (*runtime.Pager[BatchApiClientListNodeExtensionsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListNodeExtensionsResponse]{
		More: func(page BatchApiClientListNodeExtensionsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListNodeExtensionsResponse) (BatchApiClientListNodeExtensionsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listNodeExtensionsCreateRequest(ctx, poolID, nodeID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListNodeExtensionsResponse{}, err
			}
			return client.listNodeExtensionsHandleResponse(resp)
			},
	})
}

// listNodeExtensionsCreateRequest creates the ListNodeExtensions request.
func (client *BatchApiClient) listNodeExtensionsCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientListNodeExtensionsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/extensions"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listNodeExtensionsHandleResponse handles the ListNodeExtensions response.
func (client *BatchApiClient) listNodeExtensionsHandleResponse(resp *http.Response) (BatchApiClientListNodeExtensionsResponse, error) {
	result := BatchApiClientListNodeExtensionsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListNodeExtensionsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNodeVMExtensionListResult); err != nil {
		return BatchApiClientListNodeExtensionsResponse{}, err
	}
	return result, nil
}

// NewListNodeFilesPager - Lists all of the files in Task directories on the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node whose files you want to list.
//   - options - BatchApiClientListNodeFilesOptions contains the optional parameters for the BatchApiClient.NewListNodeFilesPager
//     method.
func (client *BatchApiClient) NewListNodeFilesPager(poolID string, nodeID string, options *BatchApiClientListNodeFilesOptions) (*runtime.Pager[BatchApiClientListNodeFilesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListNodeFilesResponse]{
		More: func(page BatchApiClientListNodeFilesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListNodeFilesResponse) (BatchApiClientListNodeFilesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listNodeFilesCreateRequest(ctx, poolID, nodeID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListNodeFilesResponse{}, err
			}
			return client.listNodeFilesHandleResponse(resp)
			},
	})
}

// listNodeFilesCreateRequest creates the ListNodeFiles request.
func (client *BatchApiClient) listNodeFilesCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientListNodeFilesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/files"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listNodeFilesHandleResponse handles the ListNodeFiles response.
func (client *BatchApiClient) listNodeFilesHandleResponse(resp *http.Response) (BatchApiClientListNodeFilesResponse, error) {
	result := BatchApiClientListNodeFilesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListNodeFilesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNodeFileListResult); err != nil {
		return BatchApiClientListNodeFilesResponse{}, err
	}
	return result, nil
}

// NewListNodesPager - Lists the Compute Nodes in the specified Pool.
//   - poolID - The ID of the Pool from which you want to list Compute Nodes.
//   - options - BatchApiClientListNodesOptions contains the optional parameters for the BatchApiClient.NewListNodesPager method.
func (client *BatchApiClient) NewListNodesPager(poolID string, options *BatchApiClientListNodesOptions) (*runtime.Pager[BatchApiClientListNodesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListNodesResponse]{
		More: func(page BatchApiClientListNodesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListNodesResponse) (BatchApiClientListNodesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listNodesCreateRequest(ctx, poolID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListNodesResponse{}, err
			}
			return client.listNodesHandleResponse(resp)
			},
	})
}

// listNodesCreateRequest creates the ListNodes request.
func (client *BatchApiClient) listNodesCreateRequest(ctx context.Context, poolID string, options *BatchApiClientListNodesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listNodesHandleResponse handles the ListNodes response.
func (client *BatchApiClient) listNodesHandleResponse(resp *http.Response) (BatchApiClientListNodesResponse, error) {
	result := BatchApiClientListNodesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListNodesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNodeListResult); err != nil {
		return BatchApiClientListNodesResponse{}, err
	}
	return result, nil
}

// NewListPoolNodeCountsPager - Gets the number of Compute Nodes in each state, grouped by Pool. Note that the
// numbers returned may not always be up to date. If you need exact node counts,
// use a list query.
//   - options - BatchApiClientListPoolNodeCountsOptions contains the optional parameters for the BatchApiClient.NewListPoolNodeCountsPager
//     method.
func (client *BatchApiClient) NewListPoolNodeCountsPager(options *BatchApiClientListPoolNodeCountsOptions) (*runtime.Pager[BatchApiClientListPoolNodeCountsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListPoolNodeCountsResponse]{
		More: func(page BatchApiClientListPoolNodeCountsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListPoolNodeCountsResponse) (BatchApiClientListPoolNodeCountsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPoolNodeCountsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListPoolNodeCountsResponse{}, err
			}
			return client.listPoolNodeCountsHandleResponse(resp)
			},
	})
}

// listPoolNodeCountsCreateRequest creates the ListPoolNodeCounts request.
func (client *BatchApiClient) listPoolNodeCountsCreateRequest(ctx context.Context, options *BatchApiClientListPoolNodeCountsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/nodecounts"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listPoolNodeCountsHandleResponse handles the ListPoolNodeCounts response.
func (client *BatchApiClient) listPoolNodeCountsHandleResponse(resp *http.Response) (BatchApiClientListPoolNodeCountsResponse, error) {
	result := BatchApiClientListPoolNodeCountsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListPoolNodeCountsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchPoolNodeCountsListResult); err != nil {
		return BatchApiClientListPoolNodeCountsResponse{}, err
	}
	return result, nil
}

// NewListPoolUsageMetricsPager - Lists the usage metrics, aggregated by Pool across individual time intervals,
// for the specified Account.
//   - options - BatchApiClientListPoolUsageMetricsOptions contains the optional parameters for the BatchApiClient.NewListPoolUsageMetricsPager
//     method.
func (client *BatchApiClient) NewListPoolUsageMetricsPager(options *BatchApiClientListPoolUsageMetricsOptions) (*runtime.Pager[BatchApiClientListPoolUsageMetricsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListPoolUsageMetricsResponse]{
		More: func(page BatchApiClientListPoolUsageMetricsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListPoolUsageMetricsResponse) (BatchApiClientListPoolUsageMetricsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPoolUsageMetricsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListPoolUsageMetricsResponse{}, err
			}
			return client.listPoolUsageMetricsHandleResponse(resp)
			},
	})
}

// listPoolUsageMetricsCreateRequest creates the ListPoolUsageMetrics request.
func (client *BatchApiClient) listPoolUsageMetricsCreateRequest(ctx context.Context, options *BatchApiClientListPoolUsageMetricsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/poolusagemetrics"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Endtime != nil {
		reqQP.Set("endtime", options.Endtime.Format(time.RFC3339Nano))
	}
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Starttime != nil {
		reqQP.Set("startTime", options.Starttime.Format(time.RFC3339Nano))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listPoolUsageMetricsHandleResponse handles the ListPoolUsageMetrics response.
func (client *BatchApiClient) listPoolUsageMetricsHandleResponse(resp *http.Response) (BatchApiClientListPoolUsageMetricsResponse, error) {
	result := BatchApiClientListPoolUsageMetricsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListPoolUsageMetricsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchPoolListUsageMetricsResult); err != nil {
		return BatchApiClientListPoolUsageMetricsResponse{}, err
	}
	return result, nil
}

// NewListPoolsPager - Lists all of the Pools in the specified Account.
//   - options - BatchApiClientListPoolsOptions contains the optional parameters for the BatchApiClient.NewListPoolsPager method.
func (client *BatchApiClient) NewListPoolsPager(options *BatchApiClientListPoolsOptions) (*runtime.Pager[BatchApiClientListPoolsResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListPoolsResponse]{
		More: func(page BatchApiClientListPoolsResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListPoolsResponse) (BatchApiClientListPoolsResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listPoolsCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListPoolsResponse{}, err
			}
			return client.listPoolsHandleResponse(resp)
			},
	})
}

// listPoolsCreateRequest creates the ListPools request.
func (client *BatchApiClient) listPoolsCreateRequest(ctx context.Context, options *BatchApiClientListPoolsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listPoolsHandleResponse handles the ListPools response.
func (client *BatchApiClient) listPoolsHandleResponse(resp *http.Response) (BatchApiClientListPoolsResponse, error) {
	result := BatchApiClientListPoolsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListPoolsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchPoolListResult); err != nil {
		return BatchApiClientListPoolsResponse{}, err
	}
	return result, nil
}

// NewListSubTasksPager - Lists all of the subtasks that are associated with the specified multi-instance
// Task.
//   - jobID - The ID of the Job.
//   - taskID - The ID of the Task.
//   - options - BatchApiClientListSubTasksOptions contains the optional parameters for the BatchApiClient.NewListSubTasksPager
//     method.
func (client *BatchApiClient) NewListSubTasksPager(jobID string, taskID string, options *BatchApiClientListSubTasksOptions) (*runtime.Pager[BatchApiClientListSubTasksResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListSubTasksResponse]{
		More: func(page BatchApiClientListSubTasksResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListSubTasksResponse) (BatchApiClientListSubTasksResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSubTasksCreateRequest(ctx, jobID, taskID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListSubTasksResponse{}, err
			}
			return client.listSubTasksHandleResponse(resp)
			},
	})
}

// listSubTasksCreateRequest creates the ListSubTasks request.
func (client *BatchApiClient) listSubTasksCreateRequest(ctx context.Context, jobID string, taskID string, options *BatchApiClientListSubTasksOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/subtasksinfo"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listSubTasksHandleResponse handles the ListSubTasks response.
func (client *BatchApiClient) listSubTasksHandleResponse(resp *http.Response) (BatchApiClientListSubTasksResponse, error) {
	result := BatchApiClientListSubTasksResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListSubTasksResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchTaskListSubtasksResult); err != nil {
		return BatchApiClientListSubTasksResponse{}, err
	}
	return result, nil
}

// NewListSupportedImagesPager - Lists all Virtual Machine Images supported by the Azure Batch service.
//   - options - BatchApiClientListSupportedImagesOptions contains the optional parameters for the BatchApiClient.NewListSupportedImagesPager
//     method.
func (client *BatchApiClient) NewListSupportedImagesPager(options *BatchApiClientListSupportedImagesOptions) (*runtime.Pager[BatchApiClientListSupportedImagesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListSupportedImagesResponse]{
		More: func(page BatchApiClientListSupportedImagesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListSupportedImagesResponse) (BatchApiClientListSupportedImagesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listSupportedImagesCreateRequest(ctx, options)
			}, nil)
			if err != nil {
				return BatchApiClientListSupportedImagesResponse{}, err
			}
			return client.listSupportedImagesHandleResponse(resp)
			},
	})
}

// listSupportedImagesCreateRequest creates the ListSupportedImages request.
func (client *BatchApiClient) listSupportedImagesCreateRequest(ctx context.Context, options *BatchApiClientListSupportedImagesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/supportedimages"
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listSupportedImagesHandleResponse handles the ListSupportedImages response.
func (client *BatchApiClient) listSupportedImagesHandleResponse(resp *http.Response) (BatchApiClientListSupportedImagesResponse, error) {
	result := BatchApiClientListSupportedImagesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListSupportedImagesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchAccountListSupportedImagesResult); err != nil {
		return BatchApiClientListSupportedImagesResponse{}, err
	}
	return result, nil
}

// NewListTaskFilesPager - Lists the files in a Task's directory on its Compute Node.
//   - jobID - The ID of the Job that contains the Task.
//   - taskID - The ID of the Task whose files you want to list.
//   - options - BatchApiClientListTaskFilesOptions contains the optional parameters for the BatchApiClient.NewListTaskFilesPager
//     method.
func (client *BatchApiClient) NewListTaskFilesPager(jobID string, taskID string, options *BatchApiClientListTaskFilesOptions) (*runtime.Pager[BatchApiClientListTaskFilesResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListTaskFilesResponse]{
		More: func(page BatchApiClientListTaskFilesResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListTaskFilesResponse) (BatchApiClientListTaskFilesResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTaskFilesCreateRequest(ctx, jobID, taskID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListTaskFilesResponse{}, err
			}
			return client.listTaskFilesHandleResponse(resp)
			},
	})
}

// listTaskFilesCreateRequest creates the ListTaskFiles request.
func (client *BatchApiClient) listTaskFilesCreateRequest(ctx context.Context, jobID string, taskID string, options *BatchApiClientListTaskFilesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/files"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.Recursive != nil {
		reqQP.Set("recursive", strconv.FormatBool(*options.Recursive))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listTaskFilesHandleResponse handles the ListTaskFiles response.
func (client *BatchApiClient) listTaskFilesHandleResponse(resp *http.Response) (BatchApiClientListTaskFilesResponse, error) {
	result := BatchApiClientListTaskFilesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListTaskFilesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchNodeFileListResult); err != nil {
		return BatchApiClientListTaskFilesResponse{}, err
	}
	return result, nil
}

// NewListTasksPager - Lists all of the Tasks that are associated with the specified Job.
//   - jobID - The ID of the Job.
//   - options - BatchApiClientListTasksOptions contains the optional parameters for the BatchApiClient.NewListTasksPager method.
func (client *BatchApiClient) NewListTasksPager(jobID string, options *BatchApiClientListTasksOptions) (*runtime.Pager[BatchApiClientListTasksResponse]) {
	return runtime.NewPager(runtime.PagingHandler[BatchApiClientListTasksResponse]{
		More: func(page BatchApiClientListTasksResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *BatchApiClientListTasksResponse) (BatchApiClientListTasksResponse, error) {
			nextLink := ""
			if page != nil {
				nextLink = *page.ODataNextLink
			}
			resp, err := runtime.FetcherForNextLink(ctx, client.internal.Pipeline(), nextLink, func(ctx context.Context) (*policy.Request, error) {
				return client.listTasksCreateRequest(ctx, jobID, options)
			}, nil)
			if err != nil {
				return BatchApiClientListTasksResponse{}, err
			}
			return client.listTasksHandleResponse(resp)
			},
	})
}

// listTasksCreateRequest creates the ListTasks request.
func (client *BatchApiClient) listTasksCreateRequest(ctx context.Context, jobID string, options *BatchApiClientListTasksOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", strings.Join(options.Expand, ","))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.SelectParam != nil {
		reqQP.Set("$select", strings.Join(options.SelectParam, ","))
	}
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.Maxresults != nil {
		reqQP.Set("maxresults", strconv.FormatInt(int64(*options.Maxresults), 10))
	}
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// listTasksHandleResponse handles the ListTasks response.
func (client *BatchApiClient) listTasksHandleResponse(resp *http.Response) (BatchApiClientListTasksResponse, error) {
	result := BatchApiClientListTasksResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientListTasksResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.BatchTaskListResult); err != nil {
		return BatchApiClientListTasksResponse{}, err
	}
	return result, nil
}

// PoolExists - Gets basic properties of a Pool.
//   - poolID - The ID of the Pool to get.
//   - options - BatchApiClientPoolExistsOptions contains the optional parameters for the BatchApiClient.PoolExists method.
func (client *BatchApiClient) PoolExists(ctx context.Context, poolID string, options *BatchApiClientPoolExistsOptions) (BatchApiClientPoolExistsResponse, error) {
	var err error
	req, err := client.poolExistsCreateRequest(ctx, poolID, options)
	if err != nil {
		return BatchApiClientPoolExistsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientPoolExistsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK, http.StatusNotFound) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientPoolExistsResponse{}, err
	}
	resp, err := client.poolExistsHandleResponse(httpResp)
	return resp, err
}

// poolExistsCreateRequest creates the PoolExists request.
func (client *BatchApiClient) poolExistsCreateRequest(ctx context.Context, poolID string, options *BatchApiClientPoolExistsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodHead, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// poolExistsHandleResponse handles the PoolExists response.
func (client *BatchApiClient) poolExistsHandleResponse(resp *http.Response) (BatchApiClientPoolExistsResponse, error) {
	result := BatchApiClientPoolExistsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientPoolExistsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReactivateTask - Reactivates a Task, allowing it to run again even if its retry count has been
// exhausted.
//   - jobID - The ID of the Job containing the Task.
//   - taskID - The ID of the Task to reactivate.
//   - options - BatchApiClientReactivateTaskOptions contains the optional parameters for the BatchApiClient.ReactivateTask method.
func (client *BatchApiClient) ReactivateTask(ctx context.Context, jobID string, taskID string, options *BatchApiClientReactivateTaskOptions) (BatchApiClientReactivateTaskResponse, error) {
	var err error
	req, err := client.reactivateTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return BatchApiClientReactivateTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReactivateTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReactivateTaskResponse{}, err
	}
	resp, err := client.reactivateTaskHandleResponse(httpResp)
	return resp, err
}

// reactivateTaskCreateRequest creates the ReactivateTask request.
func (client *BatchApiClient) reactivateTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *BatchApiClientReactivateTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/reactivate"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// reactivateTaskHandleResponse handles the ReactivateTask response.
func (client *BatchApiClient) reactivateTaskHandleResponse(resp *http.Response) (BatchApiClientReactivateTaskResponse, error) {
	result := BatchApiClientReactivateTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReactivateTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// RebootNode - Restarts the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to restart.
//   - options - BatchApiClientRebootNodeOptions contains the optional parameters for the BatchApiClient.RebootNode method.
func (client *BatchApiClient) RebootNode(ctx context.Context, poolID string, nodeID string, options *BatchApiClientRebootNodeOptions) (BatchApiClientRebootNodeResponse, error) {
	var err error
	req, err := client.rebootNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientRebootNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientRebootNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientRebootNodeResponse{}, err
	}
	resp, err := client.rebootNodeHandleResponse(httpResp)
	return resp, err
}

// rebootNodeCreateRequest creates the RebootNode request.
func (client *BatchApiClient) rebootNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientRebootNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/reboot"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
	if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// rebootNodeHandleResponse handles the RebootNode response.
func (client *BatchApiClient) rebootNodeHandleResponse(resp *http.Response) (BatchApiClientRebootNodeResponse, error) {
	result := BatchApiClientRebootNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientRebootNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReimageNode - Reinstalls the operating system on the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node that you want to restart.
//   - options - BatchApiClientReimageNodeOptions contains the optional parameters for the BatchApiClient.ReimageNode method.
func (client *BatchApiClient) ReimageNode(ctx context.Context, poolID string, nodeID string, options *BatchApiClientReimageNodeOptions) (BatchApiClientReimageNodeResponse, error) {
	var err error
	req, err := client.reimageNodeCreateRequest(ctx, poolID, nodeID, options)
	if err != nil {
		return BatchApiClientReimageNodeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReimageNodeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReimageNodeResponse{}, err
	}
	resp, err := client.reimageNodeHandleResponse(httpResp)
	return resp, err
}

// reimageNodeCreateRequest creates the ReimageNode request.
func (client *BatchApiClient) reimageNodeCreateRequest(ctx context.Context, poolID string, nodeID string, options *BatchApiClientReimageNodeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/reimage"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
	if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// reimageNodeHandleResponse handles the ReimageNode response.
func (client *BatchApiClient) reimageNodeHandleResponse(resp *http.Response) (BatchApiClientReimageNodeResponse, error) {
	result := BatchApiClientReimageNodeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReimageNodeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// RemoveNodes - Removes Compute Nodes from the specified Pool.
//   - poolID - The ID of the Pool to get.
//   - content - The options to use for removing the node.
//   - options - BatchApiClientRemoveNodesOptions contains the optional parameters for the BatchApiClient.RemoveNodes method.
func (client *BatchApiClient) RemoveNodes(ctx context.Context, poolID string, content BatchNodeRemoveContent, options *BatchApiClientRemoveNodesOptions) (BatchApiClientRemoveNodesResponse, error) {
	var err error
	req, err := client.removeNodesCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return BatchApiClientRemoveNodesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientRemoveNodesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientRemoveNodesResponse{}, err
	}
	resp, err := client.removeNodesHandleResponse(httpResp)
	return resp, err
}

// removeNodesCreateRequest creates the RemoveNodes request.
func (client *BatchApiClient) removeNodesCreateRequest(ctx context.Context, poolID string, content BatchNodeRemoveContent, options *BatchApiClientRemoveNodesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/removenodes"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// removeNodesHandleResponse handles the RemoveNodes response.
func (client *BatchApiClient) removeNodesHandleResponse(resp *http.Response) (BatchApiClientRemoveNodesResponse, error) {
	result := BatchApiClientRemoveNodesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientRemoveNodesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceJob - Updates the properties of the specified Job.
//   - jobID - The ID of the Job whose properties you want to update.
//   - job - A job with updated properties
//   - options - BatchApiClientReplaceJobOptions contains the optional parameters for the BatchApiClient.ReplaceJob method.
func (client *BatchApiClient) ReplaceJob(ctx context.Context, jobID string, job BatchJob, options *BatchApiClientReplaceJobOptions) (BatchApiClientReplaceJobResponse, error) {
	var err error
	req, err := client.replaceJobCreateRequest(ctx, jobID, job, options)
	if err != nil {
		return BatchApiClientReplaceJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReplaceJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReplaceJobResponse{}, err
	}
	resp, err := client.replaceJobHandleResponse(httpResp)
	return resp, err
}

// replaceJobCreateRequest creates the ReplaceJob request.
func (client *BatchApiClient) replaceJobCreateRequest(ctx context.Context, jobID string, job BatchJob, options *BatchApiClientReplaceJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, job); err != nil {
	return nil, err
}
	return req, nil
}

// replaceJobHandleResponse handles the ReplaceJob response.
func (client *BatchApiClient) replaceJobHandleResponse(resp *http.Response) (BatchApiClientReplaceJobResponse, error) {
	result := BatchApiClientReplaceJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReplaceJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceJobSchedule - Updates the properties of the specified Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule to update.
//   - jobSchedule - A Job Schedule with updated properties
//   - options - BatchApiClientReplaceJobScheduleOptions contains the optional parameters for the BatchApiClient.ReplaceJobSchedule
//     method.
func (client *BatchApiClient) ReplaceJobSchedule(ctx context.Context, jobScheduleID string, jobSchedule BatchJobSchedule, options *BatchApiClientReplaceJobScheduleOptions) (BatchApiClientReplaceJobScheduleResponse, error) {
	var err error
	req, err := client.replaceJobScheduleCreateRequest(ctx, jobScheduleID, jobSchedule, options)
	if err != nil {
		return BatchApiClientReplaceJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReplaceJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReplaceJobScheduleResponse{}, err
	}
	resp, err := client.replaceJobScheduleHandleResponse(httpResp)
	return resp, err
}

// replaceJobScheduleCreateRequest creates the ReplaceJobSchedule request.
func (client *BatchApiClient) replaceJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, jobSchedule BatchJobSchedule, options *BatchApiClientReplaceJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, jobSchedule); err != nil {
	return nil, err
}
	return req, nil
}

// replaceJobScheduleHandleResponse handles the ReplaceJobSchedule response.
func (client *BatchApiClient) replaceJobScheduleHandleResponse(resp *http.Response) (BatchApiClientReplaceJobScheduleResponse, error) {
	result := BatchApiClientReplaceJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReplaceJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceNodeUser - Updates the password and expiration time of a user Account on the specified Compute Node.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the machine on which you want to update a user Account.
//   - userName - The name of the user Account to update.
//   - content - The options to use for updating the user.
//   - options - BatchApiClientReplaceNodeUserOptions contains the optional parameters for the BatchApiClient.ReplaceNodeUser
//     method.
func (client *BatchApiClient) ReplaceNodeUser(ctx context.Context, poolID string, nodeID string, userName string, content BatchNodeUserUpdateContent, options *BatchApiClientReplaceNodeUserOptions) (BatchApiClientReplaceNodeUserResponse, error) {
	var err error
	req, err := client.replaceNodeUserCreateRequest(ctx, poolID, nodeID, userName, content, options)
	if err != nil {
		return BatchApiClientReplaceNodeUserResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReplaceNodeUserResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReplaceNodeUserResponse{}, err
	}
	resp, err := client.replaceNodeUserHandleResponse(httpResp)
	return resp, err
}

// replaceNodeUserCreateRequest creates the ReplaceNodeUser request.
func (client *BatchApiClient) replaceNodeUserCreateRequest(ctx context.Context, poolID string, nodeID string, userName string, content BatchNodeUserUpdateContent, options *BatchApiClientReplaceNodeUserOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/users/{userName}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	if userName == "" {
		return nil, errors.New("parameter userName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{userName}", url.PathEscape(userName))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// replaceNodeUserHandleResponse handles the ReplaceNodeUser response.
func (client *BatchApiClient) replaceNodeUserHandleResponse(resp *http.Response) (BatchApiClientReplaceNodeUserResponse, error) {
	result := BatchApiClientReplaceNodeUserResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReplaceNodeUserResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplacePoolProperties - Updates the properties of the specified Pool.
//   - poolID - The ID of the Pool to update.
//   - pool - The options to use for replacing properties on the pool.
//   - options - BatchApiClientReplacePoolPropertiesOptions contains the optional parameters for the BatchApiClient.ReplacePoolProperties
//     method.
func (client *BatchApiClient) ReplacePoolProperties(ctx context.Context, poolID string, pool BatchPoolReplaceContent, options *BatchApiClientReplacePoolPropertiesOptions) (BatchApiClientReplacePoolPropertiesResponse, error) {
	var err error
	req, err := client.replacePoolPropertiesCreateRequest(ctx, poolID, pool, options)
	if err != nil {
		return BatchApiClientReplacePoolPropertiesResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReplacePoolPropertiesResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReplacePoolPropertiesResponse{}, err
	}
	resp, err := client.replacePoolPropertiesHandleResponse(httpResp)
	return resp, err
}

// replacePoolPropertiesCreateRequest creates the ReplacePoolProperties request.
func (client *BatchApiClient) replacePoolPropertiesCreateRequest(ctx context.Context, poolID string, pool BatchPoolReplaceContent, options *BatchApiClientReplacePoolPropertiesOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/updateproperties"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, pool); err != nil {
	return nil, err
}
	return req, nil
}

// replacePoolPropertiesHandleResponse handles the ReplacePoolProperties response.
func (client *BatchApiClient) replacePoolPropertiesHandleResponse(resp *http.Response) (BatchApiClientReplacePoolPropertiesResponse, error) {
	result := BatchApiClientReplacePoolPropertiesResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReplacePoolPropertiesResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ReplaceTask - Updates the properties of the specified Task.
//   - jobID - The ID of the Job containing the Task.
//   - taskID - The ID of the Task to update.
//   - task - The Task to update.
//   - options - BatchApiClientReplaceTaskOptions contains the optional parameters for the BatchApiClient.ReplaceTask method.
func (client *BatchApiClient) ReplaceTask(ctx context.Context, jobID string, taskID string, task BatchTask, options *BatchApiClientReplaceTaskOptions) (BatchApiClientReplaceTaskResponse, error) {
	var err error
	req, err := client.replaceTaskCreateRequest(ctx, jobID, taskID, task, options)
	if err != nil {
		return BatchApiClientReplaceTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientReplaceTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientReplaceTaskResponse{}, err
	}
	resp, err := client.replaceTaskHandleResponse(httpResp)
	return resp, err
}

// replaceTaskCreateRequest creates the ReplaceTask request.
func (client *BatchApiClient) replaceTaskCreateRequest(ctx context.Context, jobID string, taskID string, task BatchTask, options *BatchApiClientReplaceTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, task); err != nil {
	return nil, err
}
	return req, nil
}

// replaceTaskHandleResponse handles the ReplaceTask response.
func (client *BatchApiClient) replaceTaskHandleResponse(resp *http.Response) (BatchApiClientReplaceTaskResponse, error) {
	result := BatchApiClientReplaceTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientReplaceTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// ResizePool - Changes the number of Compute Nodes that are assigned to a Pool.
//   - poolID - The ID of the Pool to get.
//   - content - The options to use for resizing the pool.
//   - options - BatchApiClientResizePoolOptions contains the optional parameters for the BatchApiClient.ResizePool method.
func (client *BatchApiClient) ResizePool(ctx context.Context, poolID string, content BatchPoolResizeContent, options *BatchApiClientResizePoolOptions) (BatchApiClientResizePoolResponse, error) {
	var err error
	req, err := client.resizePoolCreateRequest(ctx, poolID, content, options)
	if err != nil {
		return BatchApiClientResizePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientResizePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientResizePoolResponse{}, err
	}
	resp, err := client.resizePoolHandleResponse(httpResp)
	return resp, err
}

// resizePoolCreateRequest creates the ResizePool request.
func (client *BatchApiClient) resizePoolCreateRequest(ctx context.Context, poolID string, content BatchPoolResizeContent, options *BatchApiClientResizePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/resize"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// resizePoolHandleResponse handles the ResizePool response.
func (client *BatchApiClient) resizePoolHandleResponse(resp *http.Response) (BatchApiClientResizePoolResponse, error) {
	result := BatchApiClientResizePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientResizePoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// StopPoolResize - Stops an ongoing resize operation on the Pool.
//   - poolID - The ID of the Pool to get.
//   - options - BatchApiClientStopPoolResizeOptions contains the optional parameters for the BatchApiClient.StopPoolResize method.
func (client *BatchApiClient) StopPoolResize(ctx context.Context, poolID string, options *BatchApiClientStopPoolResizeOptions) (BatchApiClientStopPoolResizeResponse, error) {
	var err error
	req, err := client.stopPoolResizeCreateRequest(ctx, poolID, options)
	if err != nil {
		return BatchApiClientStopPoolResizeResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientStopPoolResizeResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientStopPoolResizeResponse{}, err
	}
	resp, err := client.stopPoolResizeHandleResponse(httpResp)
	return resp, err
}

// stopPoolResizeCreateRequest creates the StopPoolResize request.
func (client *BatchApiClient) stopPoolResizeCreateRequest(ctx context.Context, poolID string, options *BatchApiClientStopPoolResizeOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/stopresize"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// stopPoolResizeHandleResponse handles the StopPoolResize response.
func (client *BatchApiClient) stopPoolResizeHandleResponse(resp *http.Response) (BatchApiClientStopPoolResizeResponse, error) {
	result := BatchApiClientStopPoolResizeResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientStopPoolResizeResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// TerminateJob - Terminates the specified Job, marking it as completed.
//   - jobID - The ID of the Job to terminate.
//   - options - BatchApiClientTerminateJobOptions contains the optional parameters for the BatchApiClient.TerminateJob method.
func (client *BatchApiClient) TerminateJob(ctx context.Context, jobID string, options *BatchApiClientTerminateJobOptions) (BatchApiClientTerminateJobResponse, error) {
	var err error
	req, err := client.terminateJobCreateRequest(ctx, jobID, options)
	if err != nil {
		return BatchApiClientTerminateJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientTerminateJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientTerminateJobResponse{}, err
	}
	resp, err := client.terminateJobHandleResponse(httpResp)
	return resp, err
}

// terminateJobCreateRequest creates the TerminateJob request.
func (client *BatchApiClient) terminateJobCreateRequest(ctx context.Context, jobID string, options *BatchApiClientTerminateJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/terminate"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if options != nil && options.Parameters != nil {
	if err := runtime.MarshalAsJSON(req, *options.Parameters); err != nil {
	return nil, err
}
		return req, nil
	}
	return req, nil
}

// terminateJobHandleResponse handles the TerminateJob response.
func (client *BatchApiClient) terminateJobHandleResponse(resp *http.Response) (BatchApiClientTerminateJobResponse, error) {
	result := BatchApiClientTerminateJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientTerminateJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// TerminateJobSchedule - Terminates a Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule to terminates.
//   - options - BatchApiClientTerminateJobScheduleOptions contains the optional parameters for the BatchApiClient.TerminateJobSchedule
//     method.
func (client *BatchApiClient) TerminateJobSchedule(ctx context.Context, jobScheduleID string, options *BatchApiClientTerminateJobScheduleOptions) (BatchApiClientTerminateJobScheduleResponse, error) {
	var err error
	req, err := client.terminateJobScheduleCreateRequest(ctx, jobScheduleID, options)
	if err != nil {
		return BatchApiClientTerminateJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientTerminateJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusAccepted) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientTerminateJobScheduleResponse{}, err
	}
	resp, err := client.terminateJobScheduleHandleResponse(httpResp)
	return resp, err
}

// terminateJobScheduleCreateRequest creates the TerminateJobSchedule request.
func (client *BatchApiClient) terminateJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, options *BatchApiClientTerminateJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}/terminate"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// terminateJobScheduleHandleResponse handles the TerminateJobSchedule response.
func (client *BatchApiClient) terminateJobScheduleHandleResponse(resp *http.Response) (BatchApiClientTerminateJobScheduleResponse, error) {
	result := BatchApiClientTerminateJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientTerminateJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// TerminateTask - Terminates the specified Task.
//   - jobID - The ID of the Job containing the Task.
//   - taskID - The ID of the Task to terminate.
//   - options - BatchApiClientTerminateTaskOptions contains the optional parameters for the BatchApiClient.TerminateTask method.
func (client *BatchApiClient) TerminateTask(ctx context.Context, jobID string, taskID string, options *BatchApiClientTerminateTaskOptions) (BatchApiClientTerminateTaskResponse, error) {
	var err error
	req, err := client.terminateTaskCreateRequest(ctx, jobID, taskID, options)
	if err != nil {
		return BatchApiClientTerminateTaskResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientTerminateTaskResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusNoContent) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientTerminateTaskResponse{}, err
	}
	resp, err := client.terminateTaskHandleResponse(httpResp)
	return resp, err
}

// terminateTaskCreateRequest creates the TerminateTask request.
func (client *BatchApiClient) terminateTaskCreateRequest(ctx context.Context, jobID string, taskID string, options *BatchApiClientTerminateTaskOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}/tasks/{taskId}/terminate"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	if taskID == "" {
		return nil, errors.New("parameter taskID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{taskId}", url.PathEscape(taskID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	return req, nil
}

// terminateTaskHandleResponse handles the TerminateTask response.
func (client *BatchApiClient) terminateTaskHandleResponse(resp *http.Response) (BatchApiClientTerminateTaskResponse, error) {
	result := BatchApiClientTerminateTaskResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientTerminateTaskResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UpdateJob - Updates the properties of the specified Job.
//   - jobID - The ID of the Job whose properties you want to update.
//   - job - The options to use for updating the Job.
//   - options - BatchApiClientUpdateJobOptions contains the optional parameters for the BatchApiClient.UpdateJob method.
func (client *BatchApiClient) UpdateJob(ctx context.Context, jobID string, job BatchJobUpdateContent, options *BatchApiClientUpdateJobOptions) (BatchApiClientUpdateJobResponse, error) {
	var err error
	req, err := client.updateJobCreateRequest(ctx, jobID, job, options)
	if err != nil {
		return BatchApiClientUpdateJobResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientUpdateJobResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientUpdateJobResponse{}, err
	}
	resp, err := client.updateJobHandleResponse(httpResp)
	return resp, err
}

// updateJobCreateRequest creates the UpdateJob request.
func (client *BatchApiClient) updateJobCreateRequest(ctx context.Context, jobID string, job BatchJobUpdateContent, options *BatchApiClientUpdateJobOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobs/{jobId}"
	if jobID == "" {
		return nil, errors.New("parameter jobID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobId}", url.PathEscape(jobID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, job); err != nil {
	return nil, err
}
	return req, nil
}

// updateJobHandleResponse handles the UpdateJob response.
func (client *BatchApiClient) updateJobHandleResponse(resp *http.Response) (BatchApiClientUpdateJobResponse, error) {
	result := BatchApiClientUpdateJobResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientUpdateJobResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UpdateJobSchedule - Updates the properties of the specified Job Schedule.
//   - jobScheduleID - The ID of the Job Schedule to update.
//   - jobSchedule - The options to use for updating the Job Schedule.
//   - options - BatchApiClientUpdateJobScheduleOptions contains the optional parameters for the BatchApiClient.UpdateJobSchedule
//     method.
func (client *BatchApiClient) UpdateJobSchedule(ctx context.Context, jobScheduleID string, jobSchedule BatchJobScheduleUpdateContent, options *BatchApiClientUpdateJobScheduleOptions) (BatchApiClientUpdateJobScheduleResponse, error) {
	var err error
	req, err := client.updateJobScheduleCreateRequest(ctx, jobScheduleID, jobSchedule, options)
	if err != nil {
		return BatchApiClientUpdateJobScheduleResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientUpdateJobScheduleResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientUpdateJobScheduleResponse{}, err
	}
	resp, err := client.updateJobScheduleHandleResponse(httpResp)
	return resp, err
}

// updateJobScheduleCreateRequest creates the UpdateJobSchedule request.
func (client *BatchApiClient) updateJobScheduleCreateRequest(ctx context.Context, jobScheduleID string, jobSchedule BatchJobScheduleUpdateContent, options *BatchApiClientUpdateJobScheduleOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/jobschedules/{jobScheduleId}"
	if jobScheduleID == "" {
		return nil, errors.New("parameter jobScheduleID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{jobScheduleId}", url.PathEscape(jobScheduleID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, jobSchedule); err != nil {
	return nil, err
}
	return req, nil
}

// updateJobScheduleHandleResponse handles the UpdateJobSchedule response.
func (client *BatchApiClient) updateJobScheduleHandleResponse(resp *http.Response) (BatchApiClientUpdateJobScheduleResponse, error) {
	result := BatchApiClientUpdateJobScheduleResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientUpdateJobScheduleResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UpdatePool - Updates the properties of the specified Pool.
//   - poolID - The ID of the Pool to get.
//   - pool - The pool properties to update.
//   - options - BatchApiClientUpdatePoolOptions contains the optional parameters for the BatchApiClient.UpdatePool method.
func (client *BatchApiClient) UpdatePool(ctx context.Context, poolID string, pool BatchPoolUpdateContent, options *BatchApiClientUpdatePoolOptions) (BatchApiClientUpdatePoolResponse, error) {
	var err error
	req, err := client.updatePoolCreateRequest(ctx, poolID, pool, options)
	if err != nil {
		return BatchApiClientUpdatePoolResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientUpdatePoolResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientUpdatePoolResponse{}, err
	}
	resp, err := client.updatePoolHandleResponse(httpResp)
	return resp, err
}

// updatePoolCreateRequest creates the UpdatePool request.
func (client *BatchApiClient) updatePoolCreateRequest(ctx context.Context, poolID string, pool BatchPoolUpdateContent, options *BatchApiClientUpdatePoolOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.IfMatch != nil {
		req.Raw().Header["If-Match"] = []string{*options.IfMatch}
	}
	if options != nil && options.IfModifiedSince != nil {
		req.Raw().Header["If-Modified-Since"] = []string{options.IfModifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.IfNoneMatch != nil {
		req.Raw().Header["If-None-Match"] = []string{*options.IfNoneMatch}
	}
	if options != nil && options.IfUnmodifiedSince != nil {
		req.Raw().Header["If-Unmodified-Since"] = []string{options.IfUnmodifiedSince.Format(time.RFC1123)}
	}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, pool); err != nil {
	return nil, err
}
	return req, nil
}

// updatePoolHandleResponse handles the UpdatePool response.
func (client *BatchApiClient) updatePoolHandleResponse(resp *http.Response) (BatchApiClientUpdatePoolResponse, error) {
	result := BatchApiClientUpdatePoolResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("DataServiceId"); val != "" {
		result.DataServiceID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientUpdatePoolResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	return result, nil
}

// UploadNodeLogs - Upload Azure Batch service log files from the specified Compute Node to Azure
// Blob Storage.
//   - poolID - The ID of the Pool that contains the Compute Node.
//   - nodeID - The ID of the Compute Node for which you want to get the Remote Desktop
//     Protocol file.
//   - content - The Azure Batch service log files upload options.
//   - options - BatchApiClientUploadNodeLogsOptions contains the optional parameters for the BatchApiClient.UploadNodeLogs method.
func (client *BatchApiClient) UploadNodeLogs(ctx context.Context, poolID string, nodeID string, content UploadBatchServiceLogsContent, options *BatchApiClientUploadNodeLogsOptions) (BatchApiClientUploadNodeLogsResponse, error) {
	var err error
	req, err := client.uploadNodeLogsCreateRequest(ctx, poolID, nodeID, content, options)
	if err != nil {
		return BatchApiClientUploadNodeLogsResponse{}, err
	}
	httpResp, err := client.internal.Pipeline().Do(req)
	if err != nil {
		return BatchApiClientUploadNodeLogsResponse{}, err
	}
	if !runtime.HasStatusCode(httpResp, http.StatusOK) {
		err = runtime.NewResponseError(httpResp)
		return BatchApiClientUploadNodeLogsResponse{}, err
	}
	resp, err := client.uploadNodeLogsHandleResponse(httpResp)
	return resp, err
}

// uploadNodeLogsCreateRequest creates the UploadNodeLogs request.
func (client *BatchApiClient) uploadNodeLogsCreateRequest(ctx context.Context, poolID string, nodeID string, content UploadBatchServiceLogsContent, options *BatchApiClientUploadNodeLogsOptions) (*policy.Request, error) {
	host := "{endpoint}"
	host = strings.ReplaceAll(host, "{endpoint}", client.endpoint)
	urlPath := "/pools/{poolId}/nodes/{nodeId}/uploadbatchservicelogs"
	if poolID == "" {
		return nil, errors.New("parameter poolID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{poolId}", url.PathEscape(poolID))
	if nodeID == "" {
		return nil, errors.New("parameter nodeID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{nodeId}", url.PathEscape(nodeID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2024-02-01.19.0")
	if options != nil && options.TimeOutInSeconds != nil {
		reqQP.Set("timeOut", strconv.FormatInt(int64(*options.TimeOutInSeconds), 10))
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header["Accept"] = []string{"application/json"}
	if options != nil && options.ClientRequestID != nil {
		req.Raw().Header["client-request-id"] = []string{*options.ClientRequestID}
	}
	req.Raw().Header["Content-Type"] = []string{"application/json; odata=minimalmetadata"}
	if options != nil && options.Ocpdate != nil {
		req.Raw().Header["ocp-date"] = []string{options.Ocpdate.Format(time.RFC1123)}
	}
	if options != nil && options.ReturnClientRequestID != nil {
		req.Raw().Header["return-client-request-id"] = []string{strconv.FormatBool(*options.ReturnClientRequestID)}
	}
	if err := runtime.MarshalAsJSON(req, content); err != nil {
	return nil, err
}
	return req, nil
}

// uploadNodeLogsHandleResponse handles the UploadNodeLogs response.
func (client *BatchApiClient) uploadNodeLogsHandleResponse(resp *http.Response) (BatchApiClientUploadNodeLogsResponse, error) {
	result := BatchApiClientUploadNodeLogsResponse{}
	if val := resp.Header.Get("client-request-id"); val != "" {
		result.ClientRequestID = &val
	}
	if val := resp.Header.Get("ETag"); val != "" {
		result.ETag = &val
	}
	if val := resp.Header.Get("Last-Modified"); val != "" {
		lastModified, err := time.Parse(time.RFC1123, val)
		if err != nil {
			return BatchApiClientUploadNodeLogsResponse{}, err
		}
		result.LastModified = &lastModified
	}
	if val := resp.Header.Get("request-id"); val != "" {
		result.RequestID = &val
	}
	if err := runtime.UnmarshalAsJSON(resp, &result.UploadBatchServiceLogsResult); err != nil {
		return BatchApiClientUploadNodeLogsResponse{}, err
	}
	return result, nil
}

